<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · FinEtools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtools.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li class="is-active"><a class="tocitem" href="guide.html">Guide</a><ul class="internal"><li><a class="tocitem" href="#Break-down-into-modules"><span>Break down into modules</span></a></li><li><a class="tocitem" href="#Arithmetic-types"><span>Arithmetic types</span></a></li><li><a class="tocitem" href="#Physical-units"><span>Physical units</span></a></li><li><a class="tocitem" href="#Mesh-entities"><span>Mesh entities</span></a></li><li><a class="tocitem" href="#Mesh-generation"><span>Mesh generation</span></a></li><li><a class="tocitem" href="#Selection-of-mesh-entities"><span>Selection of mesh entities</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Finite-element"><span>Finite element</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li><li><a class="tocitem" href="#FEM-machines"><span>FEM machines</span></a></li><li><a class="tocitem" href="#Material-and-Material-Orientation"><span>Material and Material Orientation</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Queries-of-quadrature-point-data"><span>Queries of quadrature-point data</span></a></li><li><a class="tocitem" href="#Postprocessing"><span>Postprocessing</span></a></li><li><a class="tocitem" href="#Import/export"><span>Import/export</span></a></li><li><a class="tocitem" href="#Tutorials-and-Examples"><span>Tutorials and Examples</span></a></li><li><a class="tocitem" href="#Make-up-your-own-public-interface"><span>Make up your own public interface</span></a></li></ul></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="../man/types.html">Types</a></li><li><a class="tocitem" href="../man/functions.html">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="guide.html">Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="guide.html">Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/guide/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p><a href="https://petrkryslucsd.github.io/FinEtools.jl/latest/index.html">Table of contents</a></p><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><h2 id="Break-down-into-modules"><a class="docs-heading-anchor" href="#Break-down-into-modules">Break down into modules</a><a id="Break-down-into-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Break-down-into-modules" title="Permalink"></a></h2><p>The FinEtools package consists of many modules which fall into several  categories. The top-level module, <code>FinEtools</code>, includes all other modules and exports functions to constitute the public interface. The user is free to generate their own public interface, however. More details are provided in the section <a href="guide.html#Make-up-your-own-public-interface">Make up your own public interface</a>.</p><ul><li><p><strong>Top-level</strong>:     <code>FinEtools</code> is the  top-level module.  For interactive use   it is enough to do <code>using FinEtools</code>, however in some  cases functions from   modules need to be  brought into the scope individually (most importantly,   the algorithm modules). This is the ONLY  module that EXPORTS  functions,   none of the other modules exports a single function. The entire  public   (i. e. exported) interface of the FinEtools package is specified  in the   file <code>FinEtools.jl</code> (i. e. in the <code>FinEtools</code> module). The user is free to   specify his or her own set of exported functions from the FinEtools package   to create an <a href="guide/rollyourown.html">ad hoc public interface</a>.</p></li><li><p><strong>Utilities</strong>: Refer to the modules <code>FTypesModule</code> (definition of basic   numerical types), <code>PhysicalUnitModule</code> (for use with numbers specified   using physical units), <code>AssemblyModule</code> (assembly of elementwise matrices   and vectors),   <code>CSysModule</code> (coordinate system module),   <code>MatrixUtilityModule</code> (utilities for operations on elementwise matrices),   <code>BoxModule</code>  (support for working with bounding boxes),   <code>ForceIntensityModule</code> (force-intensity module), <code>RotationUtilModule</code>   (support for spatial rotations).</p></li><li><p><strong>Mesh  entities</strong>:  <code>FENodeSetModule</code>, <code>FESetModule</code> (node set and finite element set  types). </p></li><li><p><strong>Mesh Generation</strong>:   <code>MeshLineModule</code>,  <code>MeshQuadrilateralModule</code>,   <code>MeshTriangleModule</code>,   <code>MeshTetrahedronModule</code>, <code>MeshHexahedronModule</code>,   <code>VoxelBoxModule</code>. </p></li><li><p><strong>Mesh manipulation</strong>:  <code>MeshSelectionModule</code> (searching of nodes  and   elements),  <code>MeshModificationModule</code> (mesh boundary, merging  of meshes and   nodes, smoothing, partitioning),  <code>MeshUtilModule</code>   (utilities), <code>FENodeToFEMapModule</code> (search structure from nodes to   elements).</p></li><li><p><strong>Mesh import/export</strong>:  <code>MeshImportModule</code>,  <code>MeshExportModule</code>.</p></li><li><p><strong>Fields</strong>:   <code>FieldModule</code>,    <code>GeneralFieldModule</code>, <code>ElementalFieldModule</code>,   <code>NodalFieldModule</code> (modules for representing quantities on the mesh).</p></li><li><p><strong>Integration</strong>: Support for  integration over solids, surfaces, curves, and   points: <code>IntegRuleModule</code>,   <code>IntegDomainModule</code>.</p></li><li><p><strong>General algorithms</strong>: <code>AlgoBaseModule</code> (algorithms), <code>FEMMBaseModule</code>   (FEM machine for general tasks).</p></li></ul><h2 id="Arithmetic-types"><a class="docs-heading-anchor" href="#Arithmetic-types">Arithmetic types</a><a id="Arithmetic-types-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-types" title="Permalink"></a></h2><p>The FinEtools package tries to make typing arguments easier. The arithmetic types used throughout are <code>FInt</code> for integer data, <code>FFlt</code> for floating-point data, and <code>Complex{FFlt}</code> for applications that work with complex linear algebra quantities.</p><p>The module <code>FTypesModule</code> defines these types, and also defines abbreviations for vectors and matrices with entries of these types.</p><p>Some algorithms expect input in the form of the data dictionary, <code>FDataDict</code>, and also produce output in this form.</p><h2 id="Physical-units"><a class="docs-heading-anchor" href="#Physical-units">Physical units</a><a id="Physical-units-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-units" title="Permalink"></a></h2><p>The <code>PhysicalUnitModule</code> provides a simple function, <code>phun</code>, which can help with providing input numbers with the correct conversion between physical units. For instance, it is possible to specify the input data as</p><pre><code class="language-julia hljs">E = 200*phun(&quot;GPa&quot;);# Young&#39;s modulus
nu = 0.3;# Poisson ratio
rho = 8000*phun(&quot;KG*M^-3&quot;);# mass density
L = 10.0*phun(&quot;M&quot;); # side of the square plate
t = 0.05*phun(&quot;M&quot;); # thickness of the square plate</code></pre><p>A few common sets of units are included, <code>:US</code>, <code>:IMPERIAL</code>, <code>:CGS</code>, <code>:SIMM</code> (millimeter-based SI units), and <code>:SI</code> (meter-based SI units). The resulting  values assigned to the variables are floating-point numbers, for instance</p><pre><code class="language-julia hljs">julia&gt; E = 200*phun(&quot;GPa&quot;)
2.0e11</code></pre><p>Numbers output by the simulation can also be converted  to appropriate units for printing as</p><pre><code class="language-julia hljs">julia&gt; E/phun(&quot;MPa&quot;)
200000.0</code></pre><h2 id="Mesh-entities"><a class="docs-heading-anchor" href="#Mesh-entities">Mesh entities</a><a id="Mesh-entities-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-entities" title="Permalink"></a></h2><p>The mesh consists of one set of finite element nodes  and one or more sets of finite elements.</p><p>One of the  organizing principles of the  finite element collection  is that  finite elements can appear as representations of the interior  of the domain, but in a different model as parts of the boundary.  Thus  for instance  4-node  quadrilaterals  are finite elements that represent cross-sections of  axially symmetric models or surfaces  of membranes,  but they are also the boundaries of hexahedral  models.</p><p>A mesh  is generated by one of the functions specialized to a particular finite element type. Thus there are  <a href="guide/meshgen.md">mesh generation</a> functions for lines, triangles, quadrilaterals, tetrahedra, and hexahedra.</p><h2 id="Mesh-generation"><a class="docs-heading-anchor" href="#Mesh-generation">Mesh generation</a><a id="Mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation" title="Permalink"></a></h2><p>As an example,  the following code generates a hexahedral mesh of simple rectangular block.</p><pre><code class="language-julia hljs">fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc)</code></pre><p>The finite element node set and the finite element set  are returned. More complicated meshes can be constructed from such mesh parts. There are  functions for  merging  nodes  and even multiple meshes together.</p><p>The code snippet below  constructs the mesh of an  L-shaped  domain  from  the meshes of three rectangles.</p><pre><code class="language-julia hljs">W = 100. # width of the leg
L = 200. # length of the leg
nL = 15 # number of elements along the length of the leg
nW = 10 # number of elements along the width
tolerance = W / nW / 1.0e5 # tolerance for merging nodes
Meshes = Array{Tuple{FENodeSet,FESet},1}()
push!(Meshes, Q4quadrilateral([0.0 0.0; W W], nW, nW))
push!(Meshes, Q4quadrilateral([-L 0.0; 0.0 W], nL, nW))
push!(Meshes, Q4quadrilateral([0.0 -L; W 0.0], nW, nL))
fens, outputfes = mergenmeshes(Meshes, tolerance);
fes = cat(outputfes[1], cat(outputfes[2], outputfes[3]))</code></pre><p>As an example of the  merging  of nodes to create  the final mesh, consider the creation of  a closed hollow tube.</p><pre><code class="language-julia hljs">fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc) # generate a block
# Shape into a cylinder
R = zeros(3, 3)
for i = 1:count(fens)
    x, y, z = fens.xyz[i,:];
    rotmat3!(R, [0, z, 0])
    Q = [cos(psi * pi / 180) sin(psi * pi / 180) 0;
        -sin(psi * pi / 180) cos(psi * pi / 180) 0;
        0 0 1]
    fens.xyz[i,:] = reshape([x + Rmed - h / 2, y - l / 2, 0], 1, 3) * Q * R;
end
# Merge the nodes where the tube  closes up
candidates = selectnode(fens, box = boundingbox([Rmed - h -Inf 0.0; Rmed + h +Inf 0.0]), inflate = tolerance)
fens, fes = mergenodes(fens, fes,  tolerance, candidates);</code></pre><p>The final mesh used for a simulation  consists of a <em>single  node set</em> and <em>one or more finite element sets</em>. The  finite elements may be  divided into separate sets  to  accommodate different material properties, different orientations of the material  coordinate systems, or different formulations  of the discrete model. The  assignment  of the finite elements to sets  may be based on geometrical proximity, topological connections, or some other characteristic. See the  &quot;mesh selection&quot; <a href="guide/selection.html">discussion</a> for details.</p><h3 id="Structured-mesh-generation"><a class="docs-heading-anchor" href="#Structured-mesh-generation">Structured mesh generation</a><a id="Structured-mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-mesh-generation" title="Permalink"></a></h3><p>The simplest possible meshes can be generated in the form of one-dimensional, two-dimensional, and three-dimensional blocks. The spacing of the nodes can be either uniform (for instance <code>Q8block</code>), or the spacing can be given with an arbitrary distribution (for instance <code>Q4blockx</code>). Meshes of tetrahedra can be generated in various orientations of the &quot;diagonals&quot;.</p><p>More complex meshes can be generated for certain element types: for instance an annulus (<code>Q4annulus</code>), quarter of a plate with a hole (<code>Q4elliphole</code>), quarter of a sphere (<code>H8spheren</code>), layered plate (<code>H8layeredplatex</code>).</p><p>Hexahedral meshes can also be created by extrusion of  quadrilateral meshes (<code>H8extrudeQ4</code>).</p><h3 id="Shaping"><a class="docs-heading-anchor" href="#Shaping">Shaping</a><a id="Shaping-1"></a><a class="docs-heading-anchor-permalink" href="#Shaping" title="Permalink"></a></h3><p>Simple meshes  such as blocks can be deformed into geometrically complex shapes, for instance  by tapering  or other relocation of the nodes. For instance, we can generate a block  and then bend it  into one quarter  of  an annulus as</p><pre><code class="language-julia hljs">fens,fes = Q4block(rex-rin,pi/2,5,20);
for i=1:count(fens)
    r=rin+fens.xyz[i,1]; a=fens.xyz[i,2];
    fens.xyz[i,:]=[r*cos(a) r*sin(a)];
end</code></pre><h3 id="Merging"><a class="docs-heading-anchor" href="#Merging">Merging</a><a id="Merging-1"></a><a class="docs-heading-anchor-permalink" href="#Merging" title="Permalink"></a></h3><p>Multiple mesh regions  can be generated and then merged together into a single mesh. Refer to the <code>MeshModificationModule</code>. Meshes can be also mirrored.</p><h3 id="Boundary-extraction"><a class="docs-heading-anchor" href="#Boundary-extraction">Boundary extraction</a><a id="Boundary-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-extraction" title="Permalink"></a></h3><p>Mesh  composed of  any element type can be passed to the function  <code>meshboundary</code>, and  the boundary of the mesh is extracted. As an example, the code</p><pre><code class="language-julia hljs">fens,fes = Q4block(rex-rin,pi/2,5,20);
bdryfes = meshboundary(fes);</code></pre><p>generates a mesh of quadrilaterals in the set <code>fes</code>,  and <code>bdryfes = meshboundary(fes)</code> finds the boundary elements of the type L2 (line elements with two nodes) and stores them in the  finite element set <code>bdryfes</code>.</p><h3 id="Conversion-between-element-types"><a class="docs-heading-anchor" href="#Conversion-between-element-types">Conversion  between element types</a><a id="Conversion-between-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-element-types" title="Permalink"></a></h3><p>For any element shape  (line, triangle,  quadrilateral, hexahedron, tetrahedron) there is  the linear version and the quadratic version. Conversion routines are provided so that, for example, mesh can be generated as eight-node  hexahedra  and then converted  to twenty-node hexahedra as</p><pre><code class="language-julia hljs">fens, fes = H8toH20(fens, fes)</code></pre><p>Other conversion routines can convert triangles to quadrilaterals, tetrahedra to hexahedra, and so on.</p><h3 id="Refinement"><a class="docs-heading-anchor" href="#Refinement">Refinement</a><a id="Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Refinement" title="Permalink"></a></h3><p>Meshes composed of some  element types can be uniformly refined. For instance, quadrilateral meshes can be refined by bisection with <code>Q4refine</code>.</p><h2 id="Selection-of-mesh-entities"><a class="docs-heading-anchor" href="#Selection-of-mesh-entities">Selection of mesh entities</a><a id="Selection-of-mesh-entities-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-of-mesh-entities" title="Permalink"></a></h2><p>There are many instances of problem definitions where it is important to partition meshes into subsets. As an example,  consider a tube consisting of inner ABS core and  outer fiber-reinforced  laminate  layer. The mesh may consist  of hexahedra.  This mesh would then need to be partitioned into two subsets, because the materials and the  material orientation data  are different between the two regions.</p><p>As another example, consider a simple beam  of rectangular cross-section, clamped  at one end,  and  loaded with shear tractions at the  free end. The  entire boundary of the beam needs to be separated  into three subsets:  the first subset,  for the traction-free boundary, is ignored. The second subset, for the clamped cross-section, is extracted  and  its nodes  are used  to  formulate the essential boundary condition. The third subset is extracted and used to define an FEM machine to compute the load vector due to the shear traction.</p><p>There are  several  ways  in which mesh entities (nodes and finite elements) can be selected. The simplest uses element labels: some mesh-generation routines label the generated elements. For example,</p><pre><code class="language-julia hljs">fens,fes = H8layeredplatex(xs, ys, ts, nts)</code></pre><p>generates a plate-like mesh where the layers are labeled. It is therefore possible to select  the bottom-most layer as</p><pre><code class="language-julia hljs">rls = selectelem(fens, fes, label = 1)</code></pre><p>where <code>rls</code> is a list of integer indexes into the  set <code>fes</code>, so that we can extract a subset corresponding to this layer as</p><pre><code class="language-julia hljs">botskin = subset(fes, rls)</code></pre><p>Geometrical techniques for selecting finite elements  or nodes can be based on</p><ul><li>the location within or overlap  with boxes;</li><li>distance from  a given point;</li><li>distance from a given plane;</li><li>connectedness (selection by flooding).</li></ul><p>Additionally, surface-like  finite elements (quadrilaterals and triangles embedded in three dimensions), or lines embedded in two dimensions, can be selected based upon the orientation of their normal (<code>facing</code>  criterion).</p><p>As an example, consider a straight duct with anechoic termination. A triangle mesh is generated as</p><pre><code class="language-julia hljs">fens,fes  =  T3block(Lx,Ly,n,2);</code></pre><p>and its boundary is extracted as</p><pre><code class="language-julia hljs">bfes  =  meshboundary(fes)</code></pre><p>The finite elements from the  piece of the boundary on the left parallel to the Y axis can be extracted as</p><pre><code class="language-julia hljs">L0 = selectelem(fens,bfes,facing = true, direction = [-1.0 0.0])</code></pre><p>where the numbers of the finite elements  whose normals point in the general direction of the vector [-1.0 0.0] are returned in the integer array <code>L0</code>.</p><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>The structure to maintain the numbering  and values of the degrees of freedom in the mesh  is the field. Consider for instance the temperature field: we write</p><p class="math-container">\[T(x) = \sum_i N_i(x) T_i\]</p><p>The understanding is that <span>$T_i$</span> are the degrees of freedom, and the basis functions <span>$N_i(x)$</span> are defined implicitly by the finite element mesh. (More about basis functions below.) Each element has its own set of functions, which when multiplied by the degree of freedom values describe the temperature over each individual finite element. The basis functions are implicitly associated with the nodes of the finite elements. The degrees of freedom are also (explicitly) associated with the nodes. The field may also be generalized a bit by extending the above sum simply to entities of the mesh, not only the nodes, but perhaps also the elements.</p><p>The role of the field is then to maintain the correspondence between the entities and the numbers and values of the degrees of freedom.</p><h3 id="Abstract-Field"><a class="docs-heading-anchor" href="#Abstract-Field">Abstract  Field</a><a id="Abstract-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Field" title="Permalink"></a></h3><p>The assumption is that a field has one set of degrees of freedom per node or per element. For simplicity we will refer to the nodes and elements as entities. It assumes that concrete  subtypes of the abstract field  have the following data, one row per entity:</p><ul><li><code>values::FMat{T}</code>: Array of the values of the degrees of freedom, one row  for each entity. All the arrays below have the same dimensions as this one.</li><li><code>dofnums::FIntMat</code>: Array  of the numbers of the free degrees of freedom. If the degree of freedom is fixed (prescribed), the corresponding entry is zero.</li><li><code>is_fixed::Matrix{Bool}</code>: Array of  Boolean flags,  <code>true</code> for fixed  (prescribed) degrees of freedom, <code>false</code> otherwise.</li><li><code>fixed_values::FMat{T}</code>: Array  of the same size and type  as  <code>values</code>. Its entries are only relevant  for the fixed (prescribed)  degrees of freedom.</li><li><code>nfreedofs::FInt</code>:  the total number of free degrees of freedom.</li></ul><p>The methods defined for the abstract field  include:</p><ul><li><p>Return the number of degrees of freedom and the number of entities.</p></li><li><p>Gather and scatter the system vector.</p></li><li><p>Gather elementwise  vectors or matrices of values, the degree of freedom numbers, or the fixed values of the degrees of freedom.</p></li><li><p>Set  or clear essential boundary conditions.</p></li><li><p>Copy a field. Clear the entries of the field.</p></li></ul><h3 id="Nodal-Field"><a class="docs-heading-anchor" href="#Nodal-Field">Nodal Field</a><a id="Nodal-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Nodal-Field" title="Permalink"></a></h3><p>In this case  the  abstract field is subtyped to a concrete field where the entities are nodes.</p><h3 id="Elemental-Field"><a class="docs-heading-anchor" href="#Elemental-Field">Elemental Field</a><a id="Elemental-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Elemental-Field" title="Permalink"></a></h3><p>In this case  the  abstract field  is subtyped to a concrete field where the entities are the elements.</p><h3 id="General-Field"><a class="docs-heading-anchor" href="#General-Field">General Field</a><a id="General-Field-1"></a><a class="docs-heading-anchor-permalink" href="#General-Field" title="Permalink"></a></h3><p>In this case  the  abstract field  is subtyped to a concrete field where the entities are  use-case  specific.</p><h3 id="Numbering-of-the-degrees-of-freedom"><a class="docs-heading-anchor" href="#Numbering-of-the-degrees-of-freedom">Numbering of the degrees of freedom</a><a id="Numbering-of-the-degrees-of-freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Numbering-of-the-degrees-of-freedom" title="Permalink"></a></h3><p>The simplest method is at the moment implemented: number all free degrees of freedom, row-by-row and column-by-column, starting from 1 up to <code>f.nfreedofs</code>, for the field <code>f</code>.</p><p>The prescribed degrees of freedom are not numbered, and are marked with the &quot;degree of freedom number&quot; 0.</p><p>There is also a method to supply the numbering of the nodes, perhaps  resulting from the Reverse Cuthill-McKee permutation. This may be useful when using LU or LDLT factorization as the fill-in may be minimized.</p><h2 id="Finite-element"><a class="docs-heading-anchor" href="#Finite-element">Finite element</a><a id="Finite-element-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element" title="Permalink"></a></h2><p>The  finite element set is one of the basic entities in <code>FinEtools</code>. It is a homogeneous collection of  finite elements defined by the connectivity (collection of node numbers, listing the nodes connected by the element in  a specific order). The finite element set  provides  specialized methods  to compute the values of basis functions and the values of  the gradients of the basis functions  with respect to the parametric coordinates.</p><h3 id="Element-types"><a class="docs-heading-anchor" href="#Element-types">Element types</a><a id="Element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Element-types" title="Permalink"></a></h3><p>The finite element sets are instances of concrete types. Each particular shape and order of element has its own type. There are types for  linear  and quadratic quadrilaterals, for instance, <code>FESetQ4</code> and <code>FESetQ8</code>. Each element set provides access to the number of nodes  connected by the element (<code>nodesperelem</code>),  the connectivity as the two dimensional array    <code>conn</code>,  and the  integer label vector <code>label</code>.</p><p>The concrete finite element set types are subtypes of the abstract type for elements of different manifold dimension (3, 2, 1, and 0), for instance for the quadrilaterals that would be <code>AbstractFESet2Manifold</code>. These types are in turn  subtypes of the abstract finite element set type <code>AbstractFESet</code>.</p><p>The concrete finite element set type provides specialized methods to compute the values of the basis functions, <code>bfun</code>, and methods to compute  the gradients of the basis functions with respect to the parametric coordinates, <code>bfundpar</code>. <code>FinEtools</code> at the moment supports only the so-called <strong>nodal</strong> basis functions: each basis function is associated with a node. And that is  true both globally (in the sense that each basis function is globally supported),  and locally over each finite element, and all such functions are  1 at its own node, and zero at all the other nodes.</p><h3 id="Finite-element-set-functions"><a class="docs-heading-anchor" href="#Finite-element-set-functions">Finite element set functions</a><a id="Finite-element-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-set-functions" title="Permalink"></a></h3><ul><li><p>Methods defined for  the abstract type:</p><ul><li><code>nodesperelem</code>: Get the number of nodes  connected  by  the finite element.</li><li><code>count</code>:  Get the number of individual connectivities in the FE set.</li><li><code>setlabel!</code>: Set the label of the entire finite elements set.</li><li><code>connasarray</code>: Retrieve  connectivity  as an integer array.</li><li><code>fromarray!</code>: Set  connectivity from an integer array.</li><li><code>subset</code>: Extract a subset of the finite elements from the given finite element set.</li><li><code>cat</code>: Concatenate the connectivities of two FE sets.</li><li><code>updateconn!</code>: Update the connectivity after the IDs of nodes changed.</li><li><code>map2parametric</code>: Map a spatial location to parametric coordinates.</li></ul></li><li><p>Methods dispatched based on the manifold type:</p><ul><li><code>manifdim</code>: Return the manifold dimension.</li><li><code>Jacobian</code>: Evaluate the  Jacobian.</li><li><code>gradN!</code>: Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</li></ul></li><li><p>Methods dispatched on the concrete type:</p><ul><li><code>boundaryconn</code>: Get boundary connectivity.</li><li><code>boundaryfe</code>: Return the constructor of the type of the boundary finite element.</li><li><code>bfun</code>: Compute the values of the basis functions at a given parametric coordinate.</li><li><code>bfundpar</code>: Compute the values of the basis function gradients at a given parametric coordinate.</li><li><code>inparametric</code>: Are given parametric coordinates inside the element parametric domain?</li><li><code>centroidparametric</code>: Return the parametric coordinates  of the centroid of the element.</li></ul></li></ul><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p>There are two kinds of integrals in the weighted-residual finite element method: integrals over the <strong>interior</strong>  of the domain,  and integrals over the <strong>boundary</strong> of the domain.</p><p>Consequently, in a typical simulation one would need  two meshes: one for the interior  of the domain,  and one for the boundary. Obviously, the mesh for the boundary will be derived from the mesh  constructed for the interior.</p><p>Often only a part  of the entire boundary   is   used:  on some parts of the boundary  the  boundary condition is implied as homogeneous (i. e. zero). For instance, a traction-free boundary. Therefore the necessary integrals are typically evaluated over a subset of the entire boundary.</p><h3 id="Manifold-dimension"><a class="docs-heading-anchor" href="#Manifold-dimension">Manifold dimension</a><a id="Manifold-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Manifold-dimension" title="Permalink"></a></h3><p>Finite elements  have  a certain manifold dimension.  Tetrahedra  and hexahedra are three-manifolds, triangles and quadrilaterals are two-manifolds, triangles and quadrilaterals are two-manifolds, lines are one-manifolds, and points are zero-manifolds.</p><p>Elements are equipped with an &quot;other&quot; dimension attribute which boosts the manifold dimension to produce the required dimension for  the integration. For instance,  a line element can be equipped with an &quot;other&quot; dimension to represent a cross-section so that a volume integral can be evaluated over a line element. Or, a line element can be given an &quot;other&quot; dimension as a thickness to result in a physical dimension needed to evaluate a surface integral.</p><p>The &quot;other&quot;  dimension  has the following meaning  for finite elements of different manifold dimensions:</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Volume integral</th><th style="text-align: right">Surface integral</th></tr><tr><td style="text-align: right">3</td><td style="text-align: right">NA</td><td style="text-align: right">NA</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">Thickness</td><td style="text-align: right">NA</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">Cross-section</td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right">Volume</td><td style="text-align: right">Cross-section</td></tr></table><h3 id="Integration-over-the-interior"><a class="docs-heading-anchor" href="#Integration-over-the-interior">Integration  over the interior</a><a id="Integration-over-the-interior-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-over-the-interior" title="Permalink"></a></h3><p>The integrals are always  <em>volume</em> integrals. This means that for elements which are of  lower manifold dimension than three the &quot;other&quot;  dimension needs to compensate.</p><p>For  three-manifold finite elements (tetrahedra and hexahedra) the &quot;other&quot; dimension is always 1.0. This really means there is no &quot;other&quot; dimension to a volume-like element.</p><p>For  finite elements of manifold dimension  less than tthree, the  &quot;other&quot; dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Axially symmetric</th><th style="text-align: right">Plane 2D</th></tr><tr><td style="text-align: right">2</td><td style="text-align: right"><span>$2\pi r$</span></td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right"><span>$2\pi r\times$</span>  Thickness</td><td style="text-align: right">Cross-section</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right"><span>$2\pi r\times$</span> Cross-section</td><td style="text-align: right">Volume</td></tr></table><p>The integral  is approximated with numerical quadrature as</p><p class="math-container">\[\int_{\Omega} f dV \approx \sum_q f(\xi_q) J(\xi_q) W_q\]</p><p>Here <span>$f$</span>  is the integrand, <span>$f(\xi_q)$</span>  is the  value of the integrand  at the quadrature point, <span>$J(\xi_q)$</span>  is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the &quot;other&quot; dimension, and therefore it is the  <em>volume</em> Jacobian. (For the interior integrals the Jacobian  is computed by the <code>Jacobianvolume</code> method.)</p><h3 id="Integration-over-the-boundary"><a class="docs-heading-anchor" href="#Integration-over-the-boundary">Integration  over the boundary</a><a id="Integration-over-the-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-over-the-boundary" title="Permalink"></a></h3><p>The integrals are always  <em>surface</em> integrals. This means that for elements which are of  lower manifold dimension than two the &quot;other&quot;  dimension needs to compensate.</p><p>For  two-manifold finite elements (triangles and quadrilaterals) the &quot;other&quot; dimension is always 1.0. This really means there is no &quot;other&quot; dimension to a surface-like element.</p><p>For  finite elements of manifold dimension  less than two, the  &quot;other&quot; dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Axially symmetric</th><th style="text-align: right">Plane 2D</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right"><span>$2\pi r$</span></td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right"><span>$2\pi r\times$</span>   Thickness</td><td style="text-align: right">Cross-section</td></tr></table><p>The integral  is approximated with numerical quadrature as</p><p class="math-container">\[\int_{\partial \Omega} f dS \approx \sum_q f(\xi_q) J(\xi_q) W_q  \]</p><p>Here <span>$f$</span>  is the integrand, <span>$f(\xi_q)$</span> is the  value of the integrand  at the quadrature point, <span>$J(\xi_q)$</span> is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the &quot;other&quot; dimension, and therefore it is the  <em>surface</em> Jacobian. (For the boundary integrals the Jacobian  is computed by the <code>Jacobiansurface</code> method.)</p><h4 id="Example:-axially-symmetric-model,-line-element-L2"><a class="docs-heading-anchor" href="#Example:-axially-symmetric-model,-line-element-L2">Example: axially symmetric model, line element L2</a><a id="Example:-axially-symmetric-model,-line-element-L2-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-axially-symmetric-model,-line-element-L2" title="Permalink"></a></h4><p>The surface Jacobian in this case  is  equal to the curve Jacobian times <code>2*pi*r</code>.</p><h3 id="Integration-Domain"><a class="docs-heading-anchor" href="#Integration-Domain">Integration Domain</a><a id="Integration-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Domain" title="Permalink"></a></h3><p>As explained above, integrating over the interior or the boundary may mean different things based on the features of the solution domain: axially symmetric?, plane strain or plane stress?, and so forth.</p><p>The  module <code>IntegDomainModule</code> supports  the processing of  the geometry necessary for the evaluation of the various integrals. The module data structure  groups together  a finite element set with an appropriate integration rule, information about the model (axially symmetric or not), and a callback to evaluate  the &quot;other&quot; dimension.</p><h3 id="Other-dimension"><a class="docs-heading-anchor" href="#Other-dimension">Other dimension</a><a id="Other-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Other-dimension" title="Permalink"></a></h3><p>The  discussion of the surface and volume integrals introduces the notion  of the  &quot;other&quot;  dimension. In order to evaluate Jacobians of various space dimensions  the  Geometry Data module takes into account  whether or not the model is axially symmetric, and evaluates the &quot;other&quot; dimension based upon this information.</p><p>A finite element set is equipped with  a way of  calculating  the &quot;other&quot; dimension.  For instance, the line element with two nodes, L2, can be given  the &quot;other&quot; dimension  as a  &quot;thickness&quot;  so that  surface integrals  can be evaluated over the line element. However, if this line element  is used in an axially symmetric model, the same  &quot;other&quot; dimension  of &quot;thickness&quot;  will result in the integral  along the length of this line element  being a volume integral.</p><p>Thus, the way in which the &quot;other&quot;  dimension gets used by the integration domain methods depends on the model. As an example, consider  the  method</p><pre><code class="language-julia hljs">function Jacobianvolume(self::IntegDomain{T}, J::FFltMat, loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {T&lt;:AbstractFESet2Manifold, CC&lt;:AbstractArray{FInt}}
    Jac = Jacobiansurface(self, J, loc, conn, N)::FFlt
    if self.axisymmetric
        return Jac*2*pi*loc[1];
    else
        return Jac*self.otherdimension(loc, conn,  N)
    end
end</code></pre><p>which  evaluates the volume Jacobian  for an element  of manifold dimension  2  (surface). Note that  first  the surface Jacobian  is calculated, which is then boosted to a volume Jacobian in two different ways, depending on whether  the model is axially symmetric or not. For the axially symmetric case  the &quot;other&quot;  dimension is implied,</p><p>The callback function computes the &quot;other&quot; dimension from  two kinds of  information: (a) the physical location  of the quadrature point,  and (b) the interpolation data for the element  (connectivity and the values of the basis functions at the quadrature point).</p><ul><li>The approach ad (a) is suitable  when the &quot;other&quot; dimension is given as a function of the physical coordinates. The  simplest case is obviously  a uniform distribution of the &quot;other&quot; dimension. When  no  callback is explicitly provided,  the  &quot;other&quot;  dimension  callback is  automatically generated as the trivial</li></ul><pre><code class="language-julia hljs">function otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {CC&lt;:AbstractArray{FInt}}
    return 1.0
end</code></pre><p>which simply returns 1.0 as the default value.</p><ul><li>The approach ad (b) is appropriate when the &quot;other&quot; dimension  is given by values given at the nodes of the  mesh. Than the connectivity  and  the array of the values of the basis functions  can be used to interpolate the &quot;other&quot;  dimension  to the quadrature point.</li></ul><h3 id="Evaluation-of-integration-data"><a class="docs-heading-anchor" href="#Evaluation-of-integration-data">Evaluation of integration data</a><a id="Evaluation-of-integration-data-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-of-integration-data" title="Permalink"></a></h3><p>Importantly, the  Integration Domain (<code>IntegDomain</code>) method <code>integrationdata</code> evaluates quantities  needed for numerical integration: locations and weights of quadrature points, and the values of basis functions and of the basis function gradients with respect to the parametric coordinates at the quadrature points.</p><h2 id="FEM-machines"><a class="docs-heading-anchor" href="#FEM-machines">FEM machines</a><a id="FEM-machines-1"></a><a class="docs-heading-anchor-permalink" href="#FEM-machines" title="Permalink"></a></h2><p>The construction of the matrices and vectors of the <em>discrete</em> form of the weighted residual equation is performed in FEM  machines. (FEM = Finite Element Method.)</p><p>As an example consider the weighted-residual form of the heat balance equation</p><p class="math-container">\[\int_{V}  \vartheta c_V\frac{\partial T}{\partial t} \; \mathrm{d} V
            +\int_{V}(\mathrm{grad}\vartheta)\; \kappa (\mathrm{grad}T
            )^T\; \mathrm{d} V
            -\int_{V}  \vartheta Q \; \mathrm{d} V  
            +\int_{S_2} \vartheta\;\overline{q}_{n}\; \mathrm{d} S+ \int_{S_3} \vartheta\;h
            (T-T_a)  \; \mathrm{d} S = 0\]</p><p>where <span>$\vartheta(x) =0$</span>  for  <span>$x \in{S_1}$</span> .</p><p>The  test function is  taken to be  one  finite element basis function at a time, <span>$\vartheta = N_{j}$</span>, and the trial function is</p><p class="math-container">\[T = \sum_{i= 1} ^{N} N_{i} T_i .\]</p><p>Here by <span>$N_{j}$</span> we mean the basis function constructed on the mesh and associated with the node where the degree of freedom <span>$j$</span> is situated. </p><p>Now the test function and the trial function is substituted  into the  weighted residual equation.  </p><h3 id="Example:-internal-heat-generation-rate-term"><a class="docs-heading-anchor" href="#Example:-internal-heat-generation-rate-term">Example:  internal heat generation rate term</a><a id="Example:-internal-heat-generation-rate-term-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-internal-heat-generation-rate-term" title="Permalink"></a></h3><p>For instance,  for the term</p><p class="math-container">\[\int_{V}  \vartheta Q \; \mathrm{d} V\]</p><p>we obtain</p><p class="math-container">\[\int_{V} N_{j} Q \; \mathrm{d} V\]</p><p>This integral evaluates to a number, the heat load  applied to the degree of freedom <span>$j$</span>. When these numbers are evaluated for all  the free degrees of freedom,  they constitute the entries of the global heat load vector.</p><p>Evaluating integrals of this form is so common that there is a module <code>FEMMBaseModule</code> with the method <code>distribloads</code> that computes and assembles the global vector. For instance to evaluate this heat load vector  on the mesh composed of three-node triangles, for a uniform heat generation rate <code>Q</code>, we can write</p><pre><code class="language-julia hljs">fi = ForceIntensity(FFlt[Q]);
F1 = distribloads(FEMMBase(IntegDomain(fes, TriRule(1))), geom, tempr, fi, 3);</code></pre><p><code>IntegDomain(fes, TriRule(1))</code> constructs integration domain for the  finite elements <code>fes</code> using a triangular  integration rule with a single point. <code>FEMMBase</code> is the base  FEM  machine,  and all it needs at this point is the integration domain. The method  <code>distribloads</code> is defined for the  base FEM machine, the geometry field <code>geom</code>, the numbering of the degrees of freedom is taken from the field <code>tempr</code>, the internal heat generation rate is defined as the force intensity <code>fi</code>, and the integrals  are volume integrals  (3).</p><h3 id="Example:-conductivity-term"><a class="docs-heading-anchor" href="#Example:-conductivity-term">Example: conductivity term</a><a id="Example:-conductivity-term-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-conductivity-term" title="Permalink"></a></h3><p>The conductivity term from the weighted residual equation</p><p class="math-container">\[\int_{V}(\mathrm{grad}\vartheta)\; \kappa (\mathrm{grad}T
            )^T\; \mathrm{d} V\]</p><p>is rewritten with the test and trial functions as</p><p class="math-container">\[\sum_{i=1}^N \int_{V}(\mathrm{grad}N_{j})\; \kappa (\mathrm{grad}N_{i}
            )^T\; \mathrm{d} V \; T_i\]</p><p>The sum over the degree of freedom number <span>$i$</span> should be split: some of the  coefficients <span>$T_i$</span> are for free degrees of freedom (<span>$1 \le i \le  N_{\mathrm{f}}$</span>, with <span>$N_{\mathrm{f}}$</span> being the total number of free degrees of freedom), while some are  fixed (prescribed) for nodes  which are located on the essential boundary condition surface <span>$S_1$</span>  (<span>$N_{\mathrm{f}} &lt; i \le N$</span>).</p><p>Thus the term splits into two  pieces,</p><p class="math-container">\[\sum_{i=1}^{N_{\mathrm{f}}} \int_{V}(\mathrm{grad}N_{j})\; \kappa (\mathrm{grad}N_{i}
            )^T\; \mathrm{d} V \; T_i\]</p><p>where the  individual integrals are entries of the conductivity matrix, and</p><p class="math-container">\[\sum_{i=N_{\mathrm{f}}+1}^N \int_{V}(\mathrm{grad}N_{j})\; \kappa (\mathrm{grad}N_{i}
            )^T\; \mathrm{d} V \; T_i\]</p><p>which  will represent heat loads  due to nonzero  prescribed boundary condition.</p><p>The FEM machine  for the heat conduction problem can be created as</p><pre><code class="language-julia hljs">material = MatHeatDiff(thermal_conductivity)
femm = FEMMHeatDiff(IntegDomain(fes, TriRule(1)), material)</code></pre><p>where we first create a <code>material</code> to  provide access to the thermal conductivity matrix <span>$\kappa$</span>, and then  we create  the FEM  machine  from the integration domain  for a mesh  consisting of three node triangles, using one-point integration rule, and the material. This  FEM machine  can then be passed to a method, for instance the calculate the global conductivity matrix <code>K</code></p><pre><code class="language-julia hljs">K = conductivity(femm, geom, Temp)</code></pre><p>where the geometry comes from the geometry field <code>geom</code>, and the temperature field <code>Temp</code> provides the  numbering of the degrees of freedom. Note that the global conductivity matrix is square, and of size <span>$N_{\mathrm{f}}\timesN_{\mathrm{f}}$</span>. In other words, it is only for the degrees of freedom that are free (actual unknowns).</p><p>The heat load term  due to the  nonzero essential boundary conditions  is evaluated with the method <code>nzebcloadsconductivity</code></p><pre><code class="language-julia hljs">F2 = nzebcloadsconductivity(femm, geom, Temp);</code></pre><p>where the geometry comes from the geometry field <code>geom</code>, and the temperature field <code>Temp</code> provides the  numbering of the degrees of freedom and the values of the prescribed (fixed) degrees of freedom. The result is a contribution to the global heat load vector. </p><h3 id="Base-FEM-machine"><a class="docs-heading-anchor" href="#Base-FEM-machine">Base FEM machine</a><a id="Base-FEM-machine-1"></a><a class="docs-heading-anchor-permalink" href="#Base-FEM-machine" title="Permalink"></a></h3><p>The following  operations are provided  by the base FEM machine:</p><ul><li><p>Integrate  a function expressed in terms of a field. This is typically used to evaluate RMS discretization errors.</p></li><li><p>Integrate a function of the position. Perhaps the evaluation of the moments of inertia,  or the calculation of the volume.</p></li><li><p>Transfer field between meshes of different resolutions.</p></li><li><p>Calculate  the distributed-load system vector.</p></li><li><p>Construct a field  from integration-point quantities. This is typically used in the postprocessing phase, for instance to construct continuous distribution of stresses in the structure.</p></li></ul><h2 id="Material-and-Material-Orientation"><a class="docs-heading-anchor" href="#Material-and-Material-Orientation">Material and Material Orientation</a><a id="Material-and-Material-Orientation-1"></a><a class="docs-heading-anchor-permalink" href="#Material-and-Material-Orientation" title="Permalink"></a></h2><p>The material response  is described in  material-point-attached coordinate system. These coordinate systems  are Cartesian, and the material coordinate system is typically chosen to make  the response particularly simple.  So for orthotropic or transversely isotropic materials the axes would be aligned with the axes of orthotropy.</p><p>The type <code>CSys</code> (module <code>CSysModule</code>) is the updater of the material coordinate system matrix. The object is equipped with a callback to store the current orientation matrix. For instance: the coordinate system for an orthotropic material wound around a cylinder could be described in the coordinate system <code>CSys(3, 3, updatecs!)</code>, where the callback <code>updatecs!</code> is defined as</p><pre><code class="language-julia hljs">function updatecs!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    csmatout[:, 2] = [0.0 0.0 1.0]
    csmatout[:, 3] = XYZ
    csmatout[3, 3] = 0.0
    csmatout[:, 3] = csmatout[:, 3]/norm(csmatout[:, 3])
    csmatout[:, 1] = cross(csmatout[:, 2], csmatout[:, 3])
end</code></pre><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.</p><p>Algorithms typically (not always) accept a single argument, <code>modeldata</code>, a dictionary of data, keyed by Strings. Algorithms  also return <code>modeldata</code>,  typically  including additional key/value pairs that represent the data computed by the algorithm.</p><h3 id="Base-algorithms"><a class="docs-heading-anchor" href="#Base-algorithms">Base algorithms</a><a id="Base-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Base-algorithms" title="Permalink"></a></h3><p>These are not specific to the particular physics at hand. Examples of  algorithms are  Richardson extrapolation,  calculation of the norm of the field, or calculation of the norm  of the difference of two fields. These algorithms are the exceptions, they do not return <code>modeldata</code> but rather return directly computed values.</p><h3 id="Model-data"><a class="docs-heading-anchor" href="#Model-data">Model data</a><a id="Model-data-1"></a><a class="docs-heading-anchor-permalink" href="#Model-data" title="Permalink"></a></h3><p>Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method <code>linearstatics</code> of the <code>AlgoDeforLinearModule</code>, the <code>modeldata</code> dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.</p><p>The <code>modeldata</code> may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.</p><h2 id="Queries-of-quadrature-point-data"><a class="docs-heading-anchor" href="#Queries-of-quadrature-point-data">Queries of quadrature-point data</a><a id="Queries-of-quadrature-point-data-1"></a><a class="docs-heading-anchor-permalink" href="#Queries-of-quadrature-point-data" title="Permalink"></a></h2><p>A number of quantities exist at integration (quadrature) points. For instance for heat conduction this data may refer to the temperature gradients and heat flux vectors. In stress analysis, such data would typically be stress invariants  or stress components.</p><p>How this data is calculated at the quadrature point obviously varies depending on the element type. Not only on the element order, but the element formulation may invoke rules other than those of simple gradient-taking: take as an example mean-strain  elements, which define strains by using averaging rules over the entire element, so not looking at a single integration point only.</p><p>For this purpose, <code>FinEtools</code> has ways of defining implementations of the function <code>inspectintegpoints</code> to take into account the particular features of the various finite element formulations. Each FEMM typically defines its own specialized method. </p><h2 id="Postprocessing"><a class="docs-heading-anchor" href="#Postprocessing">Postprocessing</a><a id="Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing" title="Permalink"></a></h2><p>One way in which quadrature-point data is postprocessed into graphical means is by constructing node-based fields. For instance, extrapolating quadrature-point data to the nodes is commonly done in finite element programs. This procedure is typically referred to as &quot;averaging at the nodes&quot;. The name implies that not only the quadrature-point data is extrapolated to the nodes of the element, but since each element incident on a node may have predicted (extrapolated) a different value of a quantity (for example stress), these different values need to be somehow reconciled, and averaging, perhaps weighted averaging, is the usual procedure.</p><h3 id="Compute-continuous-stress-fields"><a class="docs-heading-anchor" href="#Compute-continuous-stress-fields">Compute continuous stress fields</a><a id="Compute-continuous-stress-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-continuous-stress-fields" title="Permalink"></a></h3><p>Individual FEMMs may have different ways of extrapolating to the nodes. These are implemented in various methods of the function <code>fieldfromintegpoints</code>. The resulting field represents quadrature-point data as a nodal field, where the degrees of freedom are extrapolated values to the nodes.</p><h3 id="Compute-elementwise-stress-fields"><a class="docs-heading-anchor" href="#Compute-elementwise-stress-fields">Compute elementwise stress fields</a><a id="Compute-elementwise-stress-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-elementwise-stress-fields" title="Permalink"></a></h3><p>Most finite element postprocessing softwares find it difficult to present results which are discontinuous at inter-element boundaries. Usually the only way in which data based on individual elements with no continuity across element boundaries is presented is by taking an average over the entire element and represent the values as uniform across each element. Various methods of the function <code>elemfieldfromintegpoints</code> produce elemental fields of this nature.</p><h2 id="Import/export"><a class="docs-heading-anchor" href="#Import/export">Import/export</a><a id="Import/export-1"></a><a class="docs-heading-anchor-permalink" href="#Import/export" title="Permalink"></a></h2><h3 id="Importing"><a class="docs-heading-anchor" href="#Importing">Importing</a><a id="Importing-1"></a><a class="docs-heading-anchor-permalink" href="#Importing" title="Permalink"></a></h3><p>At the moment importing is mostly limited to the mesh data (properties, boundary conditions, analysis of data, etc. are typically not imported). The following formats of finite element input files can be handled:</p><ul><li>NASTRAN (<code>.nas</code> files).</li><li>Abaqus (<code>.inp</code> files).</li></ul><h3 id="Exporting"><a class="docs-heading-anchor" href="#Exporting">Exporting</a><a id="Exporting-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting" title="Permalink"></a></h3><ul><li>VTK (<code>.vtk</code> so-called legacy files). Export of geometry and fields (nodal and elemental) is supported.</li><li>Abaqus (<code>.inp</code> files). Mesh data and selected property, boundary condition, and procedure commands can be handled.</li><li>NASTRAN (<code>.nas</code> files). Very basic mesh and select other attributes are handled.</li><li>STL file export of surface data.</li><li>H2Lib triangular-surface export (<code>.tri</code> files).</li><li>CSV file export of numerical data is supported.</li></ul><h2 id="Tutorials-and-Examples"><a class="docs-heading-anchor" href="#Tutorials-and-Examples">Tutorials and Examples</a><a id="Tutorials-and-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorials-and-Examples" title="Permalink"></a></h2><h3 id="Tutorials"><a class="docs-heading-anchor" href="#Tutorials">Tutorials</a><a id="Tutorials-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorials" title="Permalink"></a></h3><p>The <code>FinEtools</code> tutorials are written up in the repositories for the applications, heat diffusion, linear and nonlinear deformation and so on.</p><p>The tutorials are in the form of Julia files with markdown. These are converted to markdown files using the <a href="https://github.com/fredrikekre/Literate.jl">Literate</a> workflow.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>The examples of the use of the <code>FinEtools</code> package are separated in their own separate repositories, for instance  <a href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl.git"><code>FinEtoolsHeatDiff</code></a>, <a href="https://github.com/PetrKryslUCSD/FinEtoolsAcoustics.jl.git"><code>FinEtoolsAcoustics</code></a>, and so on. For a complete information refer to <a href="https://github.com/PetrKryslUCSD?tab=repositories">the list of the repositories</a>.</p><p>The examples are in the form of  Julia files with multiple functions, where each function defines one or more related examples. Take for instance the example file <code>Fahy_examples.jl</code>. This incantation will run all the examples from the example file:</p><pre><code class="nohighlight hljs">include(&quot;Fahy_examples.jl&quot;); Fahy_examples.allrun()</code></pre><p>This will run just a single example from this file:</p><pre><code class="nohighlight hljs">include(&quot;Fahy_examples.jl&quot;); Fahy_examples.fahy_H8_example()</code></pre><p>The example file <code>Fahy_examples.jl</code> consists of a module (whose name matches the name of the file), and  the module defines multiple functions,  one for each example, and one to run <em>all</em> examples, <code>allrun</code>.</p><h3 id="Tests"><a class="docs-heading-anchor" href="#Tests">Tests</a><a id="Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Tests" title="Permalink"></a></h3><p>Check out the numerous tests in the <code>test</code> folder. There are hundreds of tests which exercise the various functions of the library. These examples may help you understand how to extract the desired outcome.</p><h2 id="Make-up-your-own-public-interface"><a class="docs-heading-anchor" href="#Make-up-your-own-public-interface">Make up your own public interface</a><a id="Make-up-your-own-public-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Make-up-your-own-public-interface" title="Permalink"></a></h2><p>Here we assume that the FinEtools package is installed. We also assume the user works in his or her own folder, which for simplicity we assume is a package folder in the same tree as the package folder for FinEtools.</p><p>The user may have his or her additions to the FinEtools library, for instance a new material implementation, or a new FEMM (finite element model machine). Additionally, the user writes some code to solve particular problems.</p><p>In order to facilitate interactive work at the command line(REPL), it is convenient to have one or two modules so that <code>using</code> them allows for the user&#39;s code to resolve function names from the FinEtools package and from the user&#39;s own code.</p><p>Here are two ways in which this can be accomplished.</p><ol><li><p>The user exports his or her own additions from the module <code>add2FinEtools</code> (the name of this module is not obligatory, it can be anything). In addition, the public interface to the FinEtools package needs to be brought in separately.</p><p><code>using FinEtools  using add2FinEtools</code></p></li><li><p>The user may change entirely the public interface to the FinEtools package by selectively including parts of the <code>FinEtools.jl</code> file and the code to export his or her own functionality in a single module, let us say <code>myFinEtools</code> (this name is arbitrary), so that when the user invokes</p><p><code>using myFinEtools</code></p><p>all the functionality that the USER considers to be public is made available by exports.</p></li></ol><p>Method 1 has the <em>advantage</em> that the interface definition of the FinEtools package itself does not change, which means that package code does not need to be touched. It also has a <em>disadvantage</em> that the interface to FinEtools does not change which means that if there is a conflict with one of the exported functions from FinEtools, it needs to be resolved by fiddling with other packages.</p><p>Method 2 has the advantage that when there is a conflict between one of the exported FinEtools functions and some other function, be it from another package or the user&#39;s own, the conflict can be resolved by changing the public interface to FinEtools by the USER (as opposed to  by the DEVELOPER). Also, in this method the USER has the power to define the public interface to the FinEtools package, and if the user decides that nothing should be exported for implicit resolution of functions, that is easily accomplished.</p><p>These two methods have been described by examples in the <a href="https://github.com/PetrKryslUCSD/FinEtoolsUseCase">FinEtoolsUseCase</a> package. Refer to the Readme  file and to the method descriptions  in the  method 1 and 2 folders.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Home</a><a class="docs-footer-nextpage" href="../man/types.html">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 12 August 2021 23:54">Thursday 12 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
