var documenterSearchIndex = {"docs":
[{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/guide.html#Break-down-into-modules","page":"Guide","title":"Break down into modules","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The FinEtools package consists of many modules which fall into several  categories. The top-level module, FinEtools, includes all other modules and exports functions to constitute the public interface. The user is free to generate their own public interface, however. More details are provided in the section Make up your own public interface.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Top-level:     FinEtools is the  top-level module.  For interactive use   it is enough to do using FinEtools, however in some  cases functions from   modules need to be  brought into the scope individually (most importantly,   the algorithm modules). This is the ONLY  module that EXPORTS  functions,   none of the other modules exports a single function. The entire  public   (i. e. exported) interface of the FinEtools package is specified  in the   file FinEtools.jl (i. e. in the FinEtools module). The user is free to   specify his or her own set of exported functions from the FinEtools package   to create an ad hoc public interface.\nUtilities: Refer to the modules FTypesModule (definition of basic   numerical types), PhysicalUnitModule (for use with numbers specified   using physical units), AssemblyModule (assembly of elementwise matrices   and vectors),   CSysModule (coordinate system module),   MatrixUtilityModule (utilities for operations on elementwise matrices),   BoxModule  (support for working with bounding boxes),   ForceIntensityModule (force-intensity module), RotationUtilModule   (support for spatial rotations).\nMesh  entities:  FENodeSetModule, FESetModule (node set and finite element set  types). \nMesh Generation:   MeshLineModule,  MeshQuadrilateralModule,   MeshTriangleModule,   MeshTetrahedronModule, MeshHexahedronModule,   VoxelBoxModule. \nMesh manipulation:  MeshSelectionModule (searching of nodes  and   elements),  MeshModificationModule (mesh boundary, merging  of meshes and   nodes, smoothing, partitioning),  MeshUtilModule   (utilities), FENodeToFEMapModule (search structure from nodes to   elements).\nMesh import/export:  MeshImportModule,  MeshExportModule.\nFields:   FieldModule,    GeneralFieldModule, ElementalFieldModule,   NodalFieldModule (modules for representing quantities on the mesh).\nIntegration: Support for  integration over solids, surfaces, curves, and   points: IntegRuleModule,   IntegDomainModule.\nGeneral algorithms: AlgoBaseModule (algorithms), FEMMBaseModule   (FEM machine for general tasks).","category":"page"},{"location":"guide/guide.html#Arithmetic-types","page":"Guide","title":"Arithmetic types","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The FinEtools package tries to make typing arguments easier. The arithmetic types used throughout are FInt for integer data, FFlt for floating-point data, and Complex{FFlt} for applications that work with complex linear algebra quantities.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The module FTypesModule defines these types, and also defines abbreviations for vectors and matrices with entries of these types.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Some algorithms expect input in the form of the data dictionary, FDataDict, and also produce output in this form.","category":"page"},{"location":"guide/guide.html#Physical-units","page":"Guide","title":"Physical units","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The PhysicalUnitModule provides a simple function, phun, which can help with providing input numbers with the correct conversion between physical units. For instance, it is possible to specify the input data as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"E = 200*phun(\"GPa\");# Young's modulus\nnu = 0.3;# Poisson ratio\nrho = 8000*phun(\"KG*M^-3\");# mass density\nL = 10.0*phun(\"M\"); # side of the square plate\nt = 0.05*phun(\"M\"); # thickness of the square plate","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"A few common sets of units are included, :US, :IMPERIAL, :CGS, :SIMM (millimeter-based SI units), and :SI (meter-based SI units). The resulting  values assigned to the variables are floating-point numbers, for instance","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"julia> E = 200*phun(\"GPa\")\n2.0e11","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Numbers output by the simulation can also be converted  to appropriate units for printing as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"julia> E/phun(\"MPa\")\n200000.0","category":"page"},{"location":"guide/guide.html#Mesh-entities","page":"Guide","title":"Mesh entities","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The mesh consists of one set of finite element nodes  and one or more sets of finite elements.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"One of the  organizing principles of the  finite element collection  is that  finite elements can appear as representations of the interior  of the domain, but in a different model as parts of the boundary.  Thus  for instance  4-node  quadrilaterals  are finite elements that represent cross-sections of  axially symmetric models or surfaces  of membranes,  but they are also the boundaries of hexahedral  models.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"A mesh  is generated by one of the functions specialized to a particular finite element type. Thus there are  mesh generation functions for lines, triangles, quadrilaterals, tetrahedra, and hexahedra.","category":"page"},{"location":"guide/guide.html#Mesh-generation","page":"Guide","title":"Mesh generation","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As an example,  the following code generates a hexahedral mesh of simple rectangular block.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The finite element node set and the finite element set  are returned. More complicated meshes can be constructed from such mesh parts. There are  functions for  merging  nodes  and even multiple meshes together.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The code snippet below  constructs the mesh of an  L-shaped  domain  from  the meshes of three rectangles.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"W = 100. # width of the leg\nL = 200. # length of the leg\nnL = 15 # number of elements along the length of the leg\nnW = 10 # number of elements along the width\ntolerance = W / nW / 1.0e5 # tolerance for merging nodes\nMeshes = Array{Tuple{FENodeSet,FESet},1}()\npush!(Meshes, Q4quadrilateral([0.0 0.0; W W], nW, nW))\npush!(Meshes, Q4quadrilateral([-L 0.0; 0.0 W], nL, nW))\npush!(Meshes, Q4quadrilateral([0.0 -L; W 0.0], nW, nL))\nfens, outputfes = mergenmeshes(Meshes, tolerance);\nfes = cat(outputfes[1], cat(outputfes[2], outputfes[3]))","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As an example of the  merging  of nodes to create  the final mesh, consider the creation of  a closed hollow tube.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc) # generate a block\n# Shape into a cylinder\nR = zeros(3, 3)\nfor i = 1:count(fens)\n    x, y, z = fens.xyz[i,:];\n    rotmat3!(R, [0, z, 0])\n    Q = [cos(psi * pi / 180) sin(psi * pi / 180) 0;\n        -sin(psi * pi / 180) cos(psi * pi / 180) 0;\n        0 0 1]\n    fens.xyz[i,:] = reshape([x + Rmed - h / 2, y - l / 2, 0], 1, 3) * Q * R;\nend\n# Merge the nodes where the tube  closes up\ncandidates = selectnode(fens, box = boundingbox([Rmed - h -Inf 0.0; Rmed + h +Inf 0.0]), inflate = tolerance)\nfens, fes = mergenodes(fens, fes,  tolerance, candidates);","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The final mesh used for a simulation  consists of a single  node set and one or more finite element sets. The  finite elements may be  divided into separate sets  to  accommodate different material properties, different orientations of the material  coordinate systems, or different formulations  of the discrete model. The  assignment  of the finite elements to sets  may be based on geometrical proximity, topological connections, or some other characteristic. See the  \"mesh selection\" discussion for details.","category":"page"},{"location":"guide/guide.html#Structured-mesh-generation","page":"Guide","title":"Structured mesh generation","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The simplest possible meshes can be generated in the form of one-dimensional, two-dimensional, and three-dimensional blocks. The spacing of the nodes can be either uniform (for instance Q8block), or the spacing can be given with an arbitrary distribution (for instance Q4blockx). Meshes of tetrahedra can be generated in various orientations of the \"diagonals\".","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"More complex meshes can be generated for certain element types: for instance an annulus (Q4annulus), quarter of a plate with a hole (Q4elliphole), quarter of a sphere (H8spheren), layered plate (H8layeredplatex).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Hexahedral meshes can also be created by extrusion of  quadrilateral meshes (H8extrudeQ4).","category":"page"},{"location":"guide/guide.html#Shaping","page":"Guide","title":"Shaping","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Simple meshes  such as blocks can be deformed into geometrically complex shapes, for instance  by tapering  or other relocation of the nodes. For instance, we can generate a block  and then bend it  into one quarter  of  an annulus as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nfor i=1:count(fens)\n    r=rin+fens.xyz[i,1]; a=fens.xyz[i,2];\n    fens.xyz[i,:]=[r*cos(a) r*sin(a)];\nend","category":"page"},{"location":"guide/guide.html#Merging","page":"Guide","title":"Merging","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Multiple mesh regions  can be generated and then merged together into a single mesh. Refer to the MeshModificationModule. Meshes can be also mirrored.","category":"page"},{"location":"guide/guide.html#Boundary-extraction","page":"Guide","title":"Boundary extraction","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Mesh  composed of  any element type can be passed to the function  meshboundary, and  the boundary of the mesh is extracted. As an example, the code","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nbdryfes = meshboundary(fes);","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"generates a mesh of quadrilaterals in the set fes,  and bdryfes = meshboundary(fes) finds the boundary elements of the type L2 (line elements with two nodes) and stores them in the  finite element set bdryfes.","category":"page"},{"location":"guide/guide.html#Conversion-between-element-types","page":"Guide","title":"Conversion  between element types","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For any element shape  (line, triangle,  quadrilateral, hexahedron, tetrahedron) there is  the linear version and the quadratic version. Conversion routines are provided so that, for example, mesh can be generated as eight-node  hexahedra  and then converted  to twenty-node hexahedra as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens, fes = H8toH20(fens, fes)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Other conversion routines can convert triangles to quadrilaterals, tetrahedra to hexahedra, and so on.","category":"page"},{"location":"guide/guide.html#Refinement","page":"Guide","title":"Refinement","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Meshes composed of some  element types can be uniformly refined. For instance, quadrilateral meshes can be refined by bisection with Q4refine.","category":"page"},{"location":"guide/guide.html#Selection-of-mesh-entities","page":"Guide","title":"Selection of mesh entities","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"There are many instances of problem definitions where it is important to partition meshes into subsets. As an example,  consider a tube consisting of inner ABS core and  outer fiber-reinforced  laminate  layer. The mesh may consist  of hexahedra.  This mesh would then need to be partitioned into two subsets, because the materials and the  material orientation data  are different between the two regions.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As another example, consider a simple beam  of rectangular cross-section, clamped  at one end,  and  loaded with shear tractions at the  free end. The  entire boundary of the beam needs to be separated  into three subsets:  the first subset,  for the traction-free boundary, is ignored. The second subset, for the clamped cross-section, is extracted  and  its nodes  are used  to  formulate the essential boundary condition. The third subset is extracted and used to define an FEM machine to compute the load vector due to the shear traction.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"There are  several  ways  in which mesh entities (nodes and finite elements) can be selected. The simplest uses element labels: some mesh-generation routines label the generated elements. For example,","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens,fes = H8layeredplatex(xs, ys, ts, nts)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"generates a plate-like mesh where the layers are labeled. It is therefore possible to select  the bottom-most layer as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"rls = selectelem(fens, fes, label = 1)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where rls is a list of integer indexes into the  set fes, so that we can extract a subset corresponding to this layer as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"botskin = subset(fes, rls)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Geometrical techniques for selecting finite elements  or nodes can be based on","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"the location within or overlap  with boxes;\ndistance from  a given point;\ndistance from a given plane;\nconnectedness (selection by flooding).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Additionally, surface-like  finite elements (quadrilaterals and triangles embedded in three dimensions), or lines embedded in two dimensions, can be selected based upon the orientation of their normal (facing  criterion).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As an example, consider a straight duct with anechoic termination. A triangle mesh is generated as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fens,fes  =  T3block(Lx,Ly,n,2);","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"and its boundary is extracted as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"bfes  =  meshboundary(fes)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The finite elements from the  piece of the boundary on the left parallel to the Y axis can be extracted as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"L0 = selectelem(fens,bfes,facing = true, direction = [-1.0 0.0])","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where the numbers of the finite elements  whose normals point in the general direction of the vector [-1.0 0.0] are returned in the integer array L0.","category":"page"},{"location":"guide/guide.html#Fields","page":"Guide","title":"Fields","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The structure to maintain the numbering  and values of the degrees of freedom in the mesh  is the field. Consider for instance the temperature field: we write","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"T(x) = sum_i N_i(x) T_i","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The understanding is that T_i are the degrees of freedom, and the basis functions N_i(x) are defined implicitly by the finite element mesh. (More about basis functions below.) Each element has its own set of functions, which when multiplied by the degree of freedom values describe the temperature over each individual finite element. The basis functions are implicitly associated with the nodes of the finite elements. The degrees of freedom are also (explicitly) associated with the nodes. The field may also be generalized a bit by extending the above sum simply to entities of the mesh, not only the nodes, but perhaps also the elements.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The role of the field is then to maintain the correspondence between the entities and the numbers and values of the degrees of freedom.","category":"page"},{"location":"guide/guide.html#Abstract-Field","page":"Guide","title":"Abstract  Field","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The assumption is that a field has one set of degrees of freedom per node or per element. For simplicity we will refer to the nodes and elements as entities. It assumes that concrete  subtypes of the abstract field  have the following data, one row per entity:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"values::FMat{T}: Array of the values of the degrees of freedom, one row  for each entity. All the arrays below have the same dimensions as this one.\ndofnums::FIntMat: Array  of the numbers of the free degrees of freedom. If the degree of freedom is fixed (prescribed), the corresponding entry is zero.\nis_fixed::Matrix{Bool}: Array of  Boolean flags,  true for fixed  (prescribed) degrees of freedom, false otherwise.\nfixed_values::FMat{T}: Array  of the same size and type  as  values. Its entries are only relevant  for the fixed (prescribed)  degrees of freedom.\nnfreedofs::FInt:  the total number of free degrees of freedom.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The methods defined for the abstract field  include:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Return the number of degrees of freedom and the number of entities.\nGather and scatter the system vector.\nGather elementwise  vectors or matrices of values, the degree of freedom numbers, or the fixed values of the degrees of freedom.\nSet  or clear essential boundary conditions.\nCopy a field. Clear the entries of the field.","category":"page"},{"location":"guide/guide.html#Nodal-Field","page":"Guide","title":"Nodal Field","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"In this case  the  abstract field is subtyped to a concrete field where the entities are nodes.","category":"page"},{"location":"guide/guide.html#Elemental-Field","page":"Guide","title":"Elemental Field","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are the elements.","category":"page"},{"location":"guide/guide.html#General-Field","page":"Guide","title":"General Field","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are  use-case  specific.","category":"page"},{"location":"guide/guide.html#Numbering-of-the-degrees-of-freedom","page":"Guide","title":"Numbering of the degrees of freedom","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The simplest method is at the moment implemented: number all free degrees of freedom, row-by-row and column-by-column, starting from 1 up to f.nfreedofs, for the field f.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The prescribed degrees of freedom are not numbered, and are marked with the \"degree of freedom number\" 0.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"There is also a method to supply the numbering of the nodes, perhaps  resulting from the Reverse Cuthill-McKee permutation. This may be useful when using LU or LDLT factorization as the fill-in may be minimized.","category":"page"},{"location":"guide/guide.html#Finite-element","page":"Guide","title":"Finite element","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The  finite element set is one of the basic entities in FinEtools. It is a homogeneous collection of  finite elements defined by the connectivity (collection of node numbers, listing the nodes connected by the element in  a specific order). The finite element set  provides  specialized methods  to compute the values of basis functions and the values of  the gradients of the basis functions  with respect to the parametric coordinates.","category":"page"},{"location":"guide/guide.html#Element-types","page":"Guide","title":"Element types","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The finite element sets are instances of concrete types. Each particular shape and order of element has its own type. There are types for  linear  and quadratic quadrilaterals, for instance, FESetQ4 and FESetQ8. Each element set provides access to the number of nodes  connected by the element (nodesperelem),  the connectivity as the two dimensional array    conn,  and the  integer label vector label.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The concrete finite element set types are subtypes of the abstract type for elements of different manifold dimension (3, 2, 1, and 0), for instance for the quadrilaterals that would be AbstractFESet2Manifold. These types are in turn  subtypes of the abstract finite element set type AbstractFESet.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The concrete finite element set type provides specialized methods to compute the values of the basis functions, bfun, and methods to compute  the gradients of the basis functions with respect to the parametric coordinates, bfundpar. FinEtools at the moment supports only the so-called nodal basis functions: each basis function is associated with a node. And that is  true both globally (in the sense that each basis function is globally supported),  and locally over each finite element, and all such functions are  1 at its own node, and zero at all the other nodes.","category":"page"},{"location":"guide/guide.html#Finite-element-set-functions","page":"Guide","title":"Finite element set functions","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Methods defined for  the abstract type:\nnodesperelem: Get the number of nodes  connected  by  the finite element.\ncount:  Get the number of individual connectivities in the FE set.\nsetlabel!: Set the label of the entire finite elements set.\nconnasarray: Retrieve  connectivity  as an integer array.\nfromarray!: Set  connectivity from an integer array.\nsubset: Extract a subset of the finite elements from the given finite element set.\ncat: Concatenate the connectivities of two FE sets.\nupdateconn!: Update the connectivity after the IDs of nodes changed.\nmap2parametric: Map a spatial location to parametric coordinates.\nMethods dispatched based on the manifold type:\nmanifdim: Return the manifold dimension.\nJacobian: Evaluate the  Jacobian.\ngradN!: Compute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\nMethods dispatched on the concrete type:\nboundaryconn: Get boundary connectivity.\nboundaryfe: Return the constructor of the type of the boundary finite element.\nbfun: Compute the values of the basis functions at a given parametric coordinate.\nbfundpar: Compute the values of the basis function gradients at a given parametric coordinate.\ninparametric: Are given parametric coordinates inside the element parametric domain?\ncentroidparametric: Return the parametric coordinates  of the centroid of the element.","category":"page"},{"location":"guide/guide.html#Integration","page":"Guide","title":"Integration","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"There are two kinds of integrals in the weighted-residual finite element method: integrals over the interior  of the domain,  and integrals over the boundary of the domain.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Consequently, in a typical simulation one would need  two meshes: one for the interior  of the domain,  and one for the boundary. Obviously, the mesh for the boundary will be derived from the mesh  constructed for the interior.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Often only a part  of the entire boundary   is   used:  on some parts of the boundary  the  boundary condition is implied as homogeneous (i. e. zero). For instance, a traction-free boundary. Therefore the necessary integrals are typically evaluated over a subset of the entire boundary.","category":"page"},{"location":"guide/guide.html#Manifold-dimension","page":"Guide","title":"Manifold dimension","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Finite elements  have  a certain manifold dimension.  Tetrahedra  and hexahedra are three-manifolds, triangles and quadrilaterals are two-manifolds, triangles and quadrilaterals are two-manifolds, lines are one-manifolds, and points are zero-manifolds.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Elements are equipped with an \"other\" dimension attribute which boosts the manifold dimension to produce the required dimension for  the integration. For instance,  a line element can be equipped with an \"other\" dimension to represent a cross-section so that a volume integral can be evaluated over a line element. Or, a line element can be given an \"other\" dimension as a thickness to result in a physical dimension needed to evaluate a surface integral.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The \"other\"  dimension  has the following meaning  for finite elements of different manifold dimensions:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Manifold dimension Volume integral Surface integral\n3 NA NA\n2 Thickness NA\n1 Cross-section Thickness\n0 Volume Cross-section","category":"page"},{"location":"guide/guide.html#Integration-over-the-interior","page":"Guide","title":"Integration  over the interior","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The integrals are always  volume integrals. This means that for elements which are of  lower manifold dimension than three the \"other\"  dimension needs to compensate.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For  three-manifold finite elements (tetrahedra and hexahedra) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a volume-like element.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For  finite elements of manifold dimension  less than tthree, the  \"other\" dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Manifold dimension Axially symmetric Plane 2D\n2 2pi r Thickness\n1 2pi rtimes  Thickness Cross-section\n0 2pi rtimes Cross-section Volume","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_Omega f dV approx sum_q f(xi_q) J(xi_q) W_q","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Here f  is the integrand, f(xi_q)  is the  value of the integrand  at the quadrature point, J(xi_q)  is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension, and therefore it is the  volume Jacobian. (For the interior integrals the Jacobian  is computed by the Jacobianvolume method.)","category":"page"},{"location":"guide/guide.html#Integration-over-the-boundary","page":"Guide","title":"Integration  over the boundary","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The integrals are always  surface integrals. This means that for elements which are of  lower manifold dimension than two the \"other\"  dimension needs to compensate.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For  two-manifold finite elements (triangles and quadrilaterals) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a surface-like element.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For  finite elements of manifold dimension  less than two, the  \"other\" dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Manifold dimension Axially symmetric Plane 2D\n1 2pi r Thickness\n0 2pi rtimes   Thickness Cross-section","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_partial Omega f dS approx sum_q f(xi_q) J(xi_q) W_q  ","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Here f  is the integrand, f(xi_q) is the  value of the integrand  at the quadrature point, J(xi_q) is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension, and therefore it is the  surface Jacobian. (For the boundary integrals the Jacobian  is computed by the Jacobiansurface method.)","category":"page"},{"location":"guide/guide.html#Example:-axially-symmetric-model,-line-element-L2","page":"Guide","title":"Example: axially symmetric model, line element L2","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The surface Jacobian in this case  is  equal to the curve Jacobian times 2*pi*r.","category":"page"},{"location":"guide/guide.html#Integration-Domain","page":"Guide","title":"Integration Domain","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As explained above, integrating over the interior or the boundary may mean different things based on the features of the solution domain: axially symmetric?, plane strain or plane stress?, and so forth.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The  module IntegDomainModule supports  the processing of  the geometry necessary for the evaluation of the various integrals. The module data structure  groups together  a finite element set with an appropriate integration rule, information about the model (axially symmetric or not), and a callback to evaluate  the \"other\" dimension.","category":"page"},{"location":"guide/guide.html#Other-dimension","page":"Guide","title":"Other dimension","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The  discussion of the surface and volume integrals introduces the notion  of the  \"other\"  dimension. In order to evaluate Jacobians of various space dimensions  the  Geometry Data module takes into account  whether or not the model is axially symmetric, and evaluates the \"other\" dimension based upon this information.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"A finite element set is equipped with  a way of  calculating  the \"other\" dimension.  For instance, the line element with two nodes, L2, can be given  the \"other\" dimension  as a  \"thickness\"  so that  surface integrals  can be evaluated over the line element. However, if this line element  is used in an axially symmetric model, the same  \"other\" dimension  of \"thickness\"  will result in the integral  along the length of this line element  being a volume integral.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Thus, the way in which the \"other\"  dimension gets used by the integration domain methods depends on the model. As an example, consider  the  method","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"function Jacobianvolume(self::IntegDomain{T}, J::FFltMat, loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC<:AbstractArray{FInt}}\n    Jac = Jacobiansurface(self, J, loc, conn, N)::FFlt\n    if self.axisymmetric\n        return Jac*2*pi*loc[1];\n    else\n        return Jac*self.otherdimension(loc, conn,  N)\n    end\nend","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"which  evaluates the volume Jacobian  for an element  of manifold dimension  2  (surface). Note that  first  the surface Jacobian  is calculated, which is then boosted to a volume Jacobian in two different ways, depending on whether  the model is axially symmetric or not. For the axially symmetric case  the \"other\"  dimension is implied,","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The callback function computes the \"other\" dimension from  two kinds of  information: (a) the physical location  of the quadrature point,  and (b) the interpolation data for the element  (connectivity and the values of the basis functions at the quadrature point).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The approach ad (a) is suitable  when the \"other\" dimension is given as a function of the physical coordinates. The  simplest case is obviously  a uniform distribution of the \"other\" dimension. When  no  callback is explicitly provided,  the  \"other\"  dimension  callback is  automatically generated as the trivial","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"function otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {CC<:AbstractArray{FInt}}\n    return 1.0\nend","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"which simply returns 1.0 as the default value.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The approach ad (b) is appropriate when the \"other\" dimension  is given by values given at the nodes of the  mesh. Than the connectivity  and  the array of the values of the basis functions  can be used to interpolate the \"other\"  dimension  to the quadrature point.","category":"page"},{"location":"guide/guide.html#Evaluation-of-integration-data","page":"Guide","title":"Evaluation of integration data","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Importantly, the  Integration Domain (IntegDomain) method integrationdata evaluates quantities  needed for numerical integration: locations and weights of quadrature points, and the values of basis functions and of the basis function gradients with respect to the parametric coordinates at the quadrature points.","category":"page"},{"location":"guide/guide.html#FEM-machines","page":"Guide","title":"FEM machines","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The construction of the matrices and vectors of the discrete form of the weighted residual equation is performed in FEM  machines. (FEM = Finite Element Method.)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"As an example consider the weighted-residual form of the heat balance equation","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_V  vartheta c_Vfracpartial Tpartial t  mathrmd V\n            +int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V\n            -int_V  vartheta Q  mathrmd V  \n            +int_S_2 varthetaoverlineq_n mathrmd S+ int_S_3 varthetah\n            (T-T_a)   mathrmd S = 0","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where vartheta(x) =0  for  x inS_1 .","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The  test function is  taken to be  one  finite element basis function at a time, vartheta = N_j, and the trial function is","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"T = sum_i= 1 ^N N_i T_i ","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Here by N_j we mean the basis function constructed on the mesh and associated with the node where the degree of freedom j is situated. ","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Now the test function and the trial function is substituted  into the  weighted residual equation.  ","category":"page"},{"location":"guide/guide.html#Example:-internal-heat-generation-rate-term","page":"Guide","title":"Example:  internal heat generation rate term","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For instance,  for the term","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_V  vartheta Q  mathrmd V","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"we obtain","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_V N_j Q  mathrmd V","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"This integral evaluates to a number, the heat load  applied to the degree of freedom j. When these numbers are evaluated for all  the free degrees of freedom,  they constitute the entries of the global heat load vector.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Evaluating integrals of this form is so common that there is a module FEMMBaseModule with the method distribloads that computes and assembles the global vector. For instance to evaluate this heat load vector  on the mesh composed of three-node triangles, for a uniform heat generation rate Q, we can write","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"fi = ForceIntensity(FFlt[Q]);\nF1 = distribloads(FEMMBase(IntegDomain(fes, TriRule(1))), geom, tempr, fi, 3);","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"IntegDomain(fes, TriRule(1)) constructs integration domain for the  finite elements fes using a triangular  integration rule with a single point. FEMMBase is the base  FEM  machine,  and all it needs at this point is the integration domain. The method  distribloads is defined for the  base FEM machine, the geometry field geom, the numbering of the degrees of freedom is taken from the field tempr, the internal heat generation rate is defined as the force intensity fi, and the integrals  are volume integrals  (3).","category":"page"},{"location":"guide/guide.html#Example:-conductivity-term","page":"Guide","title":"Example: conductivity term","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The conductivity term from the weighted residual equation","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"is rewritten with the test and trial functions as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"sum_i=1^N int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The sum over the degree of freedom number i should be split: some of the  coefficients T_i are for free degrees of freedom (1 le i le  N_mathrmf, with N_mathrmf being the total number of free degrees of freedom), while some are  fixed (prescribed) for nodes  which are located on the essential boundary condition surface S_1  (N_mathrmf  i le N).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Thus the term splits into two  pieces,","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"sum_i=1^N_mathrmf int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where the  individual integrals are entries of the conductivity matrix, and","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"sum_i=N_mathrmf+1^N int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"which  will represent heat loads  due to nonzero  prescribed boundary condition.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The FEM machine  for the heat conduction problem can be created as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"material = MatHeatDiff(thermal_conductivity)\nfemm = FEMMHeatDiff(IntegDomain(fes, TriRule(1)), material)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where we first create a material to  provide access to the thermal conductivity matrix kappa, and then  we create  the FEM  machine  from the integration domain  for a mesh  consisting of three node triangles, using one-point integration rule, and the material. This  FEM machine  can then be passed to a method, for instance the calculate the global conductivity matrix K","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"K = conductivity(femm, geom, Temp)","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom. Note that the global conductivity matrix is square, and of size N_mathrmftimesN_mathrmf. In other words, it is only for the degrees of freedom that are free (actual unknowns).","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The heat load term  due to the  nonzero essential boundary conditions  is evaluated with the method nzebcloadsconductivity","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"F2 = nzebcloadsconductivity(femm, geom, Temp);","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom and the values of the prescribed (fixed) degrees of freedom. The result is a contribution to the global heat load vector. ","category":"page"},{"location":"guide/guide.html#Base-FEM-machine","page":"Guide","title":"Base FEM machine","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The following  operations are provided  by the base FEM machine:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Integrate  a function expressed in terms of a field. This is typically used to evaluate RMS discretization errors.\nIntegrate a function of the position. Perhaps the evaluation of the moments of inertia,  or the calculation of the volume.\nTransfer field between meshes of different resolutions.\nCalculate  the distributed-load system vector.\nConstruct a field  from integration-point quantities. This is typically used in the postprocessing phase, for instance to construct continuous distribution of stresses in the structure.","category":"page"},{"location":"guide/guide.html#Material-and-Material-Orientation","page":"Guide","title":"Material and Material Orientation","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The material response  is described in  material-point-attached coordinate system. These coordinate systems  are Cartesian, and the material coordinate system is typically chosen to make  the response particularly simple.  So for orthotropic or transversely isotropic materials the axes would be aligned with the axes of orthotropy.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The type CSys (module CSysModule) is the updater of the material coordinate system matrix. The object is equipped with a callback to store the current orientation matrix. For instance: the coordinate system for an orthotropic material wound around a cylinder could be described in the coordinate system CSys(3, 3, updatecs!), where the callback updatecs! is defined as","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"function updatecs!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    csmatout[:, 2] = [0.0 0.0 1.0]\n    csmatout[:, 3] = XYZ\n    csmatout[3, 3] = 0.0\n    csmatout[:, 3] = csmatout[:, 3]/norm(csmatout[:, 3])\n    csmatout[:, 1] = cross(csmatout[:, 2], csmatout[:, 3])\nend","category":"page"},{"location":"guide/guide.html#Algorithms","page":"Guide","title":"Algorithms","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Algorithms typically (not always) accept a single argument, modeldata, a dictionary of data, keyed by Strings. Algorithms  also return modeldata,  typically  including additional key/value pairs that represent the data computed by the algorithm.","category":"page"},{"location":"guide/guide.html#Base-algorithms","page":"Guide","title":"Base algorithms","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"These are not specific to the particular physics at hand. Examples of  algorithms are  Richardson extrapolation,  calculation of the norm of the field, or calculation of the norm  of the difference of two fields. These algorithms are the exceptions, they do not return modeldata but rather return directly computed values.","category":"page"},{"location":"guide/guide.html#Model-data","page":"Guide","title":"Model data","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.","category":"page"},{"location":"guide/guide.html#Queries-of-quadrature-point-data","page":"Guide","title":"Queries of quadrature-point data","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"A number of quantities exist at integration (quadrature) points. For instance for heat conduction this data may refer to the temperature gradients and heat flux vectors. In stress analysis, such data would typically be stress invariants  or stress components.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"How this data is calculated at the quadrature point obviously varies depending on the element type. Not only on the element order, but the element formulation may invoke rules other than those of simple gradient-taking: take as an example mean-strain  elements, which define strains by using averaging rules over the entire element, so not looking at a single integration point only.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"For this purpose, FinEtools has ways of defining implementations of the function inspectintegpoints to take into account the particular features of the various finite element formulations. Each FEMM typically defines its own specialized method. ","category":"page"},{"location":"guide/guide.html#Postprocessing","page":"Guide","title":"Postprocessing","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"One way in which quadrature-point data is postprocessed into graphical means is by constructing node-based fields. For instance, extrapolating quadrature-point data to the nodes is commonly done in finite element programs. This procedure is typically referred to as \"averaging at the nodes\". The name implies that not only the quadrature-point data is extrapolated to the nodes of the element, but since each element incident on a node may have predicted (extrapolated) a different value of a quantity (for example stress), these different values need to be somehow reconciled, and averaging, perhaps weighted averaging, is the usual procedure.","category":"page"},{"location":"guide/guide.html#Compute-continuous-stress-fields","page":"Guide","title":"Compute continuous stress fields","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Individual FEMMs may have different ways of extrapolating to the nodes. These are implemented in various methods of the function fieldfromintegpoints. The resulting field represents quadrature-point data as a nodal field, where the degrees of freedom are extrapolated values to the nodes.","category":"page"},{"location":"guide/guide.html#Compute-elementwise-stress-fields","page":"Guide","title":"Compute elementwise stress fields","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Most finite element postprocessing softwares find it difficult to present results which are discontinuous at inter-element boundaries. Usually the only way in which data based on individual elements with no continuity across element boundaries is presented is by taking an average over the entire element and represent the values as uniform across each element. Various methods of the function elemfieldfromintegpoints produce elemental fields of this nature.","category":"page"},{"location":"guide/guide.html#Import/export","page":"Guide","title":"Import/export","text":"","category":"section"},{"location":"guide/guide.html#Importing","page":"Guide","title":"Importing","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"At the moment importing is mostly limited to the mesh data (properties, boundary conditions, analysis of data, etc. are typically not imported). The following formats of finite element input files can be handled:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"NASTRAN (.nas files).\nAbaqus (.inp files).","category":"page"},{"location":"guide/guide.html#Exporting","page":"Guide","title":"Exporting","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"VTK (.vtk so-called legacy files). Export of geometry and fields (nodal and elemental) is supported.\nAbaqus (.inp files). Mesh data and selected property, boundary condition, and procedure commands can be handled.\nNASTRAN (.nas files). Very basic mesh and select other attributes are handled.\nSTL file export of surface data.\nH2Lib triangular-surface export (.tri files).\nCSV file export of numerical data is supported.","category":"page"},{"location":"guide/guide.html#Tutorials-and-Examples","page":"Guide","title":"Tutorials and Examples","text":"","category":"section"},{"location":"guide/guide.html#Tutorials","page":"Guide","title":"Tutorials","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The FinEtools tutorials are written up in the repositories for the applications, heat diffusion, linear and nonlinear deformation and so on.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The tutorials are in the form of Julia files with markdown. These are converted to markdown files using the Literate workflow.","category":"page"},{"location":"guide/guide.html#Examples","page":"Guide","title":"Examples","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The examples of the use of the FinEtools package are separated in their own separate repositories, for instance  FinEtoolsHeatDiff, FinEtoolsAcoustics, and so on. For a complete information refer to the list of the repositories.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The examples are in the form of  Julia files with multiple functions, where each function defines one or more related examples. Take for instance the example file Fahy_examples.jl. This incantation will run all the examples from the example file:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"include(\"Fahy_examples.jl\"); Fahy_examples.allrun()","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"This will run just a single example from this file:","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"include(\"Fahy_examples.jl\"); Fahy_examples.fahy_H8_example()","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The example file Fahy_examples.jl consists of a module (whose name matches the name of the file), and  the module defines multiple functions,  one for each example, and one to run all examples, allrun.","category":"page"},{"location":"guide/guide.html#Tests","page":"Guide","title":"Tests","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Check out the numerous tests in the test folder. There are hundreds of tests which exercise the various functions of the library. These examples may help you understand how to extract the desired outcome.","category":"page"},{"location":"guide/guide.html#Make-up-your-own-public-interface","page":"Guide","title":"Make up your own public interface","text":"","category":"section"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Here we assume that the FinEtools package is installed. We also assume the user works in his or her own folder, which for simplicity we assume is a package folder in the same tree as the package folder for FinEtools.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The user may have his or her additions to the FinEtools library, for instance a new material implementation, or a new FEMM (finite element model machine). Additionally, the user writes some code to solve particular problems.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"In order to facilitate interactive work at the command line(REPL), it is convenient to have one or two modules so that using them allows for the user's code to resolve function names from the FinEtools package and from the user's own code.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Here are two ways in which this can be accomplished.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"The user exports his or her own additions from the module add2FinEtools (the name of this module is not obligatory, it can be anything). In addition, the public interface to the FinEtools package needs to be brought in separately.\nusing FinEtools  using add2FinEtools\nThe user may change entirely the public interface to the FinEtools package by selectively including parts of the FinEtools.jl file and the code to export his or her own functionality in a single module, let us say myFinEtools (this name is arbitrary), so that when the user invokes\nusing myFinEtools\nall the functionality that the USER considers to be public is made available by exports.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Method 1 has the advantage that the interface definition of the FinEtools package itself does not change, which means that package code does not need to be touched. It also has a disadvantage that the interface to FinEtools does not change which means that if there is a conflict with one of the exported functions from FinEtools, it needs to be resolved by fiddling with other packages.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Method 2 has the advantage that when there is a conflict between one of the exported FinEtools functions and some other function, be it from another package or the user's own, the conflict can be resolved by changing the public interface to FinEtools by the USER (as opposed to  by the DEVELOPER). Also, in this method the USER has the power to define the public interface to the FinEtools package, and if the user decides that nothing should be exported for implicit resolution of functions, that is easily accomplished.","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"These two methods have been described by examples in the FinEtoolsUseCase package. Refer to the Readme  file and to the method descriptions  in the  method 1 and 2 folders.","category":"page"},{"location":"index.html#FinEtools-(Finite-Element-tools)-Documentation","page":"Home","title":"FinEtools (Finite Element tools) Documentation","text":"","category":"section"},{"location":"index.html#Conceptual-guide","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 3","category":"page"},{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#Coordinate-systems","page":"Types","title":"Coordinate systems","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.CSysModule.CSys","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys{F<:Function}\n\nType for coordinate system transformations. Used to define material coordinate systems, and output coordinate systems, for instance.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(csmat::FFltMat)\n\nConstruct coordinate system when the rotation matrix is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Int64,Int64}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::FInt, mdim::FInt)\n\nConstruct coordinate system for isotropic-material used with isoparametric finite elements.\n\nsdim = number of space dimensions,\nmdim = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.\n\nnote: Note\n\n\nIf  the coordinate system matrix  should be identity, better use the constructor for this specific situation, CSys(dim::FInt). That will be much more efficient.\n\nSee also\n\ngen_iso_csmat\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Int64}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(dim::FInt)\n\nConstruct coordinate system when the rotation matrix is the identity.\n\ndim = is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F<:Function","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::FInt, mdim::FInt, computecsmat::F) where {F<:Function}\n\nConstruct ccoordinate system when the function to compute the rotation matrix is given.\n\nThe function signature: update!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt) where\n\ncsmatout= output matrix buffer, of size (sdim, mdim)\nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element,\nfe_label= finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Finite-element-sets","page":"Types","title":"Finite element sets","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet","page":"Types","title":"FinEtools.FESetModule.AbstractFESet","text":"AbstractFESet{NODESPERELEM}\n\nAbstract type of a finite element set. Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet0Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet0Manifold","text":"AbstractFESet0Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet1Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet1Manifold","text":"AbstractFESet1Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet2Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet2Manifold","text":"AbstractFESet2Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet3Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet3Manifold","text":"AbstractFESet3Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH20","page":"Types","title":"FinEtools.FESetModule.FESetH20","text":"FESetH20\n\nType for sets of volume-like hexahedral finite elements with 20 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH27","page":"Types","title":"FinEtools.FESetModule.FESetH27","text":"FESetH27\n\nType for sets of volume-like hexahedral finite elements with 27 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH8","page":"Types","title":"FinEtools.FESetModule.FESetH8","text":"FESetH8\n\nType for sets of volume-like hexahedral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL2","page":"Types","title":"FinEtools.FESetModule.FESetL2","text":"FESetL2\n\nType for sets of curve-like finite elements with two nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL3","page":"Types","title":"FinEtools.FESetModule.FESetL3","text":"FESetL3\n\nType for sets of curve-like of finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetP1","page":"Types","title":"FinEtools.FESetModule.FESetP1","text":"FESetP1\n\nType for sets of point-like of finite elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ4","page":"Types","title":"FinEtools.FESetModule.FESetQ4","text":"FESetQ4\n\nType for sets of surface-like quadrilateral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ8","page":"Types","title":"FinEtools.FESetModule.FESetQ8","text":"FESetQ8\n\nType for sets of surface-like quadrilateral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ9","page":"Types","title":"FinEtools.FESetModule.FESetQ9","text":"FESetQ9\n\nType for sets of surface-like quadrilateral finite elements with nine nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT10","page":"Types","title":"FinEtools.FESetModule.FESetT10","text":"FESetT10\n\nType for sets of volume-like tetrahedral finite elements with 10 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT3","page":"Types","title":"FinEtools.FESetModule.FESetT3","text":"FESetT3\n\nType for sets of surface-like triangular finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT4","page":"Types","title":"FinEtools.FESetModule.FESetT4","text":"FESetT4\n\nType for sets of volume-like tetrahedral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT6","page":"Types","title":"FinEtools.FESetModule.FESetT6","text":"FESetT6\n\nType for sets of surface-like triangular finite elements with six nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-nodes","page":"Types","title":"Finite element nodes","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeSetModule.FENodeSet","page":"Types","title":"FinEtools.FENodeSetModule.FENodeSet","text":"Finite element node set type.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-node-to-element-map","page":"Types","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"Map from finite element nodes to the finite elements connecting them.\n\nFor each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array map.         Example: \n\nfes.conn= [7,6,5;\n            4,1,3;\n            3,7,5];\nThe map reads\n    map[1] = [2];\n    map[2] = [];#  note that node number 2 is not referenced by the connectivity\n    map[3] = [2,3];\n    map[4] = [2];\n    map[5] = [1,3];\n    map[6] = [1];\n    map[7] = [1,3];\n\nThe individual elements from the connectivity that reference node number 5 are 1 and 3, so that fes.conn(map[5],:)includes all the nodes that are connected to node 5 (including node 5 itself).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Array{Int64,2},Int64}","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(conns::FIntMat, nmax::FInt)\n\nMap from finite element nodes to the finite elements connecting them.\n\nconns = integer array of the connectivities\nnmax = largest possible node number\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT<:Integer where N","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT<:Integer}\n\nMap from finite element nodes to the finite elements connecting them.\n\nconns = connectivities as a vector of tuples\nnmax = largest possible node number\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Fields","page":"Types","title":"Fields","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FieldModule.AbstractField","page":"Types","title":"FinEtools.FieldModule.AbstractField","text":"AbstractField\n\nAbstract field.\n\nExpected  attributes:\n\nvalues::FMat{T}: Array of degree of freedom parameters,  indexed by entity number\ndofnums::FIntMat: Array of degree of freedom numbers, indexed by entity number\nis_fixed::Matrix{Bool}: Array of Boolean flags, indexed by entity number\nfixed_values::FMat{T}: Array of fixed values, indexed by entity number\nnfreedofs::FInt: Total number of free degrees of freedom\n\nSee also: @add_Field_fields() .\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField{T<:Number} <: AbstractField\n\nGeneral field, meaning the entities can be anything.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::FVec{T}) where {T<:Number}\n\nConstructor of general field.  The values of the field are given by the vector on input, data. This vector needs to have as many rows as there are entities.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of general field.  The values of the field are given by the array on input, data. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField{T<:Number} <: AbstractField\n\nNodal field, meaning the entities are the finite element nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::FVec{T}) where {T<:Number}\n\nConstructor of nodal field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of nodal field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField{T<:Number} <: AbstractField\n\nElemental field, meaning the entities are finite elements.\n\nThe values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::FVec{T}) where {T<:Number}\n\nConstructor of elemental field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of elemental field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Integration-rule","page":"Types","title":"Integration rule","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegRuleModule.AbstractIntegRule","page":"Types","title":"FinEtools.IntegRuleModule.AbstractIntegRule","text":"AbstractIntegRule\n\nAbstract type for integration rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule <: AbstractIntegRule\n\nThe Gauss rul, applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule-2","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule(dim=1, order=1)\n\nGauss rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule <: AbstractIntegRule\n\nThe nodal-quadrature simplex rule.\n\nThe rule is applicable for line segments, triangles, tetrahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule-2","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule(dim=1)\n\nNodal-quadrature simplex rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule <: AbstractIntegRule\n\nThe tensor-product nodal-quadrature rule.\n\nThe rule is applicable for line segments, quadrilaterals, hexahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule-2","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule(dim=1)\n\nNodal-quadrature tensor-product rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule <: AbstractIntegRule\n\nPoint quadrature rule, used for integration on the standard \"point\" shape.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule-Tuple{}","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule()\n\nPOINT integration rule.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule <: AbstractIntegRule\n\nSimplex quadrature rule.\n\nUsed for integration on the standard triangle or the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule-2","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule(dim=1, npts=1)\n\nReturn simplex rule, appropriate for the manifold dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule <: AbstractIntegRule\n\nTetrahedral quadrature rule, used for integration on the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule(npts=1)\n\nTetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule <: AbstractIntegRule\n\nThe trapezoidal rule.\n\nThe rule is applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule(dim=1)\n\nTrapezoidal rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule <: AbstractIntegRule\n\nTriangular quadrature rule for integration on the standard triangle.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule(npts=1)\n\nType for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. npts = number of points (1– one-point rule, 3 – three-point rule, 6 – six  point rule, 9 –nine point rule, 10 – Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13–twelve- and thirteen-point rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Integration-domain","page":"Types","title":"Integration domain","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain{S<:AbstractFESet, F<:Function}\n\nIntegration domain.\n\nT = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.\nF = type of function to return the \"other\" dimension.\n\nAn integration domain consists of the finite elements that approximate the geometry, the function to supply the \"missing\" (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool,Float64}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule, axisymmetric::Bool,\n  otherdimension::FFlt) where {S<:AbstractFESet}\n\nConstruct for axially symmetric models. The other dimension is given as a number.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule,\n  axisymmetric::Bool) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), for axially symmetric models. The other dimension is the default unity (1.0).\n\nThis will probably be called when axisymmetric = true, since the default is axisymmetric = false.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Float64}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule,\n  otherdimension::FFlt) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), and constant other dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), and the other dimension  being the default 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Assembly-of-matrices-and-vectors","page":"Types","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysmatAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysmatAssembler","text":"AbstractSysmatAssembler\n\nAbstract type of system-matrix assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysvecAssembler","text":"AbstractSysvecAssembler\n\nAbstract type of system vector assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerReduced","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerReduced","text":"SysmatAssemblerReduced{T<:Number} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from elementwise matrices.\n\nnote: Note\nAll fields of the datatype are private. No need to access them directly.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse{T<:Number} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from elementwise matrices.\n\nnote: Note\nAll fields of the datatype are private. No need to access them directly.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T,Any}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse(zero::T=0.0, nomatrixresult = false) where {T<:Number}\n\nConstruct blank system matrix assembler. \n\nThe matrix entries are of type T. The assembler either produces a sparse matrix (when nomatrixresult = true), or does not (when nomatrixresult = false). When the assembler does not produce the sparse matrix when makematrix! is called, it still can be constructed from the buffers stored in the assembler.\n\nExample\n\nThis is how a sparse matrix is assembled from two rectangular dense matrices.\n\n    a = SysmatAssemblerSparse(0.0)                                                        \n    startassembly!(a, 5, 5, 3, 7, 7)    \n    m = [0.24406   0.599773    0.833404  0.0420141                                             \n        0.786024  0.00206713  0.995379  0.780298                                              \n        0.845816  0.198459    0.355149  0.224996]                                     \n    assemble!(a, m, [1 7 5], [5 2 1 4])        \n    m = [0.146618  0.53471   0.614342    0.737833                                              \n         0.479719  0.41354   0.00760941  0.836455                                              \n         0.254868  0.476189  0.460794    0.00919633                                            \n         0.159064  0.261821  0.317078    0.77646                                               \n         0.643538  0.429817  0.59788     0.958909]                                   \n    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        \n    A = makematrix!(a) \n\nWhen the nomatrixresult is set as true, no matrix is produced.\n\n    a = SysmatAssemblerSparse(0.0, true)                                                        \n    startassembly!(a, 5, 5, 3, 7, 7)    \n    m = [0.24406   0.599773    0.833404  0.0420141                                             \n        0.786024  0.00206713  0.995379  0.780298                                              \n        0.845816  0.198459    0.355149  0.224996]                                     \n    assemble!(a, m, [1 7 5], [5 2 1 4])        \n    m = [0.146618  0.53471   0.614342    0.737833                                              \n         0.479719  0.41354   0.00760941  0.836455                                              \n         0.254868  0.476189  0.460794    0.00919633                                            \n         0.159064  0.261821  0.317078    0.77646                                               \n         0.643538  0.429817  0.59788     0.958909]                                   \n    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        \n    A = makematrix!(a) \n\nHere A is a sparse zero matrix. To construct the correct matrix is still  possible, for instance like this:\n\n    a.nomatrixresult = false\n    A = makematrix!(a) \n\nAt this point all the buffers of the assembler have been cleared, and  makematrix!(a) is no longer possible.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm{T<:Number} <: AbstractSysmatAssembler\n\nAssembler for a symmetric lumped square matrix  assembled from  symmetric square matrices. \n\nReference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering & Structural Dynamics, volume 4, number 3, 245–249, 1976. }\n\nnote: Note\nThis assembler can compute and assemble diagonalized mass matrices. However, if the meaning of the entries of the mass matrix  differs (translation versus rotation), the mass matrices will not be computed correctly. Put bluntly: it can only be used for homogeneous mass matrices, all translation degrees of freedom, for instance. \n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm(zer::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm{T<:Number} <: AbstractSysmatAssembler\n\nAssembler for a symmetric square matrix  assembled from symmetric square matrices.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm(zero::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler for symmetric matrices. The matrix entries are of type T.\n\nExample\n\nThis is how a symmetric sparse matrix is assembled from two square dense matrices.\n\n\ta = SysmatAssemblerSparseSymm(0.0)                                                        \n\tstartassembly!(a, 5, 5, 3, 7, 7)    \n\tm = [0.24406   0.599773    0.833404  0.0420141                                             \n\t\t0.786024  0.00206713  0.995379  0.780298                                              \n\t\t0.845816  0.198459    0.355149  0.224996]                                     \n\tassemble!(a, m'*m, [5 2 1 4], [5 2 1 4])        \n\tm = [0.146618  0.53471   0.614342    0.737833                                              \n\t\t 0.479719  0.41354   0.00760941  0.836455                                              \n\t\t 0.254868  0.476189  0.460794    0.00919633                                            \n\t\t 0.159064  0.261821  0.317078    0.77646                                               \n\t\t 0.643538  0.429817  0.59788     0.958909]                                   \n\tassemble!(a, m'*m, [2 3 1 5], [2 3 1 5])                                        \n\tA = makematrix!(a) \n\nSee also\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler\n\nAssembler for the system vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler-Union{Tuple{}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler(zero::T=0.0) where {T<:Number}\n\nConstruct blank system vector assembler. The vector entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Mesh-import/export","page":"Types","title":"Mesh import/export","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MeshImportModule, FinEtools.MeshExportModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Vector-cache-utilities","page":"Types","title":"Vector-cache utilities","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.VectorCacheModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache{T<:Number, F<:Function}\n\nType for caching vectors.\n\nT = type of the entries of the vector, F = type of the function to update the entries of the vector.\n\nSignature of the function to fill the cache with the value of the vector at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, and, if convenient, also the finite element label, fe_label. Finally, the value of the vector may also depend on the time (or the load factor):\n\nfillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)\n\nThe cache cacheout is filled with the value  of the vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache(vector::FVec{T}) where {T<:Number}\n\nConstruct vector cache. The constant vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache(::Type{T}, nentries::FInt, fillcache!::F, time::FFlt) where {T<:Number, F<:Function}\n\nConstruct vector cache. The function to fill the vector cache is given.\n\nThis constructor is intended for time-dependent vector caches. This function needs to have a signature of\n\nfillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)\n    Calculate the vector and copy it into the cache....\n    return forceout\nend\n\nand it needs to  fill in the cache cacheout with the current vector at the location XYZ, using the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label, if appropriate. The time can also be supplied (keyword argument time).\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache(::Type{T}, nentries::FInt, fillcache!::F) where {T<:Number, F<:Function}\n\nConstruct vector cache. The function to fill the vector cache is given.\n\nThis constructor is intended for time-independent vector caches. This function needs to have a signature of\n\nfillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    Calculate the vector and copy it into the cache....\n    return forceout\nend\n\nand it needs to  fill in the cache cacheout with the current vector at the location XYZ, using the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label, if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Surface-normal-utilities","page":"Types","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal{F<:Function}\n\nExterior surface normal type.\n\nNormalized to unit length.\n\nSignature of the function to compute the value of the unit normal at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, and if necessary  also the finite element label, fe_label:\n\ncomputenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nThe buffer normalout is filled with the value  of the normal vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions::FInt)\n\nConstruct surface normal evaluator when the default calculation of the normal vector based on the columns of the Jacobian matrix should be used. This function needs to have a signature of\n\nfunction computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    Calculate the normal and copy it into the buffer....\n    return normalout # return the buffer\nend\n\nand it needs to  fill in the buffer normalout with the current vector at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\nThe normal vector has ndimensions entries.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(vector::FVec{T}) where {T<:Number}\n\nConstruct surface normal vector when the constant normal vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F<:Function","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions::FInt, computenormal!::F) where {F<:Function}\n\nConstruct surface normal evaluator when the function to compute the normal vector is given. This function needs to have a signature of\n\nfunction computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    Calculate the normal and copy it into the buffer....\n    return normalout # return the buffer\nend\n\nand it needs to  fill in the buffer normalout with the current vector at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Force-intensity","page":"Types","title":"Force intensity","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity{T<:Number, F<:Function}\n\nDistributed force (force intensity) type.\n\nThe force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:\n\nforce/length^3 (when applied to a 3-D solid),\nforce/length^2 (when applied to a surface),\nforce/length^1 (when applied along a curve), or\nforce/length^0 (when applied at a point).\n\nSignature of the function to compute the value of the force  at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, and if necessary  also the finite element label, fe_label:\n\ngetforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nThe buffer forceout is filled with the value  of the force. The vector forceout is also returned for convenience.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Tuple{T} where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::T) where {T<:Number}\n\nConstruct force intensity when the force is given as a scalar value.\n\nThe dimension of the force vector in this case is 1.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::FVec{T}) where {T<:Number}\n\nConstruct force intensity when the constant force vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F, time::FFlt) where {T<:Number, F<:Function}\n\nConstruct force intensity when the function to compute the intensity vector is given.\n\nThis constructor is intended for time-dependent force intensity caches.\n\nArguments\n\nT = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,\nndofn = number of elements of the force vector (the length of the force vector),\ncomputeforce! = callback function,\ntime = initial time.\n\nThe function computeforce! needs to have a signature of\n\nfunction computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)\n\tCalculate the force  and copy it into the buffer....\n\treturn forceout\nend\n\nand it needs to  fill in the buffer forceout with the current force at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label. The initial time is given.\n\nThe time needs to be set with settime! before calling updateforce! as follows:\n\nXYZ = reshape([0.0, 0.0], 2, 1)\ntangents = reshape([0.0, 1.0], 2, 1)\nfe_label = 0\nsetvector!(v, XYZ, tangents, fe_label; time::FFlt = 0.0) = begin\n    return (time < 5.0 ?  v .= [10.0] : v .= [0.0])\nend\nvector = [10.0]\nfi = ForceIntensity(FFlt, length(vector), setvector!, 0.0)\nv = updateforce!(fi, XYZ, tangents, fe_label)\n@test v == [10.0]\nsettime!(fi, 6.0)\nv = updateforce!(fi, XYZ, tangents, fe_label)\n@test v == [0.0]\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F) where {T<:Number, F<:Function}\n\nConstruct force intensity when the function to compute the intensity vector is given.\n\nThis constructor is intended for time-independent vector caches.\n\nArguments\n\nT = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,\nndofn = number of elements of the force vector (the length of the force vector),\ncomputeforce! = callback function.\n\nThe function computeforce! needs to have a signature of\n\nfunction computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    Calculate the force  and copy it into the buffer....\n    return forceout\nend\n\nand it needs to  fill in the buffer forceout with the current force at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FEM-machines","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Base","page":"Types","title":"Base","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FEMMBaseModule.AbstractFEMM","page":"Types","title":"FinEtools.FEMMBaseModule.AbstractFEMM","text":"AbstractFEMM\n\nAbstract type for all finite element model machines.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nClass for base finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F<:Function where S<:AbstractFESet","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase(integdomain::IntegDomain{S, F}) where {S<:AbstractFESet, F<:Function}\n\nConstruct with the default orientation matrix (identity).\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Material-models","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#Material-model-abstractions","page":"Types","title":"Material model abstractions","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MatModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.MatModule.AbstractMat","page":"Types","title":"FinEtools.MatModule.AbstractMat","text":"AbstractMat\n\nAbstract type of material.\n\n\n\n\n\n","category":"type"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#Physical-units","page":"Functions","title":"Physical units","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.PhysicalUnitModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.PhysicalUnitModule.phun-Tuple{String}","page":"Functions","title":"FinEtools.PhysicalUnitModule.phun","text":"phun(str::String; system_of_units = :SI, base_time_units = :SEC)\n\nEvaluate an expression in physical units.\n\nExample\n\npu = ustring -> phun(ustring; system_of_units = :SIMM)\nE1s = 130.0*pu(\"GPa\")\n\nyields 1.3e+5 (in mega Pascal) whereas\n\n130.0*phun(\"GPa\"; system_of_units = :SI)\n\nyields 1.3e+11 (in Pascal)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Bounding-box-functions","page":"Functions","title":"Bounding box functions","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.BoxModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.boundingbox","text":"boundingbox(x::AbstractArray)\n\nCompute the bounding box of the points in x.\n\nx = holds points, one per row.\n\nReturns box = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.boxesoverlap-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.boxesoverlap","text":"boxesoverlap(box1::AbstractVector, box2::AbstractVector)\n\nDo the given boxes overlap?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.inbox-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.inbox","text":"inbox(box::AbstractVector, x::AbstractVector)\n\nIs the given location inside the box?\n\nbox = vector entries arranged as minx,maxx,miny,maxy,minz,maxz.\n\nNote: point on the boundary of the box is counted as being inside.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.inflatebox!-Tuple{AbstractArray{T,1} where T,Number}","page":"Functions","title":"FinEtools.BoxModule.inflatebox!","text":"inflatebox!(box::AbstractVector, inflatevalue::Number)\n\nInflate the box by the value supplied.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.initbox!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.initbox!","text":"initbox!(box::AbstractVector, x::AbstractVector)\n\nInitialize a bounding box with a single point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.intersectboxes-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.intersectboxes","text":"intersectboxes(box1::AbstractVector, box2::AbstractVector)\n\nCompute the intersection of two boxes.\n\nThe function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.updatebox!-Tuple{AbstractArray{T,1} where T,AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.updatebox!","text":"updatebox!(box::AbstractVector, x::AbstractArray)\n\nUpdate a box with another location, or create a new box.\n\nIf the  box does not have  the correct dimensions,  it is correctly sized.\n\nbox = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]     The box is expanded to include the     supplied location x.   The variable x  can hold multiple points in rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Coordinate-systems","page":"Functions","title":"Coordinate systems","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.CSysModule.gen_iso_csmat!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.CSysModule.gen_iso_csmat!","text":"gen_iso_csmat(XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nCompute the coordinate system  for an isotropic material using information available  by looking at the coordinate curves of isoparametric finite elements.\n\nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element,\nfe_label= finite element label.\n\nThe basic assumption here is that the material is isotropic, and therefore the choice of the material directions does not really matter as long as they correspond to the dimensionality of the element. For instance a one-dimensional element (L2 as an example) may be embedded in a three-dimensional space.\n\nThis function assumes that it is being called for an mdim-dimensional manifold element, which is embedded in a sdim-dimensional Euclidean space. If mdim == sdim, the coordinate system matrix is the identity; otherwise the local coordinate directions are aligned with the linear subspace defined by the tangent vectors.\n\nwarning: Warning\n\n\nThis cannot be reliably used to produce consistent stresses because each quadrature point gets a local coordinate system which depends on the orientation of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.CSysModule.updatecsmat!-Tuple{CSys,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.CSysModule.updatecsmat!","text":"function updatecsmat!(self::CSys, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the coordinate system orientation matrix.\n\nThe  coordinate system matrix is updated based upon the location XYZ of the evaluation point, and possibly on the Jacobian matrix tangents within the element in which the coordinate system matrix is evaluated,  or perhaps on the label fe_label of the finite element.\n\nAfter this function returns, the coordinate system matrix can be retrieved from the buffer as self.csmat.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Matrix-utilities","page":"Functions","title":"Matrix utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatrixUtilityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btdb_ut_only!","text":"add_btdb_ut_only!(Ke::FFltMat, B::FFltMat, Jac_w::FFlt,\n              D::FFltMat, DB::FFltMat)\n\nAdd the product  (B'*(D*(Jac*w[j]))*B), to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrices B and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btsigma!-Tuple{Array{Float64,1},Array{Float64,2},Float64,Array{Float64,1}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btsigma!","text":"add_btsigma!(Fe::FFltVec, B::FFltMat, coefficient::FFlt, sigma::FFltVec)\n\nAdd the product  B'*(sigma*coefficient), to the elementwise vector Fe.\n\nThe vector Fe is assumed to be suitably initialized.\n\nThe vector Fe is modified.  The vector sigma is not modified inside this function. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_gkgt_ut_only!","text":"add_gkgt_ut_only!(Ke::FFltMat, gradN::FFltMat, Jac_w::FFlt,\n  kappa_bar::FFltMat, kappa_bargradNT::FFltMat)\n\nAdd the product gradN*kappa_bar*gradNT*(Jac*w[j]) to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nUpon return,  the matrix Ke is updated.  The scratch buffer kappa_bargradNT is overwritten during each call of this function. The matrices gradN and kappa_bar are not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_mggt_ut_only!","text":"add_mggt_ut_only!(Ke::FFltMat, gradN::FFltMat, mult::FFlt)\n\nAdd the product gradN*mult*gradNT to the elementwise matrix Ke. The argument mult is a scalar. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrix gradN is not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Array{T,2},Array{Float64,2},T}} where T<:Number","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_nnt_ut_only!","text":"add_nnt_ut_only!(Ke::FFltMat, Nn::FFltMat, Jac_w_coeff::FFlt)\n\nAdd the product  Nn*(Nn'*(coeff*(Jac*w(j))), to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched.\n\nThe matrix Ke is assumed to be suitably initialized. The  matrix Nn has a single column.\n\nThe matrix Ke is modified.  The matrix Nn is not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.adjugate3!","text":"adjugate3!(B, A)\n\nCompute the adjugate matrix of A.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.complete_lt!-Tuple{Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.complete_lt!","text":"complete_lt!(Ke::FFltMat)\n\nComplete the lower triangle of the elementwise matrix Ke.\n\nThe matrix Ke is modified  inside this function. The upper-triangle  entries  are copied  across the diagonal to the lower triangle.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.detC-Tuple{Val{3},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.detC","text":"detC(::Val{3}, C::FFltMat)\n\nCompute determinant of 3X3 C.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.export_sparse-Tuple{Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.export_sparse","text":"export_sparse(filnam, M)\n\nExport sparse matrix to a text file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.import_sparse-Tuple{Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.import_sparse","text":"import_sparse(filnam)\n\nImport sparse matrix from a text file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.jac!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.jac!","text":"jac!(J::FFltMat, ecoords::FFltMat,gradNparams::FFltMat)\n\nCompute the Jacobian matrix at the quadrature point.\n\nArguments: J = Jacobian matrix, overwritten  inside the function ecoords = matrix of the node coordinates for the element. gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.loc!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.loc!","text":"loc!(loc::FFltMat, ecoords::FFltMat, N::FFltMat)\n\nCompute the location of the quadrature point.\n\nArguments: loc = matrix of coordinates, overwritten  inside the function ecoords = matrix of the node coordinates for the element. N = matrix of basis function values\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.locjac!-NTuple{5,Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.locjac!","text":"locjac!(loc::FFltMat, J::FFltMat, ecoords::FFltMat, N::FFltMat, gradNparams::FFltMat)\n\nCompute location and Jacobian matrix at the quadrature point.\n\nArguments: loc = matrix of coordinates, overwritten  inside the function J = Jacobian matrix, overwritten  inside the function ecoords = matrix of the node coordinates for the element. N = matrix of basis function values gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(C, A, B)\n\nCompute the matrix C = A * B\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\nNote: See the thread https://discourse.julialang.org/t/ann-loopvectorization/32843/36\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3},Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = A * B\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Array{T,1},Any,Array{T,1}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(C::Vector{T}, A, B::Vector{T})  where {T}\n\nCompute the product C = A * B, where C and B are \"vectors\".\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCABt!","text":"mulCABt!(C, A, B)\n\nCompute the matrix C = A * B'\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3},Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCABt!","text":"mulCABt!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = A * Transpose(B)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAtB!","text":"mulCAtB!(C, A, B)\n\nCompute the matrix C = A' * B\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3},Any,Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAtB!","text":"mulCAtB!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = Transpose(A) * B\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.symmetrize!","text":"symmetrize!(a)\n\nMake the matrix on input symmetric.\n\nThe operation is in-place.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-sets","page":"Functions","title":"Finite element sets","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.cat-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFESet","page":"Functions","title":"Base.cat","text":"cat(self::T,  other::T) where {T<:AbstractFESet}\n\nConcatenate the connectivities of two FE sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.count-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"Base.count","text":"count(self::T)::FInt where {T<:AbstractFESet}\n\nGet the number of individual connectivities in the FE set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet0Manifold}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet1Manifold}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet2Manifold}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet3Manifold}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.bfun","text":"bfun(self::T,  param_coords::FFltVec)::FFltMat where {T<:AbstractFESet}\n\nCompute the values of the basis functions.\n\nCompute the values of the basis functions at a given parametric coordinate. One basis function per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.bfundpar","text":"bfundpar(self::T,  param_coords::FFltVec)::FFltMat where {T<:AbstractFESet}\n\nCompute the values of the basis function gradients.\n\nCompute the values of the basis function gradients with respect to the parametric coordinates at a given parametric coordinate. One basis function gradients per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryconn-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryconn","text":"boundaryconn(self::T) where {T<:AbstractFESet}\n\nGet boundary connectivity.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryfe-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryfe","text":"boundaryfe(self::T) where {T<:AbstractFESet}\n\nReturn the constructor of the type of the boundary finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.centroidparametric-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.centroidparametric","text":"centroidparametric(self::T) where {T<:AbstractFESet}\n\nReturn the parametric coordinates  of the centroid of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.connasarray","text":"connasarray(self::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nReturn the connectivity as an array.\n\nReturn the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM},Array{Int64,2}}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.fromarray!","text":"fromarray!(self::AbstractFESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}\n\nSet  the connectivity from an integer array.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet1Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet1Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet2Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet2Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet3Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet3Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.inparametric-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.inparametric","text":"inparametric(self::AbstractFESet, param_coords::FFltVec)\n\nAre given parametric coordinates inside the element parametric domain?\n\nReturn a Boolean: is the point inside, true or false?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.manifdim","text":"manifdim(me)\n\nGet the manifold dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.map2parametric-Union{Tuple{T}, Tuple{T,Array{Float64,2},Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.map2parametric","text":"map2parametric(self::T, x::FFltMat, pt::FFltVec;\n    tolerance = 0.001, maxiter =5) where {T<:AbstractFESet}\n\nMap a spatial location to parametric coordinates.\n\nx=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,\nc= spatial location\ntolerance = tolerance in parametric coordinates; default is 0.001.\n\nReturn\n\nsuccess = Boolean flag, true if successful, false otherwise.\npc = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.nodesperelem","text":"nodesperelem(fes::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nProvide the number of nodes per element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.nodesperelem-Union{Tuple{Type{T}}, Tuple{T}, Tuple{NODESPERELEM}} where T<:AbstractFESet{NODESPERELEM} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.nodesperelem","text":"nodesperelem(::Type{T}) where {NODESPERELEM, T<:AbstractFESet{NODESPERELEM}}\n\nProvide the number of nodes per element for a given type.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::T, val::FIntVec) where {T<:AbstractFESet}\n\nSet the labels of individual elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Int64}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::T, val::FInt) where {T<:AbstractFESet}\n\nSet the label of the entire finite elements set.\n\nAll elements are labeled with this number.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.subset-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.subset","text":"subset(self::T, L::FIntVec) where {T<:AbstractFESet}\n\nExtract a subset of the finite elements from the given finite element set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.updateconn!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.updateconn!","text":"updateconn!(self::T, newids::FIntVec) where {T<:AbstractFESet}\n\nUpdate the connectivity after the IDs of nodes changed.\n\nnewids= new node IDs. Note that indexes in the conn array \"point\" into the  newids array. After the connectivity was updated this will no longer be true!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-nodes","page":"Functions","title":"Finite element nodes","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.count-Tuple{FENodeSet}","page":"Functions","title":"Base.count","text":"count(self::FENodeSet)\n\nGet the number of finite element nodes in the node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.spacedim","text":"spacedim(self::FENodeSet)\n\nNumber of dimensions of the space in which the node lives, 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.xyz3","text":"xyz3(self::FENodeSet)\n\nGet the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-node-to-element-map","page":"Functions","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Selecting-nodes-and-elements","page":"Functions","title":"Selecting nodes and elements","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshSelectionModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectedelems-Tuple{AbstractFESet,Array{Int64,1},Int64}","page":"Functions","title":"FinEtools.MeshSelectionModule.connectedelems","text":"connectedelems(fes::AbstractFESet, node_list::FIntVec)\n\nExtract the list of numbers for the fes  that are connected to given nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.connectednodes","text":"connectednodes(fes::AbstractFESet)\n\nExtract the node numbers of the nodes connected by given finite elements.\n\nExtract the list of unique node numbers for the nodes that are connected by the finite element set fes. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet,AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.findunconnnodes","text":"findunconnnodes(fens::FENodeSet, fes::AbstractFESet)\n\nFind nodes that are not connected to any finite element.\n\nconnected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectelem-Union{Tuple{T}, Tuple{FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshSelectionModule.selectelem","text":"selectelem(fens::FENodeSet, fes::T; kwargs...) where {T<:AbstractFESet}\n\nSelect finite elements.\n\nArguments\n\nfens = finite element node set\nfes = finite element set\nkwargs = keyword arguments to specify the selection criteria\n\nSelection criteria\n\nfacing\n\nSelect all \"boundary\" elements that \"face\" a certain direction.\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);\n\nor\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);\n\nwhere\n\nfunction dout(xyz)\n    return xyz/norm(xyz)\nend\n\nand xyz is the location of the centroid  of  a boundary element. Here the finite element is considered \"facing\" in the given direction if the dot product of its normal and the direction vector is greater than dotmin. The default value for dotmin is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).\n\nThis selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).\n\nlabel\n\nSelect elements based on their label.\n\nrl1 = selectelem(fens, fes, label=1)\n\nbox, distance\n\nSelect elements based on some criteria that their nodes satisfy.  See the function selectnode().\n\nExample: Select all  elements whose nodes are closer than R+inflate from the point from.\n\nlinner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],\n  inflate = tolerance)\n\nExample:\n\nexteriorbfl = selectelem(fens, bdryfes,\n   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);\n\nflood\n\nSelect all FEs connected together, starting from a given node.\n\nExample: Select all FEs connected together (Starting from node 13):\n\nl = selectelem(fens, fes, flood = true, startnode = 13)\n\nOptional keyword arguments\n\nShould we consider the element only if all its nodes are in?\n\nallin = Boolean: if true, then all nodes of an element must satisfy\n\nthe criterion; otherwise  one is enough.\n\nOutput\n\nfelist = list of finite elements from the set that satisfy the criteria\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.MeshSelectionModule.selectnode","text":"selectnode(fens::FENodeSet; kwargs...)\n\nSelect nodes using some criterion.\n\nArguments\n\nv = array of locations, one location per row\nkwargs = pairs of keyword argument/value\n\nSelection criteria\n\nbox\n\nnLx = vselect(fens.xyz, box = [0.0 Lx  0.0 0.0 0.0 0.0], inflate = Lx/1.0e5)\n\nThe keyword 'inflate' may be used to increase or decrease the extent of the box (or the distance) to make sure some nodes which would be on the boundary are either excluded or included.\n\ndistance\n\nlist = selectnode(fens.xyz, distance=1.0+0.1/2^nref, from=[0. 0.],\n        inflate=tolerance);\n\nplane\n\ncandidates = selectnode(fens, plane = [0.0 0.0 1.0 0.0], thickness = h/1000)\n\nThe keyword plane defines the plane by its normal (the first two or three numbers) and its distance from the origin (the last number). Nodes are selected they lie on the plane,  or near the plane within the distance thickness from the plane. The normal is assumed to be of unit length, if it isn't apply as such, it will be normalized internally.\n\nnearestto\n\nFind the node nearest to the location given.\n\nnh = selectnode(fens, nearestto = [R+Ro/2, 0.0, 0.0] )\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.vselect-Tuple{Array{Float64,2}}","page":"Functions","title":"FinEtools.MeshSelectionModule.vselect","text":"vselect(v::FFltMat; kwargs...)\n\nSelect locations (vertices) from the array based on some criterion.\n\nSee the function selectnode() for examples of the criteria that can be used to search vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Fields","page":"Functions","title":"Fields","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.copyto!-Union{Tuple{F}, Tuple{F,F}} where F<:AbstractField","page":"Functions","title":"Base.copyto!","text":"copyto!(DEST::F,  SRC::F) where {F<:AbstractField}\n\nCopy data from one field to another.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.applyebc!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.applyebc!","text":"applyebc!(self::AbstractField)\n\nApply EBCs (essential boundary conditions).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{AbstractField,A,CC}} where CC where A","page":"Functions","title":"FinEtools.FieldModule.gatherdofnums!","text":"gatherdofnums!(self::AbstractField, dest::A, conn::CC) where {A, CC}\n\nGather dofnums from the field.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom for that node,  then the next node  and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asmat!","text":"gatherfixedvalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},\n    conn::CC) where {CC, T}\n\nGather FIXED values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asvec!","text":"gatherfixedvalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},\n    conn::CC) where {CC, T}\n\nGather FIXED values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F,Array{T,1}}} where T where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.gathersysvec!","text":"gathersysvec!(self::F, vec::FVec{T}) where {F<:AbstractField, T}\n\nGather values from the field for the whole system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.gathersysvec","text":"gathersysvec{F<:AbstractField}(self::F)\n\nGather values from the field for the whole system vector. Return a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asmat!","text":"gathervalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},\n    conn::CC) where {CC, T}\n\nGather values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asvec!","text":"gathervalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},\n    conn::CC) where {CC, T}\n\nGather values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.incrscattersysvec!","text":"incrscattersysvec!(self::AbstractField, vec::FVec{T}) where {T<:Number}\n\nIncrement values of the field by scattering a system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.ndofs-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.ndofs","text":"ndofs{F<:AbstractField}(self::T)\n\nDimension of the degree of freedom parameters (i. e. how many degrees of freedom per entity).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nents-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.nents","text":"nents{F<:AbstractField}(self::F)\n\nNumber of nodes associated with the field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.numberdofs!-Tuple{AbstractField,Any}","page":"Functions","title":"FinEtools.FieldModule.numberdofs!","text":"numberdofs!(self::AbstractField, entperm)\n\nNumber the degrees of freedom.\n\nThe free components in the field are numbered consecutively. The sequence of the entities is given by the entperm permutation (array or range). \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.numberdofs!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.numberdofs!","text":"numberdofs!(self::AbstractField)\n\nNumber the degrees of freedom.\n\nThe free components in the field are numbered consecutively. No effort is made to optimize the numbering in any way. If you'd like to optimize the numbering of the degrees of freedom, use a form that sets the permutation of the degrees of freedom, or the permutation of the nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.prescribeddofs-Tuple{AbstractField,AbstractField}","page":"Functions","title":"FinEtools.FieldModule.prescribeddofs","text":"prescribeddofs(uebc, u)\n\nFind which degrees of freedom are prescribed. uebc = field which defines the constraints (is the dof fixed and to which value), u = field which does not have the constraints applied, and serves as the source of equation numbers, uebc and u may be one and the same field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.scattersysvec!","text":"scattersysvec!(self::AbstractField, vec::FVec{T}) where {T<:Number}\n\nScatter values to the field from a system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Array{Int64,1}}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec)\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given nodes.\n\nfenids         - array of N node identifiers\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Int64}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenid::FInt)\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given node.\n\nfenid         - One integer as a node identifier\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField)\n\nSet the EBCs (essential boundary conditions).\n\nAll essential boundary conditions are CLEARED.\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1}}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1},T}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FIntVec, val::T=0.0) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer vector, which degree of freedom (component), val = scalar of type T, default is 0.0\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt,\n  val::FVec{T}) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,T}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt, val::T = 0.0) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, comp::FInt,\n  val::FVec{T}) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64}, Tuple{AbstractField,Array{Int64,1},Int64,T}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, comp::FInt, val::T=0.0) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Int64,Bool,Int64,T}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenid::FInt, is_fixed::Bool, comp::FInt, val::T) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.wipe!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.wipe!","text":"wipe!(self::AbstractField)\n\nWipe all the data from the field.\n\nThis includes values, prescribed values, degree of freedom numbers, and \"is fixed\" flags. The number of free degrees of freedom is set to zero.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}","page":"Functions","title":"FinEtools.NodalFieldModule.nnodes","text":"nnodes(self::NodalField)::FInt = nents(self)\n\nProvide the number of nodes  in the nodal field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}","page":"Functions","title":"FinEtools.ElementalFieldModule.nelems","text":"nelems(self::ElementalField)::FInt = nents(self)\n\nProvide the number of elements  in the elemental field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Integration-rule","page":"Functions","title":"Integration rule","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Integration-domain","page":"Functions","title":"Integration domain","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(self::IntegDomain{T}, J::FFltMat,\n    loc::FFltMat, conn::CC,\n    N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(self::IntegDomain{T}, J::FFltMat,\n          loc::FFltMat, conn::CC,\n          N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\n  loc::FFltMat, conn::CC,\n  N::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 0-dimensional finite element,  the manifold Jacobian is for\n\nm=0: +1\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\nloc::FFltMat, conn::CC,\nN::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 1-dimensional finite element,  the manifold Jacobian is for\n\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 2-dimensional finite element,  the manifold Jacobian is for\n\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim{T<:AbstractFESet3Manifold}(self::IntegDomain, J::FFltMat,\n            loc::FFltMat, conn::FIntMat, N::FFltMat, m::FInt)\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 3-dimensional cell,  the manifold Jacobian is\n\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianpoint","text":"Jacobianpoint(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nFor the zero-dimensional cell, the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc times the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nFor the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n             N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n      loc::FFltMat, conn::CC,\n      N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the zero-dimensional cell, the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc and the other dimension (units of length squared).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc and the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point loc (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet3Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Tuple{IntegDomain}","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(self::IntegDomain)\n\nCalculate the data needed for  numerical quadrature for the integration rule stored by the integration domain.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Union{Tuple{T}, Tuple{IntegDomain,T}} where T<:AbstractIntegRule","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(self::IntegDomain, integration_rule::T) where {T<:AbstractIntegRule}\n\nCalculate the data needed for numerical quadrature.\n\nFor given integration domain, compute the quantities needed for numerical integration.\n\nReturn\n\nnpts, Ns, gradNparams, w, pc = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{CC}, Tuple{Array{Float64,2},CC,Array{Float64,2}}} where CC","page":"Functions","title":"FinEtools.IntegDomainModule.otherdimensionunity","text":"otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt\n          where {CC}\n\nEvaluate the other dimension: default is 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Assembly-of-matrices-and-vectors","page":"Functions","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SV}, Tuple{SV,MV,D}} where D<:(AbstractArray{Int64,N} where N) where MV<:(AbstractArray{T,N} where N) where T<:Number where SV<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssembler{T}, vec::MV,\n  dofnums::D) where {T<:Number, MV<:AbstractArray{T}, D<:AbstractArray{FInt}}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SysvecAssembler{T},MV,D}} where D<:(AbstractArray{Int64,N} where N) where MV<:(AbstractArray{T,N} where N) where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssembler{T}, vec::MV,\n  dofnums::D) where {T<:Number, MV<:AbstractArray{T}, D<:AbstractArray{FInt}}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},\n  dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble a HRZ-lumped square symmetric matrix.\n\nAssembly of a HRZ-lumped square symmetric matrix. The method assembles the scaled diagonal of the square symmetric matrix using the two vectors of equation numbers for the rows and columns.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},\n    dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble an HRZ-lumped square symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},  dofnums::FIntVec, ignore::FIntVec) where {T<:Number}\n\nAssemble a square symmetric matrix.\n\ndofnums are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},\n  dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble a square symmetric matrix.\n\ndofnums are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, mat::FMat{T},\n  dofnums_row::FIntMat, dofnums_col::FIntMat) where {T<:Number}\n\nAssemble a rectangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerReduced}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerReduced)\n\nMake a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)\n\nMake a sparse HRZ-lumped symmetric square  matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseSymm)\n\nMake a sparse symmetric square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparse)\n\nMake a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SV} where SV<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Int64}} where T<:Number where SV<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssembler{T},\n  ndofs_row::FInt) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nndofs_row= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},\n  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,\n  ndofs::FInt, ignore2::FInt) where {T<:Number}\n\nStart the assembly of a symmetric lumped square global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nelem_mat_nrows= number of rows in typical element matrix,\nignore1= number of columns in a typical element matrix: equal to elem_mat_nrows,\nelem_mat_nmatrices= number of element matrices,\nndofs_row= Total number of equations in the row direction,\nignore2= Total number of equations in the column direction: equal to ndofs_row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseSymm{T},\n  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,\n  ndofs::FInt, ignore2::FInt) where {T<:Number}\n\nStart the assembly of a symmetric square global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nelem_mat_nrows= number of rows in typical element matrix,\nelem_mat_ncols= number of columns in a typical element matrix,\nelem_mat_nmatrices= number of element matrices,\nndofs_row= Total number of equations in the row direction,\nndofs_col= Total number of equations in the column direction.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparse{T},\n  elem_mat_nrows::FInt, elem_mat_ncols::FInt, elem_mat_nmatrices::FInt,\n  ndofs_row::FInt, ndofs_col::FInt) where {T<:Number}\n\nStart the assembly of a global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nelem_mat_nrows= number of rows in typical element matrix,\nelem_mat_ncols= number of columns in a typical element matrix,\nelem_mat_nmatrices= number of element matrices,\nndofs_row= Total number of equations in the row direction,\nndofs_col= Total number of equations in the column direction.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysvecAssembler{T},Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssembler{T},\n  ndofs_row::FInt) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nndofs_row= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing","page":"Functions","title":"Meshing","text":"","category":"section"},{"location":"man/functions.html#Meshing-with-line-elements","page":"Functions","title":"Meshing with line elements","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshLineModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2block-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshLineModule.L2block","text":"L2block(Length::FFlt, nL::FInt)\n\nMesh of a 1-D block of L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2blockx-Tuple{Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshLineModule.L2blockx","text":"L2blockx(xs::FFltVec)\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L3blockx-Tuple{Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshLineModule.L3blockx","text":"L3blockx(xs::FFltVec)\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-triangles","page":"Functions","title":"Meshing with triangles","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTriangleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.Q4toT3","page":"Functions","title":"FinEtools.MeshTriangleModule.Q4toT3","text":"Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)\n\nConvert a mesh of quadrilateral Q4's to two T3 triangles  each.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3annulus","page":"Functions","title":"FinEtools.MeshTriangleModule.T3annulus","text":"T3annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3block","page":"Functions","title":"FinEtools.MeshTriangleModule.T3block","text":"T3block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)\n\nT3 Mesh of a rectangle.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3blockx","page":"Functions","title":"FinEtools.MeshTriangleModule.T3blockx","text":"T3blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)\n\nT3 Mesh of a rectangle.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet,FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3refine","text":"T3refine(fens::FENodeSet,fes::FESetT3)\n\nRefine a mesh of 3-node triangles by quadrisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet,FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3toT6","text":"T3toT6(fens::FENodeSet, fes::FESetT3)\n\nConvert a mesh of triangle T3 (three-node) to triangle T6.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6annulus","page":"Functions","title":"FinEtools.MeshTriangleModule.T6annulus","text":"T6annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6block","page":"Functions","title":"FinEtools.MeshTriangleModule.T6block","text":"T6block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)\n\nMesh of a rectangle of T6 elements.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6blockx","page":"Functions","title":"FinEtools.MeshTriangleModule.T6blockx","text":"T6blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)\n\nGraded mesh of a 2-D block of T6 finite elements.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#Meshing-with-quadrilaterals","page":"Functions","title":"Meshing with quadrilaterals","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshQuadrilateralModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4annulus-Tuple{Float64,Float64,Int64,Int64,Float64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4annulus","text":"Q4annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4block-Tuple{Float64,Float64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4block","text":"Q4block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)\n\nMesh of a rectangle, Q4 elements.\n\nDivided into elements: nL, nW in the first, second (x,y).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4blockx-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4blockx","text":"Q4blockx(xs::FFltVec, ys::FFltVec)\n\nGraded mesh  of a rectangle, Q4 finite elements.\n\nMesh of a 2-D block, Q4 finite elements. The nodes are located at the\nCartesian product of the two intervals on the input.  This allows for\nconstruction of graded meshes.\n\nxs,ys - Locations of the individual planes of nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4circlen-Tuple{Float64,Any}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4circlen","text":"Q4circlen(radius::FFlt, nperradius)\n\nMesh of a quarter circle with a given number of elements per radius.\n\nThe parameter nperradius should be an even  number; if that isn't so is adjusted to by adding one. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4elliphole-Tuple{Float64,Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4elliphole","text":"Q4elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt,\n  nL::FInt, nH::FInt, nW::FInt)\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radius of the ellipse,\nL,H= and dimensions of the plate,\nnL,nH= numbers of edges along the side of the plate; this also happens\n  to be the number of edges along the circumference of the elliptical\n  hole\nnW= number of edges along the remaining straight edge (from the hole\n  in the direction of the length),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Tuple{Array{Float64,2},Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4quadrilateral","text":"Q4quadrilateral(xyz::FFltMat, nL::FInt, nW::FInt)\n\nMesh of a general quadrilateral given by the location of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet,FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4refine","text":"Q4refine(fens::FENodeSet, fes::FESetQ4)\n\nRefine a mesh of quadrilaterals by bisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4spheren-Tuple{Float64,Any}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4spheren","text":"Q4spheren(radius::FFlt, nperradius)\n\nGenerate mesh of a sphere.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet,FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4toQ8","text":"Q4toQ8(fens::FENodeSet, fes::FESetQ4)\n\nConvert a mesh of quadrilateral Q4 to quadrilateral Q8.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8annulus-Tuple{Float64,Float64,Int64,Int64,Float64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8annulus","text":"Q8annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl. Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8block-Tuple{Float64,Float64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8block","text":"Q8block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)\n\nMesh of a rectangle of Q8 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8blockx-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8blockx","text":"Q8blockx(xs::FFltVec, ys::FFltVec)\n\nGraded mesh of a 2-D block of Q8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-tetrahedra","page":"Functions","title":"Meshing with tetrahedra","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTetrahedronModule, FinEtools.VoxelBoxModule, FinEtools.VoxelTetMeshingModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Meshing-with-hexahedra","page":"Functions","title":"Meshing with hexahedra","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshHexahedronModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20block","text":"H20block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nCreate mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20blockx","text":"H20blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27block","text":"H27block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nCreate mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27blockx","text":"H27blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8block","text":"H8block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nMake  a mesh  of a 3D block consisting of  eight node hexahedra.\n\nLength, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8blockx","text":"H8blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8cylindern-Tuple{Float64,Float64,Any,Any}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8cylindern","text":"H8cylindern(Radius::FFlt, Length::FFlt, nperradius, nL)\n\nH8 mesh of a solid  cylinder with given number of edges per radius (nperradius) and per length (nL).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8elliphole-Tuple{Float64,Float64,Float64,Float64,Float64,Int64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8elliphole","text":"H8elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt, T::FFlt,\n    nL::FInt, nH::FInt, nW::FInt, nT::FInt)\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radii of the ellipse, L,H = dimensions of the plate, T = thickness of the plate nL,nH= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole nW = number of edges along the remaining straight edge (from the hole   in the radial direction),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{F}, Tuple{FENodeSet,FESetQ4,Int64,F}} where F<:Function","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8extrudeQ4","text":"H8extrudeQ4(fens::FENodeSet,  fes::FESetQ4, nLayers::FInt, extrusionh::Function)\n\nExtrude a mesh of quadrilaterals into a mesh of hexahedra (H8).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8hexahedron-Tuple{Array{Float64,2},Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8hexahedron","text":"H8hexahedron(xyz::FFltMat, nL::FInt, nW::FInt, nH::FInt; blockfun=nothing)\n\nMesh of a general hexahedron given by the location of the vertices.\n\nxyz = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). nL,  nW,  nH = number of elements in each direction blockfun = Optional argument: function of the block-generating mesh function      (having the signature of the function H8block()).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8layeredplatex-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8layeredplatex","text":"H8layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec)\n\nH8 mesh for a layered block (composite plate) with specified in plane coordinates.\n\nxs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer\n\nThe finite elements of each layer are labeled with the layer number, starting from 1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8refine","text":"H8refine(fens::FENodeSet,  fes::FESetH8)\n\nRefine a mesh of H8 hexahedrals by octasection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8sphere-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8sphere","text":"H8sphere(radius::FFlt, nrefine::FInt)\n\nCreate a mesh of 1/8 of the sphere of \"radius\". The  mesh will consist of\nfour hexahedral elements if \"nrefine==0\",  or more if \"nrefine>0\".\n\"nrefine\" is the number of bisections applied  to refine the mesh.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8spheren-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8spheren","text":"H8spheren(radius::FFlt, nperradius::FInt)\n\nCreate a solid mesh of 1/8 of sphere.\n\nCreate a solid mesh of 1/8 of the sphere of \"radius\",  with nperradius elements per radius.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH20","text":"H8toH20(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H20.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH27","text":"H8toH27(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H27.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{DataT}, Tuple{Array{DataT,3},Array{Float64,1},Array{DataT,1}}} where DataT<:Number","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8voximg","text":"H8voximg(img::Array{DataT, 3}, voxdims::FFltVec,\n    voxval::Array{DataT, 1}) where {DataT<:Number}\n\nGenerate a hexahedral mesh  from three-dimensional image.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet,FESetT4}","page":"Functions","title":"FinEtools.MeshHexahedronModule.T4toH8","text":"T4toH8(fens::FENodeSet, fes::FESetT4)\n\nConvert a tetrahedral four-node mesh into eight-node hexahedra.\n\nEach vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-selection","page":"Functions","title":"Mesh selection","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"See above as \"Selecting nodes and elements\".","category":"page"},{"location":"man/functions.html#Mesh-modification","page":"Functions","title":"Mesh modification","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshModificationModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet,BitArray{1}}","page":"Functions","title":"FinEtools.MeshModificationModule.compactnodes","text":"compactnodes(fens::FENodeSet, connected::Vector{Bool})\n\nCompact the finite element node set by deleting unconnected nodes.\n\nfens = array of finite element nodes connected = The array element connected[j] is either 0 (when j is an   unconnected node), or a positive number (when node j is connected to   other nodes by at least one finite element)\n\nOutput\n\nfens = new set of finite element nodes new_numbering= array which tells where in the new fens array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      new_numbering[5] is 3.\n\nExamples\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactnodes(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.fusenodes-Tuple{FENodeSet,FENodeSet,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.fusenodes","text":"fusenodes(fens1::FENodeSet, fens2::FENodeSet, tolerance:: FFlt)\n\nFuse together nodes from two node sets.\n\nFuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, fens1 and fens2,  are fused together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the new  indexes of the nodes in the set fens1 are returned.\n\nThe set fens2 will be included unchanged, in the same order, in the node set fens. The indexes of the node set fens1 will have changed.\n\nExample\n\nAfter the call to this function we have k=new_indexes_of_fens1_nodes[j] is the node in the node set fens which used to be node j in node set fens1. The finite element set connectivity that used to refer to fens1 needs to be updated to refer to the same nodes in  the set fens as      updateconn!(fes, new_indexes_of_fens1_nodes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.interior2boundary-Tuple{Array{Int64,2},Array{Int64,2}}","page":"Functions","title":"FinEtools.MeshModificationModule.interior2boundary","text":"interior2boundary(interiorconn::Array{Int, 2}, extractb::Array{Int, 2})\n\nExtract the boundary connectivity from the connectivity of the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{FENodeSet,T1,FENodeSet,T2,Float64}} where T2<:AbstractFESet where T1<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.mergemeshes","text":"mergemeshes(fens1::FENodeSet, fes1::T1,\n  fens2::FENodeSet, fes2::T2, tolerance::FFlt) where {T1<:AbstractFESet,T2<:AbstractFESet}\n\nMerge together two meshes.\n\nMerge two meshes together by gluing together nodes within tolerance. The two meshes, fens1, fes1, and fens2, fes2, are glued together by merging the nodes that fall within a box of size tolerance. If tolerance is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.\n\nThe merged node set, fens, and the two finite element sets with renumbered  connectivities are returned.\n\nImportant notes: On entry into this function the connectivity of fes1 point into fens1 and the connectivity of fes2 point into fens2. After this function returns the connectivity of both fes1 and fes2 point into fens. The order of the nodes of the node set fens1 in the resulting set fens will have changed, whereas the order of the nodes of the node set fens2 is are guaranteed to be the same. Therefore, the connectivity of fes2 will in fact remain the same.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenmeshes-Tuple{Array{Tuple{FENodeSet,AbstractFESet},N} where N,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenmeshes","text":"mergenmeshes(meshes::Array{Tuple{FENodeSet, FESet}}, tolerance::FFlt)\n\nMerge several meshes together.\n\nThe meshes are glued together by merging the nodes that fall within a box of size tolerance. If tolerance is set to zero, no merging of nodes is performed; the nodes from the meshes are simply concatenated together.\n\nOutput\n\nThe merged node set, fens, and an array of finite element sets with renumbered  connectivities are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt, candidates::FIntVec)\n\nMerge together  nodes of a single node set.\n\nSimilar to mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt), but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt)\n\nMerge together  nodes of a single node set.\n\nMerge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the finite element set, fes, with renumbered  connectivities are returned.\n\nWarning: This tends to be an expensive operation!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshboundary-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshboundary","text":"meshboundary(fes::T) where {T<:AbstractFESet}\n\nExtract the boundary finite elements from a mesh.\n\nExtract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshsmoothing","text":"meshsmoothing(fens::FENodeSet, fes::T; options...) where {T<:AbstractFESet}\n\nGeneral smoothing of meshes.\n\nKeyword options\n\nmethod = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\nReturn\n\nThe modified  node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{FENodeSet,T,Array{Float64,1},Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.mirrormesh","text":"mirrormesh(fens::FENodeSet, fes::T, Normal::FFltVec,\n  Point::FFltVec; kwargs...) where {T<:AbstractFESet}\n\nMirror a mesh in a plane given by its normal and one point.\n\nKeyword arguments\n\nrenumb = node renumbering function for the mirrored element\n\nWarning: The code to relies on the numbering of the finite elements: to reverse the orientation of the mirrored finite elements, the connectivity is listed in reverse order.   If the mirrored finite elements do not follow this rule (for instance hexahedra or quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.\n\nFor instance: H8 elements require the renumbering function to be supplied as\n\nrenumb = (c) -> c[[1, 4, 3, 2, 5, 8, 7, 6]]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnincluded = Boolean array: is the node to be included in the partitioning or     not? npartitions = number of partitions, but note that the actual number of     partitions is going to be a power of two.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-Dollar(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend\nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" DollarFile`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning-2","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnpartitions = number of partitions, but note that the actual number of partitions will be a power of two.\n\nIn this variant all the nodes are to be included in the partitioning.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-Dollar(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend\nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" DollarFile`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet,Any,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})\n\nCompute the inertial-cut partitioning of the nodes.\n\nfesarr = array of finite element sets that represent regions npartitions = array of the number of partitions in each region. However note that the actual number of partitions will be a power of two.\n\nThe partitioning itself is carried out by nodepartitioning() with a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to the elements of that region, but not to elements that belong to any of the previous regions, 1…I-1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.renumberconn!-Tuple{AbstractFESet,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.renumberconn!","text":"renumberconn!(fes::AbstractFESet, new_numbering::FIntVec)\n\nRenumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.\n\nfes =finite element set new_numbering = new serial numbers for the nodes.  The connectivity           should be changed as conn[j] –> new_numbering[conn[j]]\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactnodes(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vertexneighbors-Tuple{Array{Int64,2},Int64}","page":"Functions","title":"FinEtools.MeshModificationModule.vertexneighbors","text":"vertexneighbors(conn::FIntMat, nvertices::FInt)\n\nFind the node neighbors in the mesh.\n\nReturn an array of integer vectors, element I holds an array of numbers of nodes which are connected to node I (including node I).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vsmoothing-Tuple{Array{Float64,2},Array{Int64,2}}","page":"Functions","title":"FinEtools.MeshModificationModule.vsmoothing","text":"vsmoothing(v::FFltMat, t::FIntMat; options...)\n\nInternal routine for mesh smoothing.\n\nKeyword options: method = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-utilities","page":"Functions","title":"Meshing utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshUtilModule.addhyperface!-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.MeshUtilModule.addhyperface!","text":"addhyperface!(container,hyperface,newn)\n\nAdd a hyper face to the container.\n\nThe new node is stored in hyper face data in the container and can be retrieved later.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.findhyperface!-Tuple{Any,Any}","page":"Functions","title":"FinEtools.MeshUtilModule.findhyperface!","text":"findhyperface!(container,hyperface)\n\nFind a hyper face in the container.\n\nIf the container holds the indicated hyper face, it is returned together with the stored new node number.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T,T,Int64}, Tuple{T,T,Int64,Any}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.gradedspace","text":"gradedspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate quadratic space.\n\nGenerate a quadratic sequence of N numbers between start and stop. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.\n\nExample\n\njulia> gradedspace(2.0, 3.0, 5)\n5-element Array{Float64,1}:\n 2.0\n 2.0625\n 2.25\n 2.5625\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T,T,Int64}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.linearspace","text":"linearspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate linear space.\n\nGenerate a linear sequence of N numbers between  start and stop (i. e. sequence  of number with uniform intervals inbetween).\n\nExample\n\njulia> linearspace(2.0, 3.0, 5)\n2.0:0.25:3.0\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.logspace-Union{Tuple{T}, Tuple{T,T,Int64}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.logspace","text":"logspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate logarithmic space.\n\nGenerate a logarithmic sequence of N numbers between  start and stop (i. e. sequence  of number with uniform intervals inbetween in the log space).\n\nExample\n\njulia> logspace(2.0, 3.0, 5)                                                             \n5-element Array{Float64,1}:                                                              \n  100.0\n  177.82794100389228   \n  316.2277660168379      \n  562.341325190349  \n 1000.0    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.makecontainer-Tuple{}","page":"Functions","title":"FinEtools.MeshUtilModule.makecontainer","text":"makecontainer()\n\nMake hyper face container.\n\nThis is a dictionary of hyper faces, indexed with an anchor node. The anchor node is the smallest node number within the connectivity of the hyper face.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-import","page":"Functions","title":"Mesh import","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshImportModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_ABAQUS","text":"import_ABAQUS(filename)\n\nImport Abaqus mesh (.inp file).\n\nLimitations:\n\nOnly the *NODE and *ELEMENT  sections are read\nOnly 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 4-node quadrilaterals, 3-node triangles are handled.\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\"nsets\" = dictionary of \"node sets\", the keys are the names of the sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_H5MESH-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_H5MESH","text":"import_H5MESH(filename)\n\nImport mesh in the H5MESH format (.h5mesh file).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_MESH-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_MESH","text":"import_MESH(filename)\n\nImport mesh in the MESH format (.mesh, .xyz, .conn triplet of files).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_NASTRAN","text":"import_NASTRAN(filename)\n\nImport tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).\n\nLimitations:\n\nonly the GRID and CTETRA  sections are read.\nOnly 4-node and 10-node tetrahedra  are handled.\nThe file should be free-form (data separated by commas). \n\nSome fixed-format files can also be processed (large-field, but not small-field).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" (finite element nodes), \n\"fesets\" (array of finite element sets).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-export","page":"Functions","title":"Mesh export","text":"","category":"section"},{"location":"man/functions.html#VTK","page":"Functions","title":"VTK","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.VTK]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String,Any,Any,Any}","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportmesh","text":"vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;\n    vectors=nothing, scalars=nothing)\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nopts = keyword argument list, where scalars = array of tuples, (name, data) vectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String,FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportmesh","text":"vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T<:AbstractFESet}\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nopts = keyword argument list, where scalars = array of tuples, (name, data) vectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String,Any,Any}","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportvectors","text":"vtkexportvectors(theFile::String, Points, vectors)\n\nExport vector data to a VTK 1.0 file.\n\nPoints = array of collection of coordinates (tuples or vectors), \nvectors = array of tuples, (name, data), where name is a string, and data is array of collection of coordinates (tuples or vectors).\n\nExample\n\nPoints = [(1.0, 3.0), (0.0, -1.0)]\nvectors = [(\"v\", [(-1.0, -2.0), (1.0, 1.0)])]\nvtkexportvectors(\"theFile.VTK\", Points, vectors)\n\nwill produce file with\n\n# vtk DataFile Version 1.0\nFinEtools Export\nASCII\n\nDATASET UNSTRUCTURED_GRID\nPOINTS 2 double\n1.0 3.0 0.0\n0.0 -1.0 0.0\n\n\nPOINT_DATA 2\nVECTORS v double\n-1.0 -2.0 0.0\n1.0 1.0 0.0\n\nnote: Note\n\n\nThe filter \"Glyph\" must be used Paraview. Also in the drop-down  menu \"Glyph mode\" select \"all points\".\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Abaqus","page":"Functions","title":"Abaqus","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.Abaqus]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{AbaqusExporter}","page":"Functions","title":"Base.close","text":"close(self::AbaqusExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ASSEMBLY","text":"ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer,Float64}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,  fixed_value::FFlt)\n\nWrite out the *BOUNDARY option.\n\nNSET = name of a node set, is_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, fixed_value=array of displacements to which the corresponding displacement components is fixed\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)\n\nWrite out the *BOUNDARY option to fix displacements at zero for a node set.\n\nInvoke at Level: Model,  Step\n\nNSET= node set, dof=Degree of freedom, 1, 2, 3\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  value::F) where {F}\n\nWrite out the *BOUNDARY option to fix displacements at nonzero value for a node set.\n\nNSET= node set, dof=Degree of freedom, 1, 2, 3\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, meshornset, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}\n\nWrite out the *BOUNDARY option.\n\nmeshornset = name of a mesh or a node set, is_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, as many columns as there are degrees of freedom per node, fixed_value=array of displacements to which the corresponding displacement components is fixed, as many columns as there are degrees of freedom per node\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, mesh, nodes, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}\n\nWrite out the *BOUNDARY option. \n\nThe boundary condition is applied to the nodes specified in  the array nodes, in the mesh (or node set) meshornset.\n\nmeshornset = mesh or node set (default is empty) nodes = array of node numbers, the node numbers are attached to the mesh label, is_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, fixed_value=array of displacements to which the corresponding displacement components is fixed\n\nExample\n\nBOUNDARY(AE, \"ASSEM1.INSTNC1\", 1:4, fill(true, 4, 1), reshape([uy(fens.xyz[i, :]...) for i in 1:4], 4, 1))\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.CLOAD","text":"CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nNSET=Node set dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,Integer,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.CLOAD","text":"CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nnodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.COMMENT","text":"COMMENT(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the ** comment option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter,Any}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.DENSITY","text":"DENSITY(self::AbaqusExporter, rho)\n\nWrite out the *DENSITY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractArray{F,1}}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.DLOAD","text":"DLOAD(self::AbaqusExporter, ELSET::AbstractString,\n  traction::AbstractVector{F}) where {F}\n\nWrite out the *DLOAD option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F,F,F,F,F,F,F,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,\n  G12::F, G13::F, G23::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ENGINEERING CONSTANTS option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ISOTROPIC option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractString,Integer,AbstractArray{T,2}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELEMENT","text":"ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,\n  start::Integer, conn::AbstractArray{T, 2}) where {T<:Integer}\n\nWrite out the *ELEMENT option.\n\nTYPE= element type code, ELSET= element set to which the elements belong, start= start the element numbering at this integer, conn= connectivity array for the elements, one row per element\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELSET_ELSET","text":"ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T<:Integer}\n\nWrite out the *ELSET option.\n\nELSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.EL_PRINT","text":"EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)\n\nWrite out the *EL PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY","text":"END_ASSEMBLY(self::AbaqusExporter)\n\nWrite out the *END ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_INSTANCE","text":"END_INSTANCE(self::AbaqusExporter)\n\nWrite out the *END INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_PART","text":"END_PART(self::AbaqusExporter)\n\nWrite out the *END PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_STEP","text":"END_STEP(self::AbaqusExporter)\n\nWrite out the *END STEP option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT","text":"ENERGY_PRINT(self::AbaqusExporter)\n\nWrite out the *ENERGY PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.EXPANSION","text":"EXPANSION(self::AbaqusExporter, CTE::F) where {F}\n\nWrite out the *EXPANSION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.HEADING","text":"HEADING(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the *HEADING option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.INSTANCE","text":"INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)\n\nWrite out the *INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.MATERIAL","text":"MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)\n\nWrite out the *MATERIAL option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractArray{T,2}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NODE","text":"NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}\n\nWrite out the *NODE option.\n\nxyz=array of node coordinates\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NODE_PRINT","text":"NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)\n\nWrite out the *NODE PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NSET_NSET","text":"NSET_NSET(self::AbaqusExporter, NSET::AbstractString,\n  n::AbstractVector{T}) where {T<:Integer}\n\nWrite out the *NSET option.\n\nNSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1},AbstractArray{T,1}}} where T<:Real","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ORIENTATION","text":"ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,\n  a::AbstractArray{T,1}, b::AbstractArray{T,1})\n\nWrite out the *ORIENTATION option.\n\nInvoke at level: Part,  Part instance,  Assembly\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.PART","text":"PART(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS","text":"SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,\n  OPTIONAL::AbstractString)\n\nWrite out the *SECTION CONTROLS option.\n\nOPTIONAL = string, for instance                      HOURGLASS=ENHANCED\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString,\n  CONTROLS::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY","text":"STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)\n\nWrite out the *STEP,FREQUENCY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE","text":"STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)\n\nWrite out the *STEP,PERTURBATION option for linear buckling analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC","text":"STEP_PERTURBATION_STATIC(self::AbaqusExporter)\n\nWrite out the *STEP,PERTURBATION option for linear static analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION","text":"SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)\n\nWrite out the *SURFACE SECTION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter,AbstractString,AbstractArray{I,1},AbstractArray{F,1}}} where F where I","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.TEMPERATURE","text":"TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},\n  tlist::AbstractArray{F, 1}) where {I, F}\n\nWrite out the *TEMPERATURE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#NASTRAN","page":"Functions","title":"NASTRAN","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.NASTRAN]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{NASTRANExporter}","page":"Functions","title":"Base.close","text":"close(self::NASTRANExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK","text":"BEGIN_BULK(self::NASTRANExporter)\n\nTerminate the Case Control section by starting the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.CEND","text":"CEND(self::NASTRANExporter)\n\nTerminate the Executive Control section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.ENDDATA","text":"ENDDATA(self::NASTRANExporter)\n\nTerminate the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter,Int64,Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.GRID","text":"GRID(self::NASTRANExporter, n::Int, xyz::Vector{FFlt})\n\nWrite a grid-point statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.MAT1","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.MAT1","text":"MAT1(self::NASTRANExporter, mid::Int, E::FFlt, nu::FFlt, rho::FFlt = 0.0, A::FFlt = 0.0, TREF::FFlt = 0.0)\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.MAT1-Tuple{NASTRANExporter,Int64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.MAT1","text":"MAT1(self::NASTRANExporter, mid::Int, E::FFlt, G::FFlt, nu::FFlt, rho::FFlt, A::FFlt, TREF::FFlt, GE::FFlt)\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter,Int64,Int64}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.PSOLID","text":"PSOLID(self::NASTRANExporter, pid::Int, mid::Int)\n\nWrite solid-property statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#STL","page":"Functions","title":"STL","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.STL]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{STLExporter}","page":"Functions","title":"Base.close","text":"close(self::STLExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#CSV","page":"Functions","title":"CSV","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.CSV]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}","page":"Functions","title":"FinEtools.MeshExportModule.CSV.savecsv","text":"savecsv(name::String; kwargs...)\n\nSave arrays as a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#H2Lib","page":"Functions","title":"H2Lib","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.H2Lib]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Vector-cache-utilities","page":"Functions","title":"Vector-cache utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.VectorCacheModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.VectorCacheModule.settime!-Tuple{VectorCache,Float64}","page":"Functions","title":"FinEtools.VectorCacheModule.settime!","text":"settime!(self::VectorCache, time::FFlt)\n\nSet the current time for the vector cache.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VectorCacheModule.updateretrieve!-Tuple{VectorCache,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.VectorCacheModule.updateretrieve!","text":"updateretrieve!(self::VectorCache, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the cache and retrieve the vector.\n\nAfter the return from this function the updated vector can be read from the cache as self.cache (also returned). If the vector depends on time, the vector cache time first needs to be set as\n\nsettime!(c, t)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Surface-normal-utilities","page":"Functions","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.SurfaceNormalModule.updatenormal!-Tuple{SurfaceNormal,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.SurfaceNormalModule.updatenormal!","text":"updatenormal!(self::SurfaceNormal, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the surface normal vector.\n\nReturns a vector (stored in the cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Force-intensity","page":"Functions","title":"Force intensity","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.ForceIntensityModule.updateforce!-Tuple{ForceIntensity,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.ForceIntensityModule.updateforce!","text":"updateforce!(self::ForceIntensity, ndofn::FInt, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the force intensity vector.\n\nReturns a vector (stored in the cache self.cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VectorCacheModule.settime!-Tuple{ForceIntensity,Float64}","page":"Functions","title":"FinEtools.VectorCacheModule.settime!","text":"settime!(self::ForceIntensity, time::FFlt)\n\nSet the current time for the force intensity.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Rotation-utilities","page":"Functions","title":"Rotation utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.RotationUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{T}, Tuple{Array{Float64,2},T}} where T","page":"Functions","title":"FinEtools.RotationUtilModule.rotmat3!","text":"rotmat3!(Rmout::FFltMat, a::T) where {T}\n\nCompute a 3D rotation matrix in-place.\n\na = array, vector, or tuple with three floating-point numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.rotmat3-Tuple{T} where T","page":"Functions","title":"FinEtools.RotationUtilModule.rotmat3","text":"rotmat3(a::T) where {T}\n\nPrepare a rotation matrix from a rotation vector\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.skewmat!-Tuple{Any,Any}","page":"Functions","title":"FinEtools.RotationUtilModule.skewmat!","text":"skewmat!(S, theta)\n\nCompute skew-symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FEM-machines","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Base","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Tuple{AbstractFEMM,NodalField{Float64}}","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::AbstractFEMM,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nThere may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.\n\nGeometry field is normally passed into any routine that evaluates some forms (integrals) over the mesh.  Whenever the geometry passed into a routine is not consistent with the one for which associategeometry!() was called before, associategeometry!() needs to be called with the new geometry field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM,Int64}} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.connectionmatrix","text":"connectionmatrix(self::FEMM, nnodes::FInt) where {FEMM<:AbstractFEMM}\n\nCompute the connection matrix.\n\nThe matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.distribloads-Union{Tuple{A}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T},ForceIntensity,Int64}} where A<:AbstractSysvecAssembler where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.distribloads","text":"distribloads(self::FEMM, assembler::A, geom::NodalField{FFlt}, P::NodalField{T},\n  fi::ForceIntensity,\n  m::FInt) where {FEMM<:AbstractFEMM, T<:Number, A<:AbstractSysvecAssembler}\n\nCompute the distributed-load vector.\n\nArguments\n\nfi=force intensity object\nm= manifold dimension, 1= curve, 2= surface, 3= volume. For body loads m\n\nis set to 3, for tractions on the surface it is set to 2, and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.elemfieldfromintegpoints","text":"elemfieldfromintegpoints(self::FEMM,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;\n  context...) where {FEMM<:AbstractFEMM, T<:Number}\n\nConstruct elemental field from integration points.\n\nArguments\n\ngeom     - reference geometry field u        - displacement field dT       - temperature difference field quantity   - this is what you would assign to the 'quantity' argument            of the material update!() method. component- component of the 'quantity' array: see the material update()            method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.field_elem_to_nodal!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},EFL,NFL}} where NFL<:NodalField{T} where EFL<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.field_elem_to_nodal!","text":"field_elem_to_nodal!(self::AbstractFEMM, geom::NodalField{FFlt}, ef::EFL, nf::NFL; kind = :weighted_average) where {T<:Number, EFL<:ElementalField{T}, NFL<:NodalField{T}}\n\nMake a nodal field  from an elemental field over the discrete manifold.\n\nef = ELEMENTAL field to be supply the values nf = NODAL field to be supply the values kind = default is :weighted_average; other options: :max\n\nReturns nf.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.field_nodal_to_elem!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},NFL,EFL}} where NFL<:NodalField{T} where EFL<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.field_nodal_to_elem!","text":"field_nodal_to_elem!(self::AbstractFEMM, geom::NodalField{FFlt}, nf::NFL, ef::EFL; kind = :weighted_average) where {T<:Number, EFL<:ElementalField{T}, NFL<:NodalField{T}}\n\nMake an elemental field  from a nodal field over the discrete manifold.\n\nnf = NODAL field to be supply the values ef = ELEMENTAL field to be supply the values kind = default is :weighted_average; other options: :max\n\nReturns ef.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.fieldfromintegpoints","text":"fieldfromintegpoints(self::FEMM,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;\n  context...) where {FEMM<:AbstractFEMM, T<:Number}\n\nConstruct nodal field from integration points.\n\nArguments\n\ngeom     - reference geometry field\nu        - displacement field\ndT       - temperature difference field\nquantity   - this is what you would assign to the 'quantity' argument          of the material update!() method.\ncomponent- component of the 'quantity' array: see the material update()          method.\n\nKeyword arguments\n\nnodevalmethod = :invdistance (the default) or :averaging;\nreportat = at which point should the  element quantities be reported?   This argument is interpreted inside the inspectintegpoints() method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T}}} where T where A<:AbstractSysmatAssembler where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.innerproduct","text":"innerproduct(self::FEMMHeatDiff,\n  assembler::A, geom::NodalField{FFlt},\n  temp::NodalField{FFlt}) where {A<:AbstractSysmatAssembler}\n\nCompute the inner-product (Gram) matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMM, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {FEMM<:AbstractFEMM, T<:Number, F<:Function}\n\nInspect integration points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F<:Function where R where FL<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(self::AbstractFEMM,\n    geom::NodalField{FFlt},  afield::FL, fh::F, initial::R;\n    m::FInt=-1) where {T<:Number, FL<:ElementalField{T}, R, F<:Function}\n\nIntegrate a elemental-field function over the discrete manifold.\n\nafield = ELEMENTAL field to be supply the values fh = function taking position and the field value as arguments, returning value of type R.\n\nReturns value of type R, which is initialized by initial.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F<:Function where R where FL<:NodalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(self::AbstractFEMM,\n    geom::NodalField{FFlt},  afield::FL, fh::F,  initial::R;\n    m::FInt=-1) where {T<:Number, FL<:NodalField{T}, R, F<:Function}\n\nIntegrate a nodal-field function over the discrete manifold.\n\nafield = NODAL field to be supply the values fh = function taking position and the field value as arguments, returning value of type R.\n\nReturns value of type R, which is initialized by initial.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{F}, Tuple{AbstractFEMM,NodalField{Float64},F}, Tuple{AbstractFEMM,NodalField{Float64},F,Int64}} where F<:Function","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefunction","text":"integratefunction(self::AbstractFEMM,\n    geom::NodalField{FFlt}, fh::F, m::FInt = -1) where {F<:Function}\n\nIntegrate a function over the discrete manifold.\n\nIntegrate some scalar function over the geometric cells. The function takes a single argument, the position vector.\n\nWhen the scalar function returns just +1 (such as (x) ->  1.0), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.\n\nExample:\n\nCompute the volume of the mesh and then its center of gravity:\n\nV = integratefunction(femm, geom, (x) ->  1.0)\nSx = integratefunction(femm, geom, (x) ->  x[1])\nSy = integratefunction(femm, geom, (x) ->  x[2])\nSz = integratefunction(femm, geom, (x) ->  x[3])\nCG = vec([Sx Sy Sz]/V)\n\nCompute a moment of inertia of the mesh relative to the origin:\n\nIxx = integratefunction(femm, geom, (x) ->  x[2]^2 + x[3]^2)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet, fc::F,\n    fensc::FENodeSet, fesc::AbstractFESet, geometricaltolerance::FFlt;\n    parametrictolerance::FFlt = 0.01 )  where {T<:Number,\n    F<:ElementalField{T}}\n\nTransfer an elemental field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ntolerance = tolerance in physical space for searches of the adjacent nodes\n\nOutput\n\nElemental field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F<:NodalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet,\n    fc::F, fensc::FENodeSet, fesc::AbstractFESet, tolerance::FFlt\n    )  where {T<:Number, F<:NodalField{T}}\n\nTransfer a nodal field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ngeometricaltolerance = tolerance in physical space for searches of the adjacent nodes\nparametrictolerance = tolerance in parametric space for for check whether node is inside an element\n\nOutput\n\nNodal field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Base-2","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.bisect-NTuple{5,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.bisect","text":"bisect(fun, xl, xu, tolx, tolf)\n\nImplementation of the bisection method.\n\nTolerance both on x and on f(x) is used.\n\nfun = function,\nxl= lower value of the bracket,\nxu= upper Value of the bracket,\ntolx= tolerance on the location of the root,\ntolf= tolerance on the function value\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.bisect-NTuple{7,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.bisect","text":"bisect(fun, xl, xu, fl, fu, tolx, tolf)\n\nImplementation of the bisection method.\n\nTolerance both on x and on f(x) is used.\n\nfun = function,\nxl,xu= lower and upper value of the bracket,\nfl,fu= function value at the lower and upper limit of the bracket.\n\nThe true values must have opposite signs (that is they must constitute a bracket). Otherwise  this algorithm will fail.\n\ntolx= tolerance on the location of the root,\ntolf= tolerance on the function value\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{T,Array{Float64,1},Array{Float64,1},Int64}} where T","page":"Functions","title":"FinEtools.AlgoBaseModule.conjugategradient","text":"conjugategradient(A, b, x0, maxiter)\n\nCompute one or more iterations of the conjugate gradient process.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.evalconvergencestudy","text":"evalconvergencestudy(modeldatasequence)\n\nEvaluate a convergence study from a model-data sequence.  \n\nmodeldatasequence = array of modeldata dictionaries. At least two must be included.\n\nRefer to methods fieldnorm and fielddiffnorm for details  on the required keys in the dictionaries.\n\nOutput\n\nelementsizes = element size array, \nerrornorms = norms of the error, \nconvergencerate = rate of convergence\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fielddiffnorm","text":"fielddiffnorm(modeldatacoarse, modeldatafine)\n\nCompute norm of the difference of the fields.  \n\nArguments\n\nmodeldatacoarse, modeldatafine = data dictionaries.\n\nFor both the \"coarse\"- and \"fine\"-mesh modeldata the data dictionaries need to contain the mandatory keys:\n\n\"fens\" = finite element node set\n\"regions\" = array of regions\n\"targetfields\" = array of fields, one for each region\n\"geom\" = geometry field\n\"elementsize\" = representative element size,\n\"geometricaltolerance\" = geometrical tolerance (used in field transfer; refer to the documentation of transferfield!)\n\"parametrictolerance\" = parametric tolerance (used in field transfer; refer to the documentation of transferfield!)\n\nOutput\n\nNorm of the field as floating-point scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fieldnorm","text":"fieldnorm(modeldata)\n\nCompute norm of the target field.  \n\nArgument\n\nmodeldata = data dictionary, mandatory keys:\nfens = finite element node set\nregions = array of regions\ntargetfields = array of fields, one for each region\ngeom = geometry field\nelementsize = representative element size,\n\nOutput\n\nNorm of the field as floating-point scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.penaltyebc!","text":"penaltyebc!(K, F, dofnums, prescribedvalues, penfact)\n\nApply penalty essential boundary conditions.\n\nArguments\n\nK = stiffness matrix\nF = global load vector \ndofnums, prescribedvalues = arrays computed by prescribeddofs()\npenfact = penalty multiplier, in relative terms: how many times the maximum absolute value of the diagonal elements should the penalty term be?\n\nOutput\n\nUpdated matrix K and vector F.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qcovariance-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qcovariance","text":"qcovariance(ps, xs, ys; ws = nothing)\n\nCompute the covariance for two 'functions' given by the arrays xs and ys  at the values of the parameter ps. ws is the optional weights vector;   if it is not supplied, uniformly distributed default weights are assumed.  \n\nNotes: \n\n– The mean is subtracted from both functions.  – This function is not particularly efficient: it computes the mean of both   functions and it allocates arrays instead of overwriting the contents of the   arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qtrap-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qtrap","text":"qtrap(ps, xs)\n\nCompute the area under the curve given by a set of parameters along  an interval and the values of the 'function' at those parameter values.   The parameter values need not be uniformly distributed.\n\nTrapezoidal rule is used to evaluate the integral. The 'function' is  assumed to vary linearly inbetween the given points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qvariance-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qvariance","text":"qvariance(ps, xs; ws = nothing)\n\nCompute the variance of a function given by the array xs at  the values of the parameter ps. ws is the optional weights vector   with unit default weights.    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{Tn,N} where N where Tn)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapol","text":"richextrapol(solns::T, params::T; lower_conv_rate = 0.001, upper_conv_rate = 10.0) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArguments\n\nsolns =  array of three solution values\nparams = array of values of three parameters for which the solns have been obtained\n\nThis function is applicable to any sequence of the mesh sizes (monotonically increasing, or decreasing).\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nresidual = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{Tn,N} where N where Tn)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapoluniform","text":"richextrapoluniform(solns::T, params::T) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArgument\n\nsolns =  array of solution values\nparams = array of values of parameters for which the solns have been obtained. This function is applicable only to fixed (uniform) ratio between the mesh sizes, params[1]/params[2) = params[2)/params[3).\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nresidual = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-model-abstractions","page":"Functions","title":"Material model abstractions","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MatModule.massdensity-Tuple{AbstractMat}","page":"Functions","title":"FinEtools.MatModule.massdensity","text":"massdensity(self::AbstractMat)\n\nReturn mass density.\n\n\n\n\n\n","category":"method"}]
}
