var documenterSearchIndex = {"docs":
[{"location":"index.html#FinEtools-(Finite-Element-tools)-Documentation-1","page":"Home","title":"FinEtools (Finite Element tools) Documentation","text":"","category":"section"},{"location":"index.html#Conceptual-guide-1","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 1","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#Guide-1","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/guide.html#Modules-1","page":"Guide","title":"Modules","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FinEtools package consists of many modules which fall into several  categories. The top-level module, FinEtools, includes all other modules and exports functions to constitute the public interface. The user is free to generate their own public interface, however. More details are provided Make up your own public interface.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Top-level:    FinEtools is the  top-level module.  For interactive use it is enough to do using FinEtools, however in some  cases functions from modules need to be  brought into the scope individually (most importantly, the algorithm modules). This is the ONLY  module that EXPORTS  functions, none of the other modules exports a single function. The entire  public (i. e. exported) interface of the FinEtools package is specified  in the file FinEtools.jl (i. e. in the FinEtools module). The user is free to specify his or her own set of exported functions from the FinEtools package to create an ad hoc public interface.\nUtilities:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"FTypesModule (types), PhysicalUnitModule (definitions of  numbers with physical units), AssemblyModule (assembly of elementwise matrices and vectors),   CSysModule (coordinate system module),    MatrixUtilityModule (utilities for operations on elementwise matrices), BoxModule  (support for working with bounding boxes),  ForceIntensityModule (force-intensity module),        RotationUtilModule (support for spatial rotations).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Mesh  entities:  FENodeSetModule, FESetModule (node set and finite element set  types).  \nMesh Generation:   MeshLineModule,  MeshQuadrilateralModule,   MeshTriangleModule,   MeshTetrahedronModule,             TetRemeshingModule,  VoxelTetMeshingModule,     MeshHexahedronModule,       VoxelBoxModule.  \nMesh manipulation:  MeshSelectionModule (searching of nodes  and elements),  MeshModificationModule (mesh boundary, merging  of meshes and nodes, smoothing, partitioning),  MeshUtilModule (utilities), FENodeToFEMapModule (search structure from nodes to elements).\nMesh import/export:  MeshImportModule,  MeshExportModule.\nFields: ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"FieldModule,    GeneralFieldModule, ElementalFieldModule,    NodalFieldModule (modules for representing quantities on the mesh).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Support for  integration over solids, surfaces, curves, and points: ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"IntegRuleModule,   IntegDomainModule.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"General algorithms: AlgoBaseModule (algorithms), FEMMBaseModule (FEM machine for general tasks).\nHeat conduction: AlgoHeatDiffModule (algorithms), FEMMHeatDiffModule, FEMMHeatDiffSurfModule  (FEM machines  to evaluate  the  matrix and vector quantities), MatHeatDiffModule  (heat diffusion material)\nAcoustics: AlgoAcoustModule (algorithms), FEMMAcoustModule, FEMMAcoustSurfModule (FEM machines to evaluate the matrix and vector quantities),  MatAcoustFluidModule (acoustic fluid material).\nLinear deformation:  AlgoDeforLinearModule (algorithms), DeforModelRedModule, ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"FEMMDeforLinearBaseModule,  FEMMDeforLinearModule, FEMMDeforLinearMSModule,  FEMMDeforWinklerModule (FEM machines to evaluate the matrix and vector quantities), MatDeforModule, MatDeforElastIsoModule, MatDeforElastOrthoModule (elastic material models).","category":"page"},{"location":"guide/guide.html#Arithmetic-types-1","page":"Guide","title":"Arithmetic types","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FinEtools package is fairly strict about typing arguments. The arithmetic types used throughout are FInt for integer data, FFlt for floating-point data, and Complex{FFlt} for applications that work with complex linear algebra quantities.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The module FTypesModule defines these types, and also defines abbreviations for vectors and matrices with entries of these types.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Some algorithms expect input in the form of the data dictionary, FDataDict, and also produce output in this form.","category":"page"},{"location":"guide/guide.html#Physical-units-1","page":"Guide","title":"Physical units","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The PhysicalUnitModule provides a simple function, phun, which can help with providing input numbers with the correct conversion between physical units. For instance, it is possible to specify the input data as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"E = 200*phun(\"GPa\");# Young's modulus\nnu = 0.3;# Poisson ratio\nrho = 8000*phun(\"KG*M^-3\");# mass density\nL = 10.0*phun(\"M\"); # side of the square plate\nt = 0.05*phun(\"M\"); # thickness of the square plate","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The usual sets of units are included, :US, :IMPERIAL, :CGS, :SIMM (millimeter-based SI units), and :SI (meter-based SI units). The resulting  values assigned to the variables are floating-point numbers, for instance","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"julia> E = 200*phun(\"GPa\")\n2.0e11","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Numbers output by the simulation can also be converted  to appropriate units for printing as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"julia> E/phun(\"MPa\")\n200000.0","category":"page"},{"location":"guide/guide.html#Mesh-entities-1","page":"Guide","title":"Mesh entities","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The mesh consists of one set of finite element nodes  and one or more sets of finite elements. ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"One of the  organizing principles of the  finite element collection  is that  finite elements can appear as representations of the interior  of the domain, but in a different model as parts of the boundary.  Thus  for instance  4-node  quadrilaterals  are finite elements that represent cross-sections of  axially symmetric models or surfaces  of membranes,  but they are also the boundaries of hexahedral  models.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"A mesh  is generated by one of the functions specialized to a particular finite element type. Thus there are  mesh generation functions for lines, triangles, quadrilaterals, tetrahedra, and hexahedra.","category":"page"},{"location":"guide/guide.html#Mesh-generation-1","page":"Guide","title":"Mesh generation","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"As an example,  the following code generates a hexahedral mesh of simple rectangular block.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The finite element node set and the finite element set  are returned. More complicated meshes can be constructed from such mesh parts. There are  functions for  merging  nodes  and even multiple meshes together.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The code snippet below  constructs the mesh of an  L-shaped  domain  from  the meshes of three rectangles.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"W = 100. # width of the leg\nL = 200. # length of the leg\nnL = 15 # number of elements along the length of the leg\nnW = 10 # number of elements along the width\ntolerance = W / nW / 1.0e5 # tolerance for merging nodes\nMeshes = Array{Tuple{FENodeSet,FESet},1}()\npush!(Meshes, Q4quadrilateral([0.0 0.0; W W], nW, nW))\npush!(Meshes, Q4quadrilateral([-L 0.0; 0.0 W], nL, nW))\npush!(Meshes, Q4quadrilateral([0.0 -L; W 0.0], nW, nL))\nfens, outputfes = mergenmeshes(Meshes, tolerance);\nfes = cat(outputfes[1], cat(outputfes[2], outputfes[3]))","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"As an example of the  merging  of nodes to create  the final mesh, consider the creation of  a closed hollow tube.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc) # generate a block\n# Shape into a cylinder\nR = zeros(3, 3)\nfor i = 1:count(fens)\n    x, y, z = fens.xyz[i,:];\n    rotmat3!(R, [0, z, 0])\n    Q = [cos(psi * pi / 180) sin(psi * pi / 180) 0;\n        -sin(psi * pi / 180) cos(psi * pi / 180) 0;\n        0 0 1]\n    fens.xyz[i,:] = reshape([x + Rmed - h / 2, y - l / 2, 0], 1, 3) * Q * R;\nend\n# Merge the nodes where the tube  closes up\ncandidates = selectnode(fens, box = boundingbox([Rmed - h -Inf 0.0; Rmed + h +Inf 0.0]), inflate = tolerance)\nfens, fes = mergenodes(fens, fes,  tolerance, candidates);","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The final mesh used for a simulation  consists of a single  node set and one or more finite element sets. The  finite elements may be  divided into separate sets  to  accommodate different material properties, different orientations of the material  coordinate systems, or different formulations  of the discrete model. The  assignment  of the finite elements to sets  may be based on geometrical proximity, topological connections, or some other characteristic. See the  \"mesh selection\" discussion for details.","category":"page"},{"location":"guide/guide.html#Structured-mesh-generation-1","page":"Guide","title":"Structured mesh generation","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The simplest possible meshes can be generated in the form of one-dimensional, two-dimensional, and three-dimensional blocks. The spacing of the nodes can be either uniform (for instance Q8block), or the spacing can be given with an arbitrary distribution (for instance Q4blockx). Meshes of tetrahedra can be generated in various orientations of the \"diagonals\".","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"More complex meshes can be generated for certain element types: for instance an annulus (Q4annulus), quarter of a plate with a hole (Q4elliphole), quarter of a sphere (H8spheren), layered plate (H8layeredplatex).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Hexahedral meshes can also be created by extrusion of  quadrilateral meshes (H8extrudeQ4).","category":"page"},{"location":"guide/guide.html#Shaping-1","page":"Guide","title":"Shaping","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Simple meshes  such as blocks can be deformed into geometrically complex shapes, for instance  by tapering  or oother relocation of the nodes. For instance, we can generate a block  and then bend it  into one quarter  of  an annulus as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nfor i=1:count(fens)\n    r=rin+fens.xyz[i,1]; a=fens.xyz[i,2];\n    fens.xyz[i,:]=[r*cos(a) r*sin(a)];\nend","category":"page"},{"location":"guide/guide.html#Merging-1","page":"Guide","title":"Merging","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Multiple mesh regions  can be generated and then merged together into a single mesh. Refer to the MeshModificationModule. Meshes can be also mirrored.","category":"page"},{"location":"guide/guide.html#Biomedical-image-mesh-generation-1","page":"Guide","title":"Biomedical image mesh generation","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The function H8voximg can generate a hexahedral mesh from a three-dimensional image (such as a CT scan). The resulting meshes can be smoothed (meshsmoothing).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"A similar functionality  is also available for tetrahedra (T4voximg). A more sophisticated strategy is available in the VoxelTetMeshingModule module: the initial mesh can be progressively coarsened and smoothed, resulting  in a much more realistic looking geometry compared  to the initial jagged representation.","category":"page"},{"location":"guide/guide.html#Boundary-extraction-1","page":"Guide","title":"Boundary extraction","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Mesh  composed of  any element type can be passed to the function  meshboundary, and  the boundary of the mesh is extracted. As an example, the code","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nbdryfes = meshboundary(fes);","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"generates a mesh of quadrilaterals in the set fes,  and bdryfes = meshboundary(fes) finds the boundary elements of the type L2 (line elements with two nodes) and stores them in the  finite element set bdryfes.","category":"page"},{"location":"guide/guide.html#Conversion-between-element-types-1","page":"Guide","title":"Conversion  between element types","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For any element shape  (line, triangle,  quadrilateral, hexahedron, tetrahedron) there is  the linear version and the quadratic version. Conversion routines are provided so tthat, for example, mesh can be generated as eight-node  hexahedra  and then converted  to twenty node hexahedra as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens,fes = H8toH20(fens,fes)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Other conversion routines NEEDS  TO BE WRITTEN","category":"page"},{"location":"guide/guide.html#Refinement-1","page":"Guide","title":"Refinement","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Meshes composed of some  element types can be uniformly refined. For instance, quadrilateral meshes can be refined by bisection with Q4refine.","category":"page"},{"location":"guide/guide.html#Selection-of-mesh-entities-1","page":"Guide","title":"Selection of mesh entities","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There are many instances of problem definitions where it is important to partition meshes into subsets. As an example,  consider a tube consisting of inner ABS core and  outer fiber-reinforced  laminate  layer. The mesh may consist  of hexahedra.  This mesh would then need to be partitioned into two subsets, because the materials and the  material orientation data  are different between the two regions.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"As another example, consider a simple beam  of rectangular cross-section, clamped  at one end,  and  loaded with shear tractions at the  free end. The  entire boundary of the beam needs to be separated  into three subsets:  the first subset,  for the traction-free boundary, is ignored. The second subset, for the clamped cross-section, is extracted  and  its nodes  are used  to  formulate the essential boundary condition. The third subset is extracted and used to define an FEM machine to compute the load vector due to the shear traction.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There are  several  ways  in which mesh entities (nodes and finite elements) can be selected. The simplest uses element labels: some mesh-generation routines label the generated elements. For example,","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens,fes = H8layeredplatex(xs, ys, ts, nts)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"generates a plate-like mesh where the layers are labeled. It is therefore possible to select  the bottom-most layer as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"rls = selectelem(fens, fes, label = 1)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where rls is a list of integer indexes into the  set fes, so that we can extract a subset corresponding to this layer as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"botskin = subset(fes, rls)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Geometrical techniques for selecting finite elements  or nodes can be based on","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"the location within or overlap  with boxes;\ndistance from  a given point;\ndistance from a given plane;\nconnectedness (selection by flooding).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Additionally, surface-like  finite elements (quadrilaterals and triangles embedded in three dimensions, or lines embedded in two dimensions) can be selected based upon the orientation of their normal (facing  criterion).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"As an example, consider a straight duct with anechoic termination. A triangle mesh is generated as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fens,fes  =  T3block(Lx,Ly,n,2); ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"and its boundary is extracted as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"bfes  =  meshboundary(fes)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The finite elements from the  piece of the boundary on the left parallel to the Y axis can be extracted as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"L0 = selectelem(fens,bfes,facing = true, direction = [-1.0 0.0])","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where the numbers of the finite elements  whose normals point in the general direction of the vector [-1.0 0.0] are returned in the integer array L0.","category":"page"},{"location":"guide/guide.html#Fields-1","page":"Guide","title":"Fields","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The structure to maintain the numbering  and values of the degrees of freedom in the mesh  is the field.","category":"page"},{"location":"guide/guide.html#Abstract-Field-1","page":"Guide","title":"Abstract  Field","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The assumption is that a field has one set of degrees of freedom per node or per element. For simplicity we will refer to the nodes and elements as entities. It assumes that concrete  subtypes of the abstract field  have the following data, one row per entity:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"values::FMat{T}: Array of the values of the degrees of freedom, one row  for each entity. All the arrays below have the same dimensions as this one.\ndofnums::FIntMat: Array  of the numbers of the free degrees of freedom. If the degree of freedom is fixed (prescribed), the corresponding entry is zero.\nis_fixed::Matrix{Bool}: Array of  Boolean flags,  true for fixed  (prescribed) degrees of freedom, false otherwise.\nfixed_values::FMat{T}: Array  of the same size and type  as  values. Its entries are only relevant  for the fixed (prescribed)  degrees of freedom.\nnfreedofs::FInt:  the total number of free degrees of freedom.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The methods defined for the abstract field  include:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Return the number of degrees of freedom and the number of entities.\nGather and scatter the system vector.\nGather elementwise  vectors or matrices of values, the degree of freedom numbers, or the fixed values of the degrees of freedom. \nSet  or clear essential boundary conditions..\nCopy a field. Clear the entries of the field.","category":"page"},{"location":"guide/guide.html#Nodal-Field-1","page":"Guide","title":"Nodal Field","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"In this case  the  abstract field is subtyped to a concrete field where the entities are nodes.","category":"page"},{"location":"guide/guide.html#Elemental-Field-1","page":"Guide","title":"Elemental Field","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are the elements.","category":"page"},{"location":"guide/guide.html#General-Field-1","page":"Guide","title":"General Field","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are  use-case  specific. ","category":"page"},{"location":"guide/guide.html#Numbering-of-the-degrees-of-freedom-1","page":"Guide","title":"Numbering of the degrees of freedom","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The simplest method is at the moment implemented: number all free degrees of freedom, row-by-row and column-by-column, starting from 1 up to f.nfreedofs, for the field f.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The prescribed degrees of freedom are not numbered, and the prescribed degrees of freedom are marked with 0.","category":"page"},{"location":"guide/guide.html#Finite-element-1","page":"Guide","title":"Finite element","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  finite element set is one of the basic entities in FinEtools.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The finite element set is a collection of  finite elements defined by the connectivity (collection of node numbers, listing the nodes connected by the element in  a specific order). The finite element set  provides  specialized methods  to compute values of basis functions and the values of  the gradients of the basis functions  with respect to the parametric coordinates.","category":"page"},{"location":"guide/guide.html#Element-types-1","page":"Guide","title":"Element types","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The finite element sets are instances of concrete types. Each particular shape and order of element has its own type. There are types for  linear  and quadratic quadrilaterals, for instance, FESetQ4 and FESetQ8. Each element set provides access to the number of nodes  connected by the element (nodesperelem),  the connectivity as the two dimensional array    conn,  and the  integer label vector label. ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The concrete finite element set types are subtypes of the abstract type for elements of different manifold dimension (3, 2, 1, and 0), for instance for the quadrilaterals that would be AbstractFESet2Manifold. These types are in turn  subtypes of the abstract finite element set type AbstractFESet.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The concrete finite element set type provides specialized methods to compute the values of the basis functions, bfun, and methods to compute  the gradients of the basis functions with respect to the parametric coordinates, bfundpar.","category":"page"},{"location":"guide/guide.html#Finite-element-set-functions-1","page":"Guide","title":"Finite element set functions","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Methods defined for  the abstract type:\nnodesperelem: Get the number of nodes  connected  by  the finite element.\ncount:  Get the number of individual connectivities in the FE set.\nsetlabel!: Set the label of the entire finite elements set.\nconnasarray: Retrieve  connectivity  as an integer array.\nfromarray!: Set  connectivity from an integer array.\nsubset: Extract a subset of the finite elements from the given finite element set.\ncat: Concatenate the connectivities of two FE sets.\nupdateconn!: Update the connectivity after the IDs of nodes changed.\nmap2parametric: Map a spatial location to parametric coordinates.\nMethods dispatched based on the manifold type:\nmanifdim: Return the manifold dimension.\nJacobian: Evaluate the  Jacobian.\ngradN!: Compute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\nMethods dispatched on the concrete type:\nboundaryconn: Get boundary connectivity.\nboundaryfe: Return the constructor of the type of the boundary finite element.\nbfun: Compute the values of the basis functions at a given parametric coordinate.\nbfundpar: Compute the values of the basis function gradients at a given parametric coordinate.\ninparametric: Are given parametric coordinates inside the element parametric domain?\ncentroidparametric: Return the parametric coordinates  of the centroid of the element.","category":"page"},{"location":"guide/guide.html#Integration-1","page":"Guide","title":"Integration","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There are two kinds of integrals in the weighted-residual finite element method: integrals over the interior  of the domain,  and integrals over the boundary of the domain.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Consequently, in a typical simulation one would need  two meshes: one for the interior  of the domain,  and one for the boundary. Obviously, the one for the boundary will be derived from the mesh  constructed for the interior.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Often only a part  of the entire boundary   is   used:  on some parts of the boundary  the  boundary condition is implied as homogeneous (i. e. zero). For instance, a traction-free boundary. Therefore the necessary integrals are typically evaluated over a subset of the entire boundary.","category":"page"},{"location":"guide/guide.html#Manifold-dimension-1","page":"Guide","title":"Manifold dimension","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Finite elements  have  a certain manifold dimension.  Tetrahedra  and hexahedra are three-manifolds, triangles and quadrilaterals are two-manifolds, triangles and quadrilaterals are two-manifolds, lines are one-manifolds, and points are zero-manifolds.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Elements are equipped with an \"other\" dimension which boosts the manifold dimension to produce the required dimension for  the integration. For instance,  a line element can be equipped with an \"other\" dimension to represent a cross-section so that a volume integral can be evaluated over a line element. Or, a line element can be given an \"other\" dimension as a thickness to result in a physical dimension needed to evaluate a surface integral.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The \"other\"  dimension  has the following meaning  for finite elements of different manifold dimensions:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Manifold dimension Volume integral Surface integral\n3 NA NA\n2 Thickness NA\n1 Cross-section Thickness\n0 Volume Cross-section","category":"page"},{"location":"guide/guide.html#Integration-over-the-interior-1","page":"Guide","title":"Integration  over the interior","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The integrals are always  volume integrals. This means that for elements which are of  lower manifold dimension than three the \"other\"  dimension needs to compensate.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For  three-manifold finite elements (tetrahedra and hexahedra) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a volume-like element.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For  finite elements of manifold dimension  less than tthree, the  \"other\" dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Manifold dimension Axially symmetric Plane 2D\n2 2pi r Thickness\n1 2pi rtimes  Thickness Cross-section\n0 2pi rtimes Cross-section Volume","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_Omega f dV approx sum_q f(xi_q) J(xi_q) W_q","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Here f  is the integrand, f(xi_q)  is the  value of the integrand  at the quadrature point, J(xi_q)  is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension,  and therefore it is the  volume  Jacobian. (For the interior integrals the Jacobian  is computed by the Jacobianvolume method.)","category":"page"},{"location":"guide/guide.html#Integration-over-the-boundary-1","page":"Guide","title":"Integration  over the boundary","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The integrals are always  surface integrals. This means that for elements which are of  lower manifold  dimension than two the \"other\"  dimension needs to compensate.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For  two-manifold finite elements (triangles and quadrilaterals) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a surface-like element.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For  finite elements of manifold dimension  less than two, the  \"other\" dimension varies according  to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Manifold dimension Axially symmetric Plane 2D\n1 2pi r Thickness\n0 2pi rtimes   Thickness Cross-section","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_partial Omega f dS approx sum_q f(xi_q) J(xi_q) W_q  ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Here f  is the integrand, f(xi_q) is the  value of the integrand  at the quadrature point, J(xi_q) is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension,  and therefore it is the  surface Jacobian. (For the boundary integrals the Jacobian  is computed by the Jacobiansurface method.)","category":"page"},{"location":"guide/guide.html#Example:-axially-symmetric-model,-line-element-L2-1","page":"Guide","title":"Example: axially symmetric model, line element L2","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The surface Jacobian in this case  is  equal to the curve Jacobian times 2*pi*r.","category":"page"},{"location":"guide/guide.html#Integration-Data-1","page":"Guide","title":"Integration Data","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  module IntegDomainModule supports  the processing of  the geometry necessary for the evaluation of the various integrals. The module data structure  groups together  a finite element set with an appropriate integration rule, information about the model (axially symmetric or not), and a callback to evaluate  the \"other\" dimension.","category":"page"},{"location":"guide/guide.html#Other-dimension-1","page":"Guide","title":"Other dimension","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  discussion of the surface and volume integrals introduces the notion  of the  \"other\"  dimension. In order to evaluate Jacobians of various space dimensions  the  Geometry Data module takes into account  whether or not the model is axially symmetric, and evaluates the \"other\" dimension based upon this information. ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"A finite element set is equipped with  a way of  calculating  the \"other\" dimension.  For instance, the line element with two nodes, L2, can be given  the \"other\" dimension  as a  \"thickness\"  so that  surface integrals  can be evaluated over the line element. However, if this line element  is used in an axially symmetric model, the same  \"other\" dimension  of \"thickness\"  will result in the integral  along the length of this line element  being a volume integral.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Thus, the way in which the \"other\"  dimension gets used by the Geometry Data methods depends on the model. As an example, consider  the  method","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"function Jacobianvolume(self::IntegDomain{T}, J::FFltMat, loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC<:AbstractArray{FInt}}\n    Jac = Jacobiansurface(self, J, loc, conn, N)::FFlt\n    if self.axisymmetric\n        return Jac*2*pi*loc[1];\n    else\n        return Jac*self.otherdimension(loc, conn,  N)\n    end\nend","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"which  evaluates the volume Jacobian  for an element  of manifold dimension  2  (surface). Note that  first  the surface Jacobian  is calculated, which is then boosted to a volume Jacobian in two different ways, depending on whether  the model is axially symmetric or not. For the axially symmetric case  the \"other\"  dimension is implied, ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The callback function computes the \"other\" dimension from  two kinds of  information: (a) the physical location  of the quadrature point,  and (b) the interpolation data for the element  (connectivity and the values of the basis functions at the quadrature point). ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The approach ad (a) is suitable  when the \"other\" dimension is given as a function of the physical coordinates. The  simplest case is obviously  a uniform distribution of the \"other\" dimension. When  no  callback is explicitly provided,  the  \"other\"  dimension  callback is  automatically generated as the trivial","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"function otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {CC<:AbstractArray{FInt}}\n    return 1.0\nend","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"which simply returns 1.0 as the default value.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The approach ad (b) is appropriate when the \"other\" dimension  is given by values given at the nodes of the  mesh. Than the connectivity  and  the array of the values of the basis functions  can be used to interpolate the \"other\"  dimension  to the quadrature point.","category":"page"},{"location":"guide/guide.html#Evaluation-of-integration-data-1","page":"Guide","title":"Evaluation of integration data","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Importantly, the  Integration Domain (IntegDomain) method integrationdata evaluates quantities  needed for numerical integration: locations and weights of quadrature points, and the values of basis functions and of the basis function gradients with respect to the parametric coordinates at the quadrature points.","category":"page"},{"location":"guide/guide.html#FEM-machines-1","page":"Guide","title":"FEM machines","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The construction of the matrices and vectors of the discrete form of the weighted residual equation is performed in FEM  machines. (FEM = Finite Element Method.)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"As an example consider the weighted-residual form of the heat balance equation","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_V  vartheta c_Vfracpartial Tpartial t  mathrmd V\n            +int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V \n            -int_V  vartheta Q  mathrmd V  \n            +int_S_2 varthetaoverlineq_n mathrmd S+ int_S_3 varthetah\n            (T-T_a)   mathrmd S = 0","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where vartheta(x) =0  for  x inS_1 .","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  test function is  taken to be  one  finite element basis function at a time, vartheta = N_leftjright, and the trial function is","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"T = sum_i= 1 ^N N_leftiright T_i ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Here by N_leftjright we mean the basis function constructed on the mesh and associated with the node leftjright. We use the notation inspected times two to mean node number at which the degree of freedom  j lives.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Now the test function and the trial function is substituted  into the  weighted residual equation.  ","category":"page"},{"location":"guide/guide.html#Example:-internal-heat-generation-rate-term-1","page":"Guide","title":"Example:  internal heat generation rate term","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For instance,  for the term ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_V  vartheta Q  mathrmd V ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"we obtain","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_V N_leftjright Q  mathrmd V ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"This integral evaluates to a number, the heat load  applied to the degree of freedom j. When these numbers are evaluated for all  the free degrees of freedom,  they constitute the entries of the global heat load vector. ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Evaluating integrals of this form is so common that there is a module FEMMBaseModule with the method distribloads that computes and assembles the global vector. For instance to evaluate this heat load vector  on the mesh composed of three-node triangles, for a uniform heat generation rate Q, we can write","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"fi = ForceIntensity(FFlt[Q]);\nF1 = distribloads(FEMMBase(IntegDomain(fes, TriRule(1))), geom, Temp, fi, 3);","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"IntegDomain(fes, TriRule(1)) constructs integration domain for the  finite elements fes using a triangular  integration rule with a single point. FEMMBase is the base  FEM  machine,  and all it needs at this point is the integration domain. The method  distribloads is defined for the  base FEM machine, the geometry field geom, the numbering of the degrees of freedom is taken from the field Temp, the internal heat generation rate is defined as the force intensity fi, and the integrals  are volume integrals  (3).","category":"page"},{"location":"guide/guide.html#Example:-conductivity-term-1","page":"Guide","title":"Example: conductivity term","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The conductivity term from the weighted residual equation","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"is rewritten with the test and trial functions as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"sum_i=1^N int_V(mathrmgradN_leftjright) kappa (mathrmgradN_leftiright\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The sum over the degree of freedom number i should be split: some of the  coefficients T_i are for free degrees of freedom (1 le i le  N_mathrmf, with N_mathrmf being the total number of free degrees of freedom), while some are  fixed (prescribed) for nodes  which are located on the essential boundary condition surface S_1  (N_mathrmf  i le N).","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Thus the term splits into two  pieces, ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"sum_i=1^N_mathrmf int_V(mathrmgradN_leftjright) kappa (mathrmgradN_leftiright\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where the  individual integrals are entries of the conductivity matrix, and","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"sum_i=N_mathrmf+1^N int_V(mathrmgradN_leftjright) kappa (mathrmgradN_leftiright\n            )^T mathrmd V  T_i","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"which  will represent heat loads  due to nonzero  prescribed boundary condition.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FEM machine  for heat conduction  can be created as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"material = MatHeatDiff(thermal_conductivity)\nfemm = FEMMHeatDiff(IntegDomain(fes, TriRule(1)), material)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where we first create a material to  deliver the thermal conductivity matrix kappa, and then  we create  the FEM  machine  from the integration domain  for a mesh  consisting of three node triangles, using one-point integration rule, and the material. This  FEM machine  can then be passed to a method","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"K = conductivity(femm, geom, Temp)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"to evaluate the global conductivity matrix K, where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The heat load term  due to the  nonzero essential boundary conditions  is evaluated with the method nzebcloadsconductivity","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"F2 = nzebcloadsconductivity(femm, geom, Temp);","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom and the values of the prescribed (fixed) degrees of freedom. The result is a contribution to the global heat load vector.","category":"page"},{"location":"guide/guide.html#Base-FEM-machine-1","page":"Guide","title":"Base FEM machine","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The following  operations are provided  by the base FEM machine:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Integrate  a function expressed in terms of a field. This is typically used  to  evaluate RMS discretization errors.\nIntegrate a function of the position. Perhaps the evaluation of the moments of inertia,  or the calculation of the volume.\nTransfer field between meshes of different resolutions.\nCalculate  the distributed-load system vector.\nConstruct a field  from integration-point quantities. This is typically used in the postprocessing phase, for instance to construct continuous distribution of stresses in the structure.","category":"page"},{"location":"guide/guide.html#Acoustics-FEM-machines-1","page":"Guide","title":"Acoustics FEM machines","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There is one for  the interior integrals  and one for  boundary integrals.  The  machine for the interior integrals can be used to compute:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Evaluate the acoustic-mass matrix and the acoustic-stiffness matrix.\nEvaluate the load vector corresponding to prescribed pressure  or the prescribed second order  rate of the pressure.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The machine for the boundary integrals can be used to compute:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Compute  transformation matrix to convert  pressure  to resultant force  or pressure to resultant torque.\nCompute the acoustic  ABC  (absorbing boundary condition) matrix.","category":"page"},{"location":"guide/guide.html#Heat-conduction-FEM-machines-1","page":"Guide","title":"Heat  conduction FEM machines","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There is one for  the interior integrals  and one for  boundary integrals.  The  machine for the interior integrals can be used to compute:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Evaluate the conductivity matrix.\nEvaluate the load vector corresponding to prescribed temperature.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The machine for the boundary integrals can be used to compute:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Compute surface heat transfer  matrix.\nCompute  the heat load vector for surface heat transfer.\nCompute the heat load vector  corresponding to prescribed temperatures on the boundary  with surface heat transfer.","category":"page"},{"location":"guide/guide.html#Linear-deformation-FEM-machines-1","page":"Guide","title":"Linear deformation FEM  machines","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For  the base machine for linear deformation, FEMMDeforLinearBase, assumes standard isoparametric  finite elements. It evaluates  the interior integrals:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Additionally:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FEM machine FEMMDeforLinear simply stores the data required by the base FEMMDeforLinearBase.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The machine FEMMDeforWinkler is specialized for the boundary integrals for bodies  supported  on continuously distributed springs:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Compute the stiffness matrix corresponding to the springs.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  mean-strain FEM machine FEMMDeforLinearMS implements advanced hexahedral and tetrahedral elements based on multi-field theory and  energy-sampling  stabilization. It provides functions to compute:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Additionally it defines:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html#Material-and-Material-Orientation-1","page":"Guide","title":"Material and Material Orientation","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The material response  is described in  material-point-attached coordinate system. These coordinate systems  are Cartesian, and the material coordinate system is typically chosen to make  the response particularly simple.  So for orthotropic or transversely isotropic materials the axes would be aligned with the axes of orthotropy.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The type CSys (module CSysModule) is the updater of the material coordinate system matrix. The object is equipped with a callback to store the current orientation matrix. For instance: the coordinate system for an orthotropic material wound around a cylinder could be described in the coordinate system CSys(3, 3, updatecs!), where the callback is defined as","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"function updatecs!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    csmatout[:, 2] = [0.0 0.0 1.0]\n    csmatout[:, 3] = XYZ\n    csmatout[3, 3] = 0.0\n    csmatout[:, 3] = csmatout[:, 3]/norm(csmatout[:, 3])\n    csmatout[:, 1] = cross(csmatout[:, 2], csmatout[:, 3])\nend","category":"page"},{"location":"guide/guide.html#Materials-for-linear-deformation-analysis-1","page":"Guide","title":"Materials for linear deformation analysis","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The module MatDeforModule provides functions to convert between vector and matrix (tensor) representations of stress and strain. Further, functions to rotate stress and strain between different coordinate systems (based upon the model-reduction type, 3-D, 2-D, or 1-D) are provided.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Currently  there are material types for isotropic and orthotropic linear elastic materials. The user may add  additional material types by deriving from AbstractMatDefor and equipping them with three methods: (1) compute the tangent moduli, (2) update the material state, (3) compute the thermal strain.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"For full generality, material types  should implement these methods for fully three-dimensional, plane strain and plane stress, 2D axially symmetric, and one-dimensional deformation models.","category":"page"},{"location":"guide/guide.html#Algorithms-1","page":"Guide","title":"Algorithms","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Algorithms typically (not always) accept a single argument, modeldata, a dictionary of data, keyed by Strings. Algorithms  also return modeldata,  typically  including additional key/value pairs that represent the data computed by the algorithm.","category":"page"},{"location":"guide/guide.html#Base-algorithms-1","page":"Guide","title":"Base algorithms","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"These are not specific to the particular physics at hand. Examples of  algorithms are  Richardson extrapolation,  calculation of the norm of the field, or calculation of the norm  of the difference of two fields. These algorithms are the exceptions, they do not return modeldata but rather return directly computed values.","category":"page"},{"location":"guide/guide.html#Acoustics-algorithms-1","page":"Guide","title":"Acoustics algorithms","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"At the moment there is one algorithm, for steady-state (harmonic) acoustics.","category":"page"},{"location":"guide/guide.html#Example:-baffled-piston-1","page":"Guide","title":"Example:  baffled piston","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"After the mesh  has been generated, the modeldata can be set up: Here we begin with  the region.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"material = MatAcoustFluid(bulk, rho)\nregion1 =  FDataDict(\"femm\"=>FEMMAcoust(IntegDomain(fes, GaussRule(3, 2)), material))","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"We set up a definition of the absorbing boundary condition:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"abc1  =  FDataDict(\"femm\"=>FEMMAcoustSurf(IntegDomain(outer_fes, GaussRule(2, 2)),\n          material))","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The  surface of the piston is associated with a known-flux  boundary condition:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"flux1  =  FDataDict(\"femm\"=>FEMMAcoustSurf(IntegDomain(piston_fes, GaussRule(2, 2)),\n          material),  \"normal_flux\"=> -rho*a_piston+0.0im);","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"And finally we make the model data,","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"modeldata =  FDataDict(\"fens\"=>  fens,\n                 \"omega\"=>omega,\n                 \"regions\"=>[region1],\n                 \"flux_bcs\"=>[flux1], \"ABCs\"=>[abc1])","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"and call  the solver:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"modeldata = FinEtools.AlgoAcoustModule.steadystate(modeldata)","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"When  the algorithm completes, modeldata[\"P\"] is the computed pressure field.","category":"page"},{"location":"guide/guide.html#Heat-diffusion-algorithms-1","page":"Guide","title":"Heat diffusion algorithms","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There is an implementation of an algorithm for steady-state heat conduction.","category":"page"},{"location":"guide/guide.html#Linear-deformation-algorithms-1","page":"Guide","title":"Linear deformation algorithms","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"There are algorithms for","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Linear static analysis;\nExport  of the deformed shape for visualization;\nExport  of the nodal and elementwise stress fields for visualization;\nModal (free-vibration) analysis;\nExport  of modal shapes for visualization;\nSubspace-iteration method implementation.","category":"page"},{"location":"guide/guide.html#Model-data-1","page":"Guide","title":"Model data","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm  and returned for further processing by other algorithms.","category":"page"},{"location":"guide/guide.html#Queries-of-quadrature-point-data-1","page":"Guide","title":"Queries of quadrature-point data","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"NEEDS  TO BE WRITTEN","category":"page"},{"location":"guide/guide.html#Postprocessing-1","page":"Guide","title":"Postprocessing","text":"","category":"section"},{"location":"guide/guide.html#Compute-continuous-stress-fields-1","page":"Guide","title":"Compute continuous stress fields","text":"","category":"section"},{"location":"guide/guide.html#Compute-elementwise-stress-fields-1","page":"Guide","title":"Compute elementwise stress fields","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"NEEDS  TO BE WRITTEN","category":"page"},{"location":"guide/guide.html#Import/export-1","page":"Guide","title":"Import/export","text":"","category":"section"},{"location":"guide/guide.html#Importing-1","page":"Guide","title":"Importing","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"At the moment importing is mostly limited to the mesh data (properties, boundary conditions, analysis of data, etc. are typically not imported). The following formats of finite element input files can be handled:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"NASTRAN (.nas files).\nAbaqus (.inp files).","category":"page"},{"location":"guide/guide.html#Exporting-1","page":"Guide","title":"Exporting","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"VTK (.vtk so-called legacy files). Export of geometry and fields (nodal and elemental) is supported.\nAbaqus (.inp files). Mesh data and selected property, boundary condition, and procedure commands can be handled.\nNASTRAN (.nas files). Very basic mesh and select other attributes are handled.\nSTL file export of surface data.\nH2Lib triangular-surface export (.tri files).\nCSV file export of numerical data is supported.","category":"page"},{"location":"guide/guide.html#Tutorials-and-Examples-1","page":"Guide","title":"Tutorials and Examples","text":"","category":"section"},{"location":"guide/guide.html#Tutorials-1","page":"Guide","title":"Tutorials","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FinEtools tutorials are written up in their own separate repository, FinEtoolsTutorials.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The tutorials are in the form of Julia files with markdown. These are converted to markdown files (or to Jupyter notebooks) using the Literate workflow.","category":"page"},{"location":"guide/guide.html#Examples-1","page":"Guide","title":"Examples","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The FinEtools examples are separated in their own separate repositories, FinEtoolsHeatConductionExamples, FinEtoolsAcousticsExamples, FinEtoolsLinearDeformationExamples, FinEtoolsMeshGenerationExamples.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The examples are in the form of  Julia files with multiple functions, where each function defines one example. Take for instance the example file Fahy_examples.jl. This incantation will run all the examples from the example file:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"include(\"Fahy_examples.jl\"); Fahy_examples.allrun()","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"This will run just a single example from this file:","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"include(\"Fahy_examples.jl\"); Fahy_examples.fahy_H8_example()","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The example file Fahy_examples.jl consists of a module (whose name matches the name of the file), and  the module defines multiple functions,  one for each example, and one to run all examples, allrun.","category":"page"},{"location":"guide/guide.html#Tests-1","page":"Guide","title":"Tests","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Check out the numerous tests in the test folder. There are hundreds of tests which exercise the various functions of the library. These examples may help you understand how to extract the desired outcome.","category":"page"},{"location":"guide/guide.html#Make-up-your-own-public-interface-1","page":"Guide","title":"Make up your own public interface","text":"","category":"section"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Here we assume that the FinEtools package is installed. We also assume the user works in his or her own folder, which for simplicity we assume is a package folder in the same tree as the package folder for FinEtools. ","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The user may have his or her additions to the FinEtools library, for instance a new material implementation, or a new FEMM (finite element model machine). Additionally, the user writes some code to solve particular problems.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"In order to facilitate interactive work at the command line(REPL), it is convenient to have one or two modules so that using them allows for the user's code to resolve function names from the FinEtools package and from the user's own code.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Here are two ways in which this can be accomplished.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"The user exports his or her own additions from the module add2FinEtools (the name of this module is not obligatory, it can be anything). In addition, the public interface to the FinEtools package needs to be brought in separately.\nusing FinEtools  using add2FinEtools\nThe user may change entirely the public interface to the FinEtools package by selectively including parts of the FinEtools.jl file and the code to export his or her own functionality in a single module, let us say myFinEtools (this name is arbitrary), so that when the user invokes\nusing myFinEtools\nall the functionality that the USER considers to be public is made available by exports.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Method 1 has the advantage that the interface definition of the FinEtools package itself does not change, which means that package code does not need to be touched. It also has a disadvantage that the interface to FinEtools does not change which means that if there is a conflict with one of the exported functions from FinEtools, it needs to be resolved by fiddling with other packages.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"Method 2 has the advantage that when there is a conflict between one of the exported FinEtools functions and some other function, be it from another package or the user's own, the conflict can be resolved by changing the public interface to FinEtools by the USER (as opposed to  by the DEVELOPER). Also, in this method the USER has the power to define the public interface to the FinEtools package, and if the user decides that nothing should be exported for implicit resolution of functions, that is easily accomplished.","category":"page"},{"location":"guide/guide.html#","page":"Guide","title":"Guide","text":"These two methods have been described by examples in the FinEtoolsUseCase package. Refer to the Readme  file and to the method descriptions  in the  method 1 and 2 folders.","category":"page"},{"location":"man/types.html#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#Coordinate-systems-1","page":"Types","title":"Coordinate systems","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.CSysModule.CSys","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys{F<:Function}\n\nType for coordinate system transformations.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(csmat::FFltMat)\n\nConstruct coordinate system when the rotation matrix is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Int64,Int64}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::FInt, mdim::FInt)\n\nConstruct coordinate system for isotropic-material used with isoparametric finite elements.\n\nsdim = number of space dimensions,\nmdim = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.\n\nnote: Note\n\n\nIf  the coordinate system matrix  should be identity, better use the constructor for this specific situation, CSys(dim::FInt). That will be much more efficient.\n\nSee also\n\ngen_iso_csmat\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{Int64}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(dim::FInt)\n\nConstruct coordinate system when the rotation matrix is the identity.\n\ndim = is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F<:Function","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::FInt, mdim::FInt, computecsmat::F) where {F<:Function}\n\nConstruct ccoordinate system when the function to compute the rotation matrix is given.\n\nThe function signature: update!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt) where\n\ncsmatout= output matrix buffer, \nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element,\nfe_label= finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Finite-element-sets-1","page":"Types","title":"Finite element sets","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet","page":"Types","title":"FinEtools.FESetModule.AbstractFESet","text":"AbstractFESet{NODESPERELEM}\n\nAbstract type of a finite element set. Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet0Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet0Manifold","text":"AbstractFESet0Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet1Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet1Manifold","text":"AbstractFESet1Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet2Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet2Manifold","text":"AbstractFESet2Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet3Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet3Manifold","text":"AbstractFESet3Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH20","page":"Types","title":"FinEtools.FESetModule.FESetH20","text":"FESetH20\n\nType for sets of volume-like hexahedral finite elements with 20 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH27","page":"Types","title":"FinEtools.FESetModule.FESetH27","text":"FESetH27\n\nType for sets of volume-like hexahedral finite elements with 27 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH8","page":"Types","title":"FinEtools.FESetModule.FESetH8","text":"FESetH8\n\nType for sets of volume-like hexahedral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL2","page":"Types","title":"FinEtools.FESetModule.FESetL2","text":"FESetL2\n\nType for sets of curve-like finite elements with two nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL3","page":"Types","title":"FinEtools.FESetModule.FESetL3","text":"FESetL3\n\nType for sets of curve-like of finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetP1","page":"Types","title":"FinEtools.FESetModule.FESetP1","text":"FESetP1\n\nType for sets of point-like of finite elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ4","page":"Types","title":"FinEtools.FESetModule.FESetQ4","text":"FESetQ4\n\nType for sets of surface-like quadrilateral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ8","page":"Types","title":"FinEtools.FESetModule.FESetQ8","text":"FESetQ8\n\nType for sets of surface-like quadrilateral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ9","page":"Types","title":"FinEtools.FESetModule.FESetQ9","text":"FESetQ9\n\nType for sets of surface-like quadrilateral finite elements with nine nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT10","page":"Types","title":"FinEtools.FESetModule.FESetT10","text":"FESetT10\n\nType for sets of volume-like tetrahedral finite elements with 10 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT3","page":"Types","title":"FinEtools.FESetModule.FESetT3","text":"FESetT3\n\nType for sets of surface-like triangular finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT4","page":"Types","title":"FinEtools.FESetModule.FESetT4","text":"FESetT4\n\nType for sets of volume-like tetrahedral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT6","page":"Types","title":"FinEtools.FESetModule.FESetT6","text":"FESetT6\n\nType for sets of surface-like triangular finite elements with six nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-nodes-1","page":"Types","title":"Finite element nodes","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeSetModule.FENodeSet","page":"Types","title":"FinEtools.FENodeSetModule.FENodeSet","text":"Finite element node set type.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-node-to-element-map-1","page":"Types","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"Map from finite element nodes to the finite elements connecting them.\n\nFor each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array map.         Example: \n\nfes.conn= [7,6,5;\n            4,1,3;\n            3,7,5];\nThe map reads\n    map[1] = [2];\n    map[2] = [];#  note that node number 2 is not referenced by the connectivity\n    map[3] = [2,3];\n    map[4] = [2];\n    map[5] = [1,3];\n    map[6] = [1];\n    map[7] = [1,3];\n\nThe individual elements from the connectivity that reference node number 5 are 1 and 3, so that fes.conn(map[5],:)includes all the nodes that are connected to node 5 (including node 5 itself).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Array{Int64,2},Int64}","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(conns::FIntMat, nmax::FInt)\n\nMap from finite element nodes to the finite elements connecting them.\n\nconns = integer array of the connectivities\nnmax = largest possible node number\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT<:Integer where N","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT<:Integer}\n\nMap from finite element nodes to the finite elements connecting them.\n\nconns = connectivities as a vector of tuples\nnmax = largest possible node number\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Fields-1","page":"Types","title":"Fields","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FieldModule.AbstractField","page":"Types","title":"FinEtools.FieldModule.AbstractField","text":"AbstractField\n\nAbstract field.\n\nExpected  attributes:\n\nvalues::FMat{T}: Array of degree of freedom parameters,  indexed by entity number\ndofnums::FIntMat: Array of degree of freedom numbers, indexed by entity number\nis_fixed::Matrix{Bool}: Array of Boolean flags, indexed by entity number\nfixed_values::FMat{T}: Array of fixed values, indexed by entity number\nnfreedofs::FInt: Total number of free degrees of freedom\n\nSee also: @add_Field_fields() .\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField{T<:Number} <: AbstractField\n\nGeneral field, meaning the entities can be anything.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::FVec{T}) where {T<:Number}\n\nConstructor of general field.  The values of the field are given by the vector on input, data. This vector needs to have as many rows as there are entities.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of general field.  The values of the field are given by the array on input, data. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField{T<:Number} <: AbstractField\n\nNodal field, meaning the entities are the finite element nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::FVec{T}) where {T<:Number}\n\nConstructor of nodal field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of nodal field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField{T<:Number} <: AbstractField\n\nElemental field, meaning the entities are finite elements.\n\nThe values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::FVec{T}) where {T<:Number}\n\nConstructor of elemental field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::FMat{T}=[]) where {T<:Number}\n\nConstructor of elemental field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Integration-rule-1","page":"Types","title":"Integration rule","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegRuleModule.AbstractIntegRule","page":"Types","title":"FinEtools.IntegRuleModule.AbstractIntegRule","text":"AbstractIntegRule\n\nAbstract type for integration rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule <: AbstractIntegRule\n\nThe Gauss rul, applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule(dim=1, order=1)\n\nGauss rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule <: AbstractIntegRule\n\nThe nodal-quadrature simplex rule.\n\nThe rule is applicable for line segments, triangles, tetrahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule(dim=1)\n\nNodal-quadrature simplex rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule <: AbstractIntegRule\n\nThe tensor-product nodal-quadrature rule.\n\nThe rule is applicable for line segments, quadrilaterals, hexahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule(dim=1)\n\nNodal-quadrature tensor-product rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule <: AbstractIntegRule\n\nPoint quadrature rule, used for integration on the standard \"point\" shape.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule-Tuple{}","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule()\n\nPOINT integration rule.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule <: AbstractIntegRule\n\nSimplex quadrature rule.\n\nUsed for integration on the standard triangle or the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule(dim=1, npts=1)\n\nReturn simplex rule, appropriate for the manifold dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule <: AbstractIntegRule\n\nTetrahedral quadrature rule, used for integration on the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule(npts=1)\n\nTetrahedral integration rule. npts=number of points (1 one-point rule, 4  four-point rule, 5  five point rule).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule <: AbstractIntegRule\n\nThe trapezoidal rule.\n\nThe rule is applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule(dim=1)\n\nTrapezoidal rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule <: AbstractIntegRule\n\nTriangular quadrature rule for integration on the standard triangle.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule(npts=1)\n\nType for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. npts = number of points (1 one-point rule, 3  three-point rule, 6  six  point rule, 9 nine point rule, 10  Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13twelve- and thirteen-point rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Integration-domain-1","page":"Types","title":"Integration domain","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain{S<:AbstractFESet, F<:Function}\n\nIntegration domain.\n\nT = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.\nF = type of function to return the \"other\" dimension.\n\nAn integration domain consists of the finite elements that approximate the geometry, the function to supply the \"missing\" (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool,Float64}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule, axisymmetric::Bool,\n  otherdimension::FFlt) where {S<:AbstractFESet}\n\nConstruct for axially symmetric models. The other dimension is given as a number.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule,\n  axisymmetric::Bool) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), for axially symmetric models. The other dimension is  the default  unity (1.0).\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Float64}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule,\n  otherdimension::FFlt) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), and constant other dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule}} where S<:AbstractFESet","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::AbstractIntegRule) where {S<:AbstractFESet}\n\nConstruct with the default orientation matrix (identity), and the other dimension  being the default 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Assembly-of-matrices-and-vectors-1","page":"Types","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysmatAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysmatAssembler","text":"AbstractSysmatAssembler\n\nAbstract type of system-matrix assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysvecAssembler","text":"AbstractSysvecAssembler\n\nAbstract type of system vector assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse{T<:Number} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from elementwise matrices.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse(zero::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\nExample\n\nThis is how a sparse matrix is assembled from two rectangular dense matrices.\n\n\ta = SysmatAssemblerSparse(0.0)                                                        \n\tstartassembly!(a, 5, 5, 3, 7, 7)    \n\tm = [0.24406   0.599773    0.833404  0.0420141                                             \n\t\t0.786024  0.00206713  0.995379  0.780298                                              \n\t\t0.845816  0.198459    0.355149  0.224996]                                     \n\tassemble!(a, m, [1 7 5], [5 2 1 4])        \n\tm = [0.146618  0.53471   0.614342    0.737833                                              \n\t\t 0.479719  0.41354   0.00760941  0.836455                                              \n\t\t 0.254868  0.476189  0.460794    0.00919633                                            \n\t\t 0.159064  0.261821  0.317078    0.77646                                               \n\t\t 0.643538  0.429817  0.59788     0.958909]                                   \n\tassemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        \n\tA = makematrix!(a) \n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm{T<:Number} <: AbstractSysmatAssembler\n\nAssembler for a symmetric lumped square matrix  assembled from  symmetric square matrices. \n\nReference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering & Structural Dynamics, volume 4, number 3, 245249, 1976. }\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm(zer::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm{T<:Number} <: AbstractSysmatAssembler\n\nAssembler for a symmetric square matrix  assembled from symmetric square matrices.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm(zero::T=0.0) where {T<:Number}\n\nConstruct blank system matrix assembler for symmetric matrices. The matrix entries are of type T.\n\nExample\n\nThis is how a symmetric sparse matrix is assembled from two square dense matrices.\n\n\ta = SysmatAssemblerSparseSymm(0.0)                                                        \n\tstartassembly!(a, 5, 5, 3, 7, 7)    \n\tm = [0.24406   0.599773    0.833404  0.0420141                                             \n\t\t0.786024  0.00206713  0.995379  0.780298                                              \n\t\t0.845816  0.198459    0.355149  0.224996]                                     \n\tassemble!(a, m'*m, [5 2 1 4], [5 2 1 4])        \n\tm = [0.146618  0.53471   0.614342    0.737833                                              \n\t\t 0.479719  0.41354   0.00760941  0.836455                                              \n\t\t 0.254868  0.476189  0.460794    0.00919633                                            \n\t\t 0.159064  0.261821  0.317078    0.77646                                               \n\t\t 0.643538  0.429817  0.59788     0.958909]                                   \n\tassemble!(a, m'*m, [2 3 1 5], [2 3 1 5])                                        \n\tA = makematrix!(a) \n\nSee also\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler\n\nAssembler for the system vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler-Union{Tuple{}, Tuple{T}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler(zero::T=0.0) where {T<:Number}\n\nConstruct blank system vector assembler. The vector entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Mesh-import/export-1","page":"Types","title":"Mesh import/export","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MeshImportModule, FinEtools.MeshExportModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.MeshExportModule.AbaqusExporter","page":"Types","title":"FinEtools.MeshExportModule.AbaqusExporter","text":"AbaqusExporter\n\nExport mesh to Abaqus.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MeshExportModule.NASTRANExporter","page":"Types","title":"FinEtools.MeshExportModule.NASTRANExporter","text":"NASTRANExporter\n\nExport mesh to Abaqus.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MeshExportModule.STLExporter","page":"Types","title":"FinEtools.MeshExportModule.STLExporter","text":"STLExporter\n\nExport surface mesh as STL file.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Vector-cache-utilities-1","page":"Types","title":"Vector-cache utilities","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.VectorCacheModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache{T<:Number, F<:Function}\n\nType for caching vectors.\n\nT = type of the entries of the vector, F = type of the function to update the entries of the vector.\n\nSignature of the function to fill the cache with the value of the vector at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, and if necessary  also the finite element label, fe_label:\n\nfillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nThe cache cacheout is filled with the value  of the vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache(vector::FVec{T}) where {T<:Number}\n\nConstruct vector cache. The constant vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.VectorCacheModule.VectorCache","text":"VectorCache(::Type{T}, nentries::FInt, fillcache!::F) where {T<:Number, F<:Function}\n\nConstruct vector cache. The function to fill the vector cache is given. This function needs to have a signature of\n\nfillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\nCalculate the vector and copy it into the cache....\nreturn forceout\nend\n\nand it needs to  fill in the cache cacheout with the current vector at the location XYZ, using the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label, if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Surface-normal-utilities-1","page":"Types","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal{F<:Function}\n\nExterior surface normal type.\n\nNormalized to unit length. \n\nSignature of the function to compute the value of the unit normal  at any given point XYZ, using the columns of the Jacobian matrix  of the element, tangents, and if necessary  also the finite element label, fe_label:\n\ngetnormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nThe buffer normalout is filled with the value  of the normal vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions::FInt)\n\nConstruct surface normal evaluator when the default calculation of the normal vector based  on the columns of the Jacobian matrix should be used. This function needs to have a signature of\n\nfunction computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt) \n    Calculate the normal and copy it into the buffer....\n    return normalout # return the buffer\nend\n\nand it needs to  fill in the buffer normalout with the current vector at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\nThe normal vector has ndimensions entries.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(vector::FVec{T}) where {T<:Number}\n\nConstruct surface normal vector when the constant normal vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F<:Function","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions::FInt, computenormal!::F) where {F<:Function}\n\nConstruct surface normal evaluator when the function to compute the normal vector is given. This function needs to have a signature of\n\nfunction computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    Calculate the normal and copy it into the buffer....\n    return normalout # return the buffer\nend\n\nand it needs to  fill in the buffer normalout with the current vector at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Force-intensity-1","page":"Types","title":"Force intensity","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity{T<:Number, F<:Function}\n\nDistributed force (force intensity) type. The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:\n\nforce/length^3 (when applied to a 3-D solid),\nforce/length^2 (when applied to a surface),\nforce/length^1 (when applied along a curve), or \nforce/length^0 (when applied at a point).\n\nSignature of the function to compute the value of the force  at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, and if necessary  also the finite element label, fe_label:\n\ngetforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nThe buffer forceout is filled with the value  of the force.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::FVec{T}) where {T<:Number}\n\nConstruct force intensity when the constant force vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F<:Function where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(::Type{T}, ndofn::FInt,\n  computeforce!::F) where {T<:Number, F<:Function}\n\nConstruct force intensity when the function to compute the intensity vector is given. This function needs to have a signature of\n\nfunction computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\nCalculate the force  and copy it into the buffer....\nreturn forceout\nend\n\nand it needs to  fill in the buffer forceout with the current force at the location XYZ, using if appropriate the information supplied in the Jacobian matrix tangents, and the label of the finite element, fe_label.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{T}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::T) where {T<:Number}\n\nConstruct force intensity when the force is given as a scalar value. The dimension of the force vector in this case is 1.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FEM-machines-1","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Base-1","page":"Types","title":"Base","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FEMMBaseModule.AbstractFEMM","page":"Types","title":"FinEtools.FEMMBaseModule.AbstractFEMM","text":"AbstractFEMM\n\nAbstract type for all finite element model machines.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nClass for base finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F<:Function where S<:AbstractFESet","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase(integdomain::IntegDomain{S, F}) where {S<:AbstractFESet, F<:Function}\n\nConstruct with the default orientation matrix (identity).  \n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Heat-diffusion-1","page":"Types","title":"Heat diffusion","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FEMMHeatDiffModule, FinEtools.FEMMHeatDiffSurfModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FEMMHeatDiffModule.FEMMHeatDiff","page":"Types","title":"FinEtools.FEMMHeatDiffModule.FEMMHeatDiff","text":"FEMMHeatDiff{S<:AbstractFESet, F<:Function, M<:MatHeatDiff} <: AbstractFEMM\n\nType for heat diffusion finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMHeatDiffModule.FEMMHeatDiff-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{IntegDomain{S,F},M}} where M<:MatHeatDiff where F<:Function where S<:AbstractFESet","page":"Types","title":"FinEtools.FEMMHeatDiffModule.FEMMHeatDiff","text":"FEMMHeatDiff(integdomain::IntegDomain{S, F}, material::M) where {S<:AbstractFESet, F<:Function, M<:MatHeatDiff}\n\nConstruct with the default orientation matrix (identity).  \n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.FEMMHeatDiffSurfModule.FEMMHeatDiffSurf","page":"Types","title":"FinEtools.FEMMHeatDiffSurfModule.FEMMHeatDiffSurf","text":"FEMMHeatDiffSurf{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for heat diffusion finite element modeling machine for boundary integrals.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Acoustics-1","page":"Types","title":"Acoustics","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FEMMAcoustModule, FinEtools.FEMMAcoustSurfModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FEMMAcoustModule.FEMMAcoust","page":"Types","title":"FinEtools.FEMMAcoustModule.FEMMAcoust","text":"FEMMAcoust{S<:AbstractFESet, F<:Function, M} <: AbstractFEMM\n\nType for linear acoustics finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf","page":"Types","title":"FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf","text":"FEMMAcoustSurf{S<:AbstractFESet, F<:Function, M, NF<:Function} <: AbstractFEMM\n\nClass for linear acoustics finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{IntegDomain{S,F},M}} where M where F<:Function where S<:AbstractFESet","page":"Types","title":"FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf","text":"FEMMAcoustSurf(integdomain::IntegDomain{S, F},  material::M) where {S<:AbstractFESet, F<:Function, M}\n\nCreate the FEMM for integrals over the surface. The normal is computed from the geometry of the surface elements.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Linear-deformation-1","page":"Types","title":"Linear deformation","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.DeforModelRedModule, FinEtools.FEMMDeforLinearBaseModule, FinEtools.FEMMDeforLinearModule, FinEtools.FEMMDeforWinklerModule, FinEtools.FEMMDeforLinearMSModule, FinEtools.FEMMDeforSurfaceDampingModule, FinEtools.FEMMDeforLinearNICEModule, FinEtools.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.DeforModelRedModule.AbstractDeforModelRed","page":"Types","title":"FinEtools.DeforModelRedModule.AbstractDeforModelRed","text":"AbstractDeforModelRed\n\nAbstract type of model reduction for deformation analysis.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DeforModelRedModule.DeforModelRed1D","page":"Types","title":"FinEtools.DeforModelRedModule.DeforModelRed1D","text":"DeforModelRed1D <: AbstractDeforModelRed\n\nModel reduction for 1-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DeforModelRedModule.DeforModelRed2DAxisymm","page":"Types","title":"FinEtools.DeforModelRedModule.DeforModelRed2DAxisymm","text":"DeforModelRed2DAxisymm <: AbstractDeforModelRed\n\nModel reduction for 2-D axially symmetric models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DeforModelRedModule.DeforModelRed2DStrain","page":"Types","title":"FinEtools.DeforModelRedModule.DeforModelRed2DStrain","text":"DeforModelRed2DStrain <: AbstractDeforModelRed\n\nModel reduction for 2-D plane strain models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DeforModelRedModule.DeforModelRed2DStress","page":"Types","title":"FinEtools.DeforModelRedModule.DeforModelRed2DStress","text":"DeforModelRed2DStress <: AbstractDeforModelRed\n\nModel reduction for 2-D plane stress models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DeforModelRedModule.DeforModelRed3D","page":"Types","title":"FinEtools.DeforModelRedModule.DeforModelRed3D","text":"DeforModelRed3D <: AbstractDeforModelRed\n\nModel reduction for 3-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","page":"Types","title":"FinEtools.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","text":"AbstractFEMMDeforLinear <: AbstractFEMMBase\n\nAbstract type of FEMM for linear deformation.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearModule.FEMMDeforLinear","page":"Types","title":"FinEtools.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear{MR<:AbstractDeforModelRed,  S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinear\n\nClass for linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearModule.FEMMDeforLinear-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{MR}, Tuple{Type{MR},IntegDomain{S,F},M}} where M<:AbstractMatDeforLinearElastic where F<:Function where S<:AbstractFESet where MR<:AbstractDeforModelRed","page":"Types","title":"FinEtools.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear(mr::Type{MR}, integdomain::IntegDomain{S, F}, material::M) where {MR<:AbstractDeforModelRed, S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic}\n\nConstructor of linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler","page":"Types","title":"FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler","text":"FEMMDeforWinkler{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for normal spring support  (Winkler).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","page":"Types","title":"FinEtools.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","text":"AbstractFEMMDeforLinearMS <: AbstractFEMMDeforLinear\n\nAbstract type for mean-strain linear deformation FEMM.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","page":"Types","title":"FinEtools.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","text":"FEMMDeforLinearMSH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on eight-node hexahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","page":"Types","title":"FinEtools.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","text":"FEMMDeforLinearMST10{MR<:AbstractDeforModelRed, S<:FESetT10, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on 10-node tetrahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","page":"Types","title":"FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","text":"FEMMDeforSurfaceDamping{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for surface damping model.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Types","title":"FinEtools.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","text":"AbstractFEMMDeforLinearNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","page":"Types","title":"FinEtools.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","text":"FEMMDeforLinearNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the eight-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","page":"Types","title":"FinEtools.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","text":"FEMMDeforLinearNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","page":"Types","title":"FinEtools.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","text":"AbstractFEMMDeforLinearESNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE) with energy-sampling stabilization.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","page":"Types","title":"FinEtools.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","text":"FEMMDeforLinearESNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 8-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","page":"Types","title":"FinEtools.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","text":"FEMMDeforLinearESNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models-1","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MatModule, FinEtools.MatHeatDiffModule, FinEtools.MatAcoustFluidModule,  FinEtools.MatDeforModule, \nFinEtools.MatDeforLinearElasticModule, FinEtools.MatDeforElastIsoModule, FinEtools.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.MatModule.AbstractMat","page":"Types","title":"FinEtools.MatModule.AbstractMat","text":"AbstractMat\n\nAbstract type of material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatHeatDiffModule.MatHeatDiff","page":"Types","title":"FinEtools.MatHeatDiffModule.MatHeatDiff","text":"MatHeatDiff{MTAN<:Function, MUPD<:Function} <: AbstractMat\n\nType of material model for heat diffusion.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatHeatDiffModule.MatHeatDiff-Tuple{Any}","page":"Types","title":"FinEtools.MatHeatDiffModule.MatHeatDiff","text":"MatHeatDiff(thermal_conductivity)\n\nConstruct material model for heat diffusion.\n\nSupply the matrix of thermal conductivity constants.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.MatAcoustFluidModule.MatAcoustFluid","page":"Types","title":"FinEtools.MatAcoustFluidModule.MatAcoustFluid","text":"MatAcoustFluid <: AbstractMat\n\nType for acoustic fluid material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatDeforModule.AbstractMatDefor","page":"Types","title":"FinEtools.MatDeforModule.AbstractMatDefor","text":"AbstractMatDefor\n\nAbstract type that represents deformable materials.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","page":"Types","title":"FinEtools.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","text":"AbstractMatDeforLinearElastic <: AbstractMatDefor\n\nAbstract Linear Elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatDeforElastIsoModule.MatDeforElastIso","page":"Types","title":"FinEtools.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso{MR<:AbstractDeforModelRed, MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear isotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho","page":"Types","title":"FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho{MR<:AbstractDeforModelRed,  MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear orthotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/functions.html#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#Physical-units-1","page":"Functions","title":"Physical units","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.PhysicalUnitModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.PhysicalUnitModule.phun-Tuple{String}","page":"Functions","title":"FinEtools.PhysicalUnitModule.phun","text":"phun(str::String; system_of_units = :SI, base_time_units = :SEC)\n\nEvaluate an expression in physical units.\n\nExample\n\npu = ustring -> phun(ustring; system_of_units = :SIMM)\nE1s = 130.0*pu(\"GPa\")\n\nyields 1.3e+5 (in mega Pascal) whereas\n\n130.0*phun(\"GPa\"; system_of_units = :SI)\n\nyields 1.3e+11 (in Pascal)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Bounding-box-functions-1","page":"Functions","title":"Bounding box functions","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.BoxModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.boundingbox","text":"boundingbox(x::AbstractArray)\n\nCompute the bounding box of the points in x.\n\nx = holds points, one per row.\n\nReturns box = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.boxesoverlap-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.boxesoverlap","text":"boxesoverlap(box1::AbstractVector, box2::AbstractVector)\n\nDo the given boxes overlap?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.inbox-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.inbox","text":"inbox(box::AbstractVector, x::AbstractVector)\n\nIs the given location inside the box?\n\nbox = vector entries arranged as minx,maxx,miny,maxy,minz,maxz.\n\nNote: point on the boundary of the box is counted as being inside.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.initbox!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.initbox!","text":"initbox!(box::AbstractVector, x::AbstractVector)\n\nInitialize a bounding box with a single point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.intersectboxes-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Functions","title":"FinEtools.BoxModule.intersectboxes","text":"intersectboxes(box1::AbstractVector, box2::AbstractVector)\n\nCompute the intersection of two boxes.  \n\nThe function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.updatebox!-Tuple{AbstractArray{T,1} where T,AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.updatebox!","text":"updatebox!(box::AbstractVector, x::AbstractArray)\n\nUpdate a box with another location, or create a new box.\n\nIf the  box does not have  the correct dimensions,  it is correctly sized.\n\nbox = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]     The box is expanded to include the     supplied location x.   The variable x  can hold multiple points in rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Coordinate-systems-1","page":"Functions","title":"Coordinate systems","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.CSysModule.gen_iso_csmat!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.CSysModule.gen_iso_csmat!","text":"gen_iso_csmat(XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nCompute the coordinate system  for an isotropic material using information available  by looking at the coordinate curves of isoparametric finite elements.\n\nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element, \nfe_label= finite element label.\n\nThe basic assumption here is that the material is isotropic, and therefore the choice of the material directions does not really matter as long as they correspond to the dimensionality of the element. For instance a one-dimensional element (L2 as an example) may be embedded in a three-dimensional space.\n\nThis function assumes that it is being called for an mdim-dimensional manifold element, which is embedded in a sdim-dimensional Euclidean space. If mdim == sdim, the coordinate system matrix is the identity; otherwise the local coordinate directions are aligned with the linear subspace defined by the tangent vectors.\n\nwarning: Warning\n\n\nThis cannot be reliably used to produce consistent stresses because each quadrature point gets a local coordinate system which depends on the orientation of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.CSysModule.updatecsmat!-Tuple{CSys,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.CSysModule.updatecsmat!","text":"function updatecsmat!(self::CSys, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the coordinate system orientation matrix.\n\nThe  coordinate system matrix is updated based upon the location XYZ of the evaluation point, and possibly on the Jacobian matrix tangents within the element in which the coordinate system matrix is evaluated,  or perhaps on the label fe_label of the finite element.\n\nAfter this function returns, the coordinate system matrix can be retrieved from the buffer as self.csmat.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Matrix-utilities-1","page":"Functions","title":"Matrix utilities","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatrixUtilityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btdb_ut_only!","text":"add_btdb_ut_only!(Ke::FFltMat, B::FFltMat, Jac_w::FFlt,\n              D::FFltMat, DB::FFltMat)\n\nAdd the product  (B'*(D*(Jac*w[j]))*B), to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrices B and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1},Float64}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btv!","text":"add_btv!(elvec::FFltVec, B::FFltMat, sig::FFltMat, Jac_w_coeff::FFlt)\n\nAdd product of the strain-displacement matrix transpose times the stress vector.\n\nNote:  the coefficient Jac_w_coeff will be typically  NEGATIVE.\n\nThe argument elvec needs to be suitably  initialized before the first call  (filled with zeros, for instance),  and it is updated upon return. The arguments B, sig are not modified.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_gkgt_ut_only!","text":"add_gkgt_ut_only!(Ke::FFltMat, gradN::FFltMat, Jac_w::FFlt,\n  kappa_bar::FFltMat, kappa_bargradNT::FFltMat)\n\nAdd the product gradN*kappa_bar*gradNT*(Jac*w[j]) to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nUpon return,  the matrix Ke is updated.  The scratch buffer kappa_bargradNT  is overwritten during each call of this function. The matrices gradN and  kappa_bar are not modified inside this function. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_mggt_ut_only!","text":"add_mggt_ut_only!(Ke::FFltMat, gradN::FFltMat, mult::FFlt)\n\nAdd the product gradN*mult*gradNT*(Jac*w[j]) to the elementwise matrix Ke. The argument mult is a scalar. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrix gradN is not modified inside this function. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Array{T,2},Array{Float64,2},T}} where T<:Number","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_nnt_ut_only!","text":"add_nnt_ut_only!(Ke::FFltMat, Nn::FFltMat, Jac_w_coeff::FFlt)\n\nAdd the product  Nn*(Nn'*(coeff*(Jac*w(j))), to the elementwise matrix Ke. Only upper triangle is computed; the lower triangle is not touched.\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrix Nn is not modified inside this function. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any,Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.adjugate3!","text":"adjugate3!(B, A)\n\nCompute the adjugate matrix of A.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.complete_lt!-Tuple{Array{Float64,2}}","page":"Functions","title":"FinEtools.MatrixUtilityModule.complete_lt!","text":"complete_lt!(Ke::FFltMat)\n\nComplete the lower triangle of the elementwise matrix Ke.\n\nThe matrix Ke is modified  inside this function. The  upper-triangle  entries  are copied  across the diagonal  to the lower triangle.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.jac!-Union{Tuple{C}, Tuple{Array{Float64,2},Array{Float64,2},C,Array{Float64,2}}} where C","page":"Functions","title":"FinEtools.MatrixUtilityModule.jac!","text":"jac!(J::FFltMat, X::FFltMat, conn::C, gradNparams::FFltMat) where {C}\n\nCompute the Jacobian matrix at the quadrature point.  \n\nArguments:  J = Jacobian matrix, overwritten  inside the function X = matrix of the node coordinates from the entire mesh, index      with the connectivity conn conn = connectivity, indexes the matrix X gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.loc!-Union{Tuple{C}, Tuple{Array{Float64,2},Array{Float64,2},C,Array{Float64,2}}} where C","page":"Functions","title":"FinEtools.MatrixUtilityModule.loc!","text":"loc!(loc::FFltMat, X::FFltMat, conn::C, N::FFltMat) where {C}\n\nCompute the location of the quadrature point.  \n\nArguments:  loc = matrix of coordinates, overwritten  inside the function X = matrix of the node coordinates from the entire mesh, index      with the connectivity conn conn = connectivity, indexes the matrix X N = matrix of basis function values\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.locjac!-Union{Tuple{C}, Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},C,Array{Float64,2},Array{Float64,2}}} where C","page":"Functions","title":"FinEtools.MatrixUtilityModule.locjac!","text":"locjac!(loc::FFltMat, J::FFltMat, X::FFltMat, conn::C, N::FFltMat, gradNparams::FFltMat) where {C}\n\nCompute location and Jacobian matrix at the quadrature point.  \n\nArguments:  loc = matrix of coordinates, overwritten  inside the function J = Jacobian matrix, overwritten  inside the function X = matrix of the node coordinates from the entire mesh, index      with the connectivity conn conn = connectivity, indexes the matrix X N = matrix of basis function values gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-sets-1","page":"Functions","title":"Finite element sets","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.cat-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFESet","page":"Functions","title":"Base.cat","text":"cat(self::T,  other::T) where {T<:AbstractFESet}\n\nConcatenate the connectivities of two FE sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.count-Union{Tuple{T}, Tuple{T}} where T<:AbstractFESet","page":"Functions","title":"Base.count","text":"count(self::T)::FInt where {T<:AbstractFESet}\n\nGet the number of individual connectivities in the FE set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet1Manifold}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet1Manifold}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet2Manifold}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::T, J::FFltMat)::FFlt where {T<:AbstractFESet3Manifold}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.bfun","text":"bfun(self::T,  param_coords::FFltVec)::FFltMat where {T<:AbstractFESet}\n\nCompute the values of the basis functions at a given parametric coordinate. One basis function per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.bfundpar","text":"bfundpar(self::T,  param_coords::FFltVec)::FFltMat where {T<:AbstractFESet}\n\nCompute the values of the basis function gradients with respect to the parametric coordinates at a given parametric coordinate. One basis function gradients per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryconn-Union{Tuple{T}, Tuple{T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryconn","text":"boundaryconn(self::T) where {T<:AbstractFESet}\n\nGet boundary connectivity.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryfe-Union{Tuple{T}, Tuple{T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryfe","text":"boundaryfe(self::T) where {T<:AbstractFESet}\n\nReturn the constructor of the type of the boundary finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.centroidparametric-Union{Tuple{T}, Tuple{T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.centroidparametric","text":"centroidparametric(self::T) where {T<:AbstractFESet}\n\nReturn the parametric coordinates  of the centroid of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.connasarray","text":"connasarray(self::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nReturn the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM},Array{Int64,2}}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.fromarray!","text":"fromarray!(self::AbstractFESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}\n\nSet  the connectivity from an integer array.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet1Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet1Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet2Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet2Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet3Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(self::AbstractFESet3Manifold, gradN::FFltMat, gradNparams::FFltMat,\n  redJ::FFltMat)\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.inparametric-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.inparametric","text":"inparametric(self::AbstractFESet, param_coords::FFltVec)\n\nAre given parametric coordinates inside the element parametric domain?\n\nReturn a Boolean: is the point inside, true or false?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.manifdim","text":"manifdim(me)\n\nGet the manifold dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.map2parametric-Union{Tuple{T}, Tuple{T,Array{Float64,2},Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.map2parametric","text":"map2parametric(self::T, x::FFltMat, pt::FFltVec;\n    tolerance = 0.001, maxiter =5) where {T<:AbstractFESet}\n\nMap a spatial location to parametric coordinates.\n\nx=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,\nc= spatial location\ntolerance = tolerance in parametric coordinates; default is 0.001.\n\nReturn\n\nsuccess = Boolean flag, true if successful, false otherwise.\npc = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.nodesperelem","text":"nodesperelem(fes::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nProvide the number of nodes per element.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::T, val::FIntVec) where {T<:AbstractFESet}\n\nSet the labels of individual elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Int64}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::T, val::FInt) where {T<:AbstractFESet}\n\nSet the label of the entire finite elements set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.subset-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.subset","text":"subset(self::T, L::FIntVec) where {T<:AbstractFESet}\n\nExtract a subset of the finite elements from the given finite element set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.updateconn!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.updateconn!","text":"updateconn!(self::T, newids::FIntVec) where {T<:AbstractFESet}\n\nUpdate the connectivity after the IDs of nodes changed.\n\nnewids= new node IDs. Note that indexes in the conn array \"point\" into the  newids array. After the connectivity was updated this will no longer be true!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-nodes-1","page":"Functions","title":"Finite element nodes","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.count-Tuple{FENodeSet}","page":"Functions","title":"Base.count","text":"count(self::FENodeSet)\n\nGet the number of finite element nodes in the node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.spacedim","text":"spacedim(self::FENodeSet)\n\nNumber of dimensions of the space in which the node lives, 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.xyz3","text":"xyz3(self::FENodeSet)\n\nGet the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-node-to-element-map-1","page":"Functions","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Selecting-nodes-and-elements-1","page":"Functions","title":"Selecting nodes and elements","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshSelectionModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectedelems-Tuple{AbstractFESet,Array{Int64,1},Int64}","page":"Functions","title":"FinEtools.MeshSelectionModule.connectedelems","text":"connectedelems(fes::AbstractFESet, node_list::FIntVec)\n\nExtract the list of numbers for the fes  that are connected to given nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.connectednodes","text":"connectednodes(fes::AbstractFESet)\n\nExtract the node numbers of the nodes  connected by given finite elements.\n\nExtract the list of unique node numbers for the nodes that are connected by the finite element set fes. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet,AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.findunconnnodes","text":"findunconnnodes(fens::FENodeSet, fes::AbstractFESet)\n\nFind nodes that are not connected to any finite element.\n\nconnected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectelem-Union{Tuple{T}, Tuple{FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshSelectionModule.selectelem","text":"selectelem(fens::FENodeSet, fes::T; kwargs...) where {T<:AbstractFESet}\n\nSelect finite elements.\n\nSelection criteria\n\nfacing\n\nSelect all \"boundary\" elements that \"face\" a certain direction.\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);\n\nor\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);\n\nwhere\n\nfunction dout(xyz)\n    return xyz/norm(xyz)\nend\n\nand xyz is the location of the centroid  of  a boundary element. Here the finite element is considered \"facing\" in the given direction if the dot product of its normal and the direction vector is greater than dotmin. The default value for dotmin is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).\n\nThis selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).\n\nlabel\n\nSelect elements based on their label.\n\nrl1 = selectelem(fens, fes, label=1)\n\nbox, distance\n\nSelect elements based on some criteria that their nodes satisfy.  See the function selectnode().\n\nExample: Select all  elements whose nodes are closer than R+inflate from the point from.\n\nlinner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],\n  inflate = tolerance)\n\nExample:\n\nexteriorbfl = selectelem(fens, bdryfes,\n   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);\n\nflood\n\nSelect all FEs connected together, starting from a given node.\n\nExample: Select all FEs connected together (Starting from node 13):\n\nl = selectelem(fens, fes, flood = true, startnode = 13)\n\nOptional keyword arguments\n\nShould we consider the element only if all its nodes are in? allin = Boolean: if true, then all nodes of an element must satisfy the     criterion; otherwise  one is enough.\n\nOutput\n\nfelist = list of finite elements from the set that satisfy the criteria\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.MeshSelectionModule.selectnode","text":"selectnode(fens::FENodeSet; kwargs...)\n\nSelect nodes using some criterion.\n\nSee the function vselect() for examples of the criteria.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.vselect-Tuple{Array{Float64,2}}","page":"Functions","title":"FinEtools.MeshSelectionModule.vselect","text":"vselect(v::FFltMat; kwargs...)\n\nSelect locations (vertices) from the array based on some criterion.\n\nArguments\n\nv = array of locations, one location per row kwargs = pairs of keyword argument/value\n\nSelection criteria\n\nbox\n\nnLx = vselect(fens.xyz, box = [0.0 Lx  0.0 0.0 0.0 0.0], inflate = Lx/1.0e5)\n\nThe keyword 'inflate' may be used to increase or decrease the extent of the box (or the distance) to make sure some nodes which would be on the boundary are either excluded or included.\n\ndistance\n\nlist = selectnode(fens.xyz, distance=1.0+0.1/2^nref, from=[0. 0.],\n        inflate=tolerance);\n\nplane\n\ncandidates = selectnode(fens, plane = [0.0 0.0 1.0 0.0], thickness = h/1000)\n\nThe keyword plane defines the plane by its normal (the first two or three numbers)  and its distance from the origin (the last number). Nodes are selected they lie  on the plane,  or near the plane within the distance thickness from the plane.  The normal is assumed to be of unit length, if it isn't apply as such, it will be  normalized internally.\n\nnearestto\n\nnh = selectnode(fens, nearestto = [R+Ro/2, 0.0, 0.0] )\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Fields-1","page":"Functions","title":"Fields","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.copyto!-Union{Tuple{F}, Tuple{F,F}} where F<:AbstractField","page":"Functions","title":"Base.copyto!","text":"copyto!(DEST::F,  SRC::F) where {F<:AbstractField}\n\nCopy data from one field to another.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.applyebc!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.applyebc!","text":"applyebc!(self::AbstractField)\n\nApply EBCs (essential boundary conditions).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{AbstractField,A,CC}} where CC where A","page":"Functions","title":"FinEtools.FieldModule.gatherdofnums!","text":"gatherdofnums!(self::AbstractField, dest::A, conn::CC) where {A, CC}\n\nGather dofnums from the field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asmat!","text":"gatherfixedvalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},\n    conn::CC) where {CC, T}\n\nGather FIXED values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asvec!","text":"gatherfixedvalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},\n    conn::CC) where {CC, T}\n\nGather FIXED values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F,Array{T,1}}} where T where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.gathersysvec!","text":"gathersysvec!(self::F, vec::FVec{T}) where {F<:AbstractField, T}\n\nGather values from the field for the whole system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F}} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.gathersysvec","text":"gathersysvec{F<:AbstractField}(self::F)\n\nGather values from the field for the whole system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asmat!","text":"gathervalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},\n    conn::CC) where {CC, T}\n\nGather values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asvec!","text":"gathervalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},\n    conn::CC) where {CC, T}\n\nGather values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.ndofs-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.ndofs","text":"ndofs{F<:AbstractField}(self::T)\n\nDimension of the degree of freedom parameters (i. e. how many degrees of freedom per entity).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nents-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.nents","text":"nents{F<:AbstractField}(self::F)\n\nNumber of nodes associated with the field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.numberdofs!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.numberdofs!","text":"numberdofs!(self::AbstractField)\n\nNumber the degrees of freedom.\n\nThe free components in the field are numbered consecutively. No effort is made to optimize the numbering in any way. If you'd like to optimize the numbering of the degrees of freedom, use the above form that sets the permutation of the degrees of freedom, or the permutation of the nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.prescribeddofs-Tuple{AbstractField,AbstractField}","page":"Functions","title":"FinEtools.FieldModule.prescribeddofs","text":"prescribeddofs(uebc, u)\n\nFind which degrees of freedom are prescribed. uebc = field which defines the constraints (is the dof fixed and to which value), u = field which does not have the constraints applied, and serves as the source of equation numbers, uebc and u may be one and the same field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.scattersysvec!","text":"scattersysvec!(self::AbstractField, vec::FVec{T}) where {T<:Number}\n\nScatter values to the field from a system vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Array{Int64,1}}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec)\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given nodes.\n\nfenids         - array of N node identifiers\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Int64}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenid::FInt)\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given node.\n\nfenid         - One integer as a node identifier\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField)\n\nSet the EBCs (essential boundary conditions).\n\nAll essential boundary conditions are CLEARED.\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt,\n  val::FVec{T}) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,T}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt,\n  val::T) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt;\n  val::T=0.0) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64,Array{T,1}}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, comp::FInt,\n  val::FVec{T}) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64}} where T<:Number","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::AbstractField, fenids::FIntVec, comp::FInt;\n  val::T=0.0) where {T<:Number}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.wipe!-Tuple{AbstractField}","page":"Functions","title":"FinEtools.FieldModule.wipe!","text":"wipe!(self::AbstractField)\n\nWipe all the data from the field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}","page":"Functions","title":"FinEtools.NodalFieldModule.nnodes","text":"nnodes(self::NodalField)::FInt = nents(self)\n\nProvide the number of nodes  in the nodal field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}","page":"Functions","title":"FinEtools.ElementalFieldModule.nelems","text":"nelems(self::ElementalField)::FInt = nents(self)\n\nProvide the number of elements  in the elemental field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Integration-rule-1","page":"Functions","title":"Integration rule","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Integration-domain-1","page":"Functions","title":"Integration domain","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(self::IntegDomain{T}, J::FFltMat,\n    loc::FFltMat, conn::CC,\n    N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(self::IntegDomain{T}, J::FFltMat,\n          loc::FFltMat, conn::CC,\n          N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\n  loc::FFltMat, conn::CC,\n  N::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 0-dimensional finite element,  the manifold Jacobian is for\n\nm=0: +1\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\nloc::FFltMat, conn::CC,\nN::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 1-dimensional finite element,  the manifold Jacobian is for\n\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat, m::FInt)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 2-dimensional finite element,  the manifold Jacobian is for\n\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim{T<:AbstractFESet3Manifold}(self::IntegDomain, J::FFltMat,\n            loc::FFltMat, conn::FIntMat, N::FFltMat, m::FInt)\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 3-dimensional cell,  the manifold Jacobian is\n\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianpoint","text":"Jacobianpoint(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nFor the zero-dimensional cell,  the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc times the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nFor the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n             N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the surface Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet0Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n      loc::FFltMat, conn::CC,\n      N::FFltMat)::FFlt where {T<:AbstractFESet0Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the zero-dimensional cell,  the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc and the other dimension (units of length squared).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet1Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet1Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc and the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet2Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nFor the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point loc (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F<:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T<:AbstractFESet3Manifold","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(self::IntegDomain{T}, J::FFltMat,\n            loc::FFltMat, conn::CC,\n            N::FFltMat)::FFlt where {T<:AbstractFESet3Manifold, CC}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Tuple{IntegDomain}","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(self::IntegDomain)\n\nCalculate the data needed for  numerical quadrature for the integration rule     stored by the integration domain.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Union{Tuple{T}, Tuple{IntegDomain,T}} where T<:AbstractIntegRule","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(self::IntegDomain, integration_rule::T) where {T<:AbstractIntegRule}\n\nCalculate the data needed for numerical quadrature.\n\nFor given integration domain, compute the quantities needed for numerical integration.\n\nReturn\n\nnpts, Ns, gradNparams, w, pc = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{CC}, Tuple{Array{Float64,2},CC,Array{Float64,2}}} where CC","page":"Functions","title":"FinEtools.IntegDomainModule.otherdimensionunity","text":"otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt\n          where {CC}\n\nEvaluate the other dimension: default is 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Assembly-of-matrices-and-vectors-1","page":"Functions","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SysvecAssembler{T},MV,D}} where D<:(AbstractArray{Int64,N} where N) where MV<:(AbstractArray{T,N} where N) where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssembler{T}, vec::MV,\n  dofnums::D) where {T<:Number, MV<:AbstractArray{T}, D<:AbstractArray{FInt}}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},\n  dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble a HRZ-lumped square symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},\n    dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble an HRZ-lumped square symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},  dofnums::FIntVec, ignore::FIntVec) where {T<:Number}\n\nAssemble a square symmetric matrix.\n\ndofnums are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},\n  dofnums::FIntMat, ignore::FIntMat) where {T<:Number}\n\nAssemble a square symmetric matrix.\n\ndofnums are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerSparse{T}, mat::FMat{T},\n  dofnums_row::FIntMat, dofnums_col::FIntMat) where {T<:Number}\n\nAssemble a rectangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)\n\nMake a sparse HRZ-lumped symmetric square  matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseSymm)\n\nMake a sparse symmetric square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparse)\n\nMake a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},\n  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,\n  ndofs::FInt, ignore2::FInt) where {T<:Number}\n\nStart the assembly of a symmetric lumped square global matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseSymm{T},\n  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,\n  ndofs::FInt, ignore2::FInt) where {T<:Number}\n\nStart the assembly of a symmetric square global matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Int64,Int64,Int64,Int64,Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparse{T},\n  elem_mat_nrows::FInt, elem_mat_ncols::FInt, elem_mat_nmatrices::FInt,\n  ndofs_row::FInt, ndofs_col::FInt) where {T<:Number}\n\nStart the assembly of a global matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysvecAssembler{T},Int64}} where T<:Number","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssembler{T},\n  ndofs_row::FInt) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nndofs_row= Total number of degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-1","page":"Functions","title":"Meshing","text":"","category":"section"},{"location":"man/functions.html#Mesh-import/export-1","page":"Functions","title":"Mesh import/export","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshImportModule, FinEtools.MeshExportModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_ABAQUS","text":"import_ABAQUS(filename)\n\nImport tetrahedral (4- and 10-node) or hexahedral (8- and 20-node) Abaqus mesh (.inp file).\n\nLimitations:\n\nOnly the *NODE and *ELEMENT  sections are read\nOnly 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 3-node triangles  are handled.\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" (finite element nodes), \n\"fesets\" (array of finite element sets).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_NASTRAN","text":"import_NASTRAN(filename)\n\nImport tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).\n\nLimitations:\n\nonly the GRID and CTETRA  sections are read.\nOnly 4-node and 10-node tetrahedra  are handled.\nThe file should be free-form (data separated by commas). \n\nSome fixed-format files can also be processed (large-field, but not small-field).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" (finite element nodes), \n\"fesets\" (array of finite element sets).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.close-Tuple{AbaqusExporter}","page":"Functions","title":"Base.close","text":"close(self::AbaqusExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.close-Tuple{NASTRANExporter}","page":"Functions","title":"Base.close","text":"close(self::NASTRANExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.close-Tuple{STLExporter}","page":"Functions","title":"Base.close","text":"close(self::STLExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ASSEMBLY-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.ASSEMBLY","text":"ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.BEGIN_BULK-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.BEGIN_BULK","text":"BEGIN_BULK(self::NASTRANExporter)\n\nTerminate the Case Control section by starting the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)\n\nWrite out the *BOUNDARY option to fix displacements at zero for a node set.\n\nInvoke at Level: Model,  Step\n\nNSET= node set, dof=Degree of freedom, 1, 2, 3\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  value::F) where {F}\n\nWrite out the *BOUNDARY option to fix displacements at nonzero value for a node set.\n\nNSET= node set, dof=Degree of freedom, 1, 2, 3\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,AbstractString,AbstractArray{B,2},AbstractArray{F,2}}} where F where B","page":"Functions","title":"FinEtools.MeshExportModule.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString,\n    is_fixed::AbstractArray{B,2},  fixed_value::AbstractArray{F,2}) where {B, F}\n\nWrite out the *BOUNDARY option.\n\nis_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, fixed_value=array of displacements to which the corresponding displacement components is fixed\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.CEND-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.CEND","text":"CEND(self::NASTRANExporter)\n\nTerminate the Executive Control section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.CLOAD","text":"CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nNSET=Node set dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,Integer,Integer,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.CLOAD","text":"CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nnodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.COMMENT-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.COMMENT","text":"COMMENT(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the ** comment option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.DENSITY-Tuple{AbaqusExporter,Any}","page":"Functions","title":"FinEtools.MeshExportModule.DENSITY","text":"DENSITY(self::AbaqusExporter, rho)\n\nWrite out the *DENSITY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractArray{F,1}}} where F","page":"Functions","title":"FinEtools.MeshExportModule.DLOAD","text":"DLOAD(self::AbaqusExporter, ELSET::AbstractString,\n  traction::AbstractVector{F}) where {F}\n\nWrite out the *DLOAD option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F,F,F,F,F,F,F,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,\n  G12::F, G13::F, G23::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ENGINEERING CONSTANTS option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ISOTROPIC option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractString,Integer,AbstractArray{T,2}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.ELEMENT","text":"ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,\n  start::Integer, conn::AbstractArray{T, 2}) where {T<:Integer}\n\nWrite out the *ELEMENT option.\n\nTYPE= element type code, ELSET= element set to which the elements belong, start= start the element numbering at this integer, conn= connectivity array for the elements, one row per element\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.ELSET_ELSET","text":"ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T<:Integer}\n\nWrite out the *ELSET option.\n\nELSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.EL_PRINT-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.EL_PRINT","text":"EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)\n\nWrite out the *EL PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ENDDATA-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.ENDDATA","text":"ENDDATA(self::NASTRANExporter)\n\nTerminate the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.END_ASSEMBLY-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.END_ASSEMBLY","text":"END_ASSEMBLY(self::AbaqusExporter)\n\nWrite out the *END ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.END_INSTANCE-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.END_INSTANCE","text":"END_INSTANCE(self::AbaqusExporter)\n\nWrite out the *END INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.END_PART-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.END_PART","text":"END_PART(self::AbaqusExporter)\n\nWrite out the *END PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.END_STEP-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.END_STEP","text":"END_STEP(self::AbaqusExporter)\n\nWrite out the *END STEP option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ENERGY_PRINT-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.ENERGY_PRINT","text":"ENERGY_PRINT(self::AbaqusExporter)\n\nWrite out the *ENERGY PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.EXPANSION","text":"EXPANSION(self::AbaqusExporter, CTE::F) where {F}\n\nWrite out the *EXPANSION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.GRID-Tuple{NASTRANExporter,Int64,Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshExportModule.GRID","text":"GRID(self::NASTRANExporter, n::Int, xyz::Vector{FFlt})\n\nWrite a grid-point statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.HEADING-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.HEADING","text":"HEADING(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the *HEADING option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.INSTANCE-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.INSTANCE","text":"INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)\n\nWrite out the *INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.MAT1","page":"Functions","title":"FinEtools.MeshExportModule.MAT1","text":"MAT1(self::NASTRANExporter, mid::Int, E::FFlt, nu::FFlt, rho::FFlt = 0.0, A::FFlt = 0.0, TREF::FFlt = 0.0)\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshExportModule.MAT1-Tuple{NASTRANExporter,Int64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Functions","title":"FinEtools.MeshExportModule.MAT1","text":"MAT1(self::NASTRANExporter, mid::Int, E::FFlt, G::FFlt, nu::FFlt, rho::FFlt, A::FFlt, TREF::FFlt, GE::FFlt)\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.MATERIAL-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.MATERIAL","text":"MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)\n\nWrite out the *MATERIAL option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NODE-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractArray{T,2}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.NODE","text":"NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}\n\nWrite out the *NODE option.\n\nxyz=array of node coordinates\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NODE_PRINT-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.NODE_PRINT","text":"NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)\n\nWrite out the *NODE PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.NSET_NSET","text":"NSET_NSET(self::AbaqusExporter, NSET::AbstractString,\n  n::AbstractVector{T}) where {T<:Integer}\n\nWrite out the *NSET option.\n\nNSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1},AbstractArray{T,1}}} where T<:Real","page":"Functions","title":"FinEtools.MeshExportModule.ORIENTATION","text":"ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,\n  a::AbstractArray{T,1}, b::AbstractArray{T,1})\n\nWrite out the *ORIENTATION option.\n\nInvoke at level: Part,  Part instance,  Assembly\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.PART-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.PART","text":"PART(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.PSOLID-Tuple{NASTRANExporter,Int64,Int64}","page":"Functions","title":"FinEtools.MeshExportModule.PSOLID","text":"PSOLID(self::NASTRANExporter, pid::Int, mid::Int)\n\nWrite solid-property statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.SECTION_CONTROLS-Tuple{AbaqusExporter,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.SECTION_CONTROLS","text":"SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,\n  OPTIONAL::AbstractString)\n\nWrite out the *SECTION CONTROLS option.\n\nOPTIONAL = string, for instance                      HOURGLASS=ENHANCED\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString,\n  CONTROLS::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.STEP_FREQUENCY-Tuple{AbaqusExporter,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.STEP_FREQUENCY","text":"STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)\n\nWrite out the *STEP,FREQUENCY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter,Integer}","page":"Functions","title":"FinEtools.MeshExportModule.STEP_PERTURBATION_BUCKLE","text":"STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)\n\nWrite out the *STEP,PERTURBATION option for linear buckling analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.STEP_PERTURBATION_STATIC","text":"STEP_PERTURBATION_STATIC(self::AbaqusExporter)\n\nWrite out the *STEP,PERTURBATION option for linear static analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.SURFACE_SECTION-Tuple{AbaqusExporter,AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.SURFACE_SECTION","text":"SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)\n\nWrite out the *SURFACE SECTION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter,AbstractString,AbstractArray{I,1},AbstractArray{F,1}}} where F where I","page":"Functions","title":"FinEtools.MeshExportModule.TEMPERATURE","text":"TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},\n  tlist::AbstractArray{F, 1}) where {I, F}\n\nWrite out the *TEMPERATURE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.savecsv-Tuple{String}","page":"Functions","title":"FinEtools.MeshExportModule.savecsv","text":"savecsv(name::String; kwargs...)\n\nSave arrays as a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.vtkexportmesh-Tuple{String,Any,Any,Any}","page":"Functions","title":"FinEtools.MeshExportModule.vtkexportmesh","text":"vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;\n    vectors=nothing, scalars=nothing)\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nopts = keyword argument list, where scalars = array of tuples, (name, data) vectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.vtkexportmesh-Union{Tuple{T}, Tuple{String,FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.vtkexportmesh","text":"vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T<:AbstractFESet}\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nopts = keyword argument list, where scalars = array of tuples, (name, data) vectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.vtkexportvectors-Tuple{String,Any,Any}","page":"Functions","title":"FinEtools.MeshExportModule.vtkexportvectors","text":"vtkexportvectors(theFile::String, Points, vectors)\n\nExport vector data to a VTK 1.0 file.\n\nPoints = array of collection of coordinates (tuples or vectors), \nvectors = array of tuples, (name, data), where name is a string, and data is array of collection of coordinates (tuples or vectors).\n\nExample\n\nPoints = [(1.0, 3.0), (0.0, -1.0)]\nvectors = [(\"v\", [(-1.0, -2.0), (1.0, 1.0)])]\nvtkexportvectors(\"theFile.VTK\", Points, vectors)\n\nwill produce file with\n\n# vtk DataFile Version 1.0\nFinEtools Export\nASCII\n\nDATASET UNSTRUCTURED_GRID\nPOINTS 2 double\n1.0 3.0 0.0\n0.0 -1.0 0.0\n\n\nPOINT_DATA 2\nVECTORS v double\n-1.0 -2.0 0.0\n1.0 1.0 0.0\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-line-elements-1","page":"Functions","title":"Meshing with line elements","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshLineModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2block-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshLineModule.L2block","text":"L2block(Length::FFlt, nL::FInt)\n\nMesh of a 1-D block of L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2blockx-Tuple{Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshLineModule.L2blockx","text":"L2blockx(xs::FFltVec)\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L3blockx-Tuple{Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshLineModule.L3blockx","text":"L3blockx(xs::FFltVec)\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-triangles-1","page":"Functions","title":"Meshing with triangles","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTriangleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.Q4toT3","page":"Functions","title":"FinEtools.MeshTriangleModule.Q4toT3","text":"Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)\n\nConvert a mesh of quadrilateral Q4's to two T3 triangles  each.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3annulus","page":"Functions","title":"FinEtools.MeshTriangleModule.T3annulus","text":"T3annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3block","page":"Functions","title":"FinEtools.MeshTriangleModule.T3block","text":"T3block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)\n\nT3 Mesh of a rectangle.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3blockx","page":"Functions","title":"FinEtools.MeshTriangleModule.T3blockx","text":"T3blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)\n\nT3 Mesh of a rectangle.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet,FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3refine","text":"T3refine(fens::FENodeSet,fes::FESetT3)\n\nRefine a mesh of 3-node triangles by quadrisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet,FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3toT6","text":"T3toT6(fens::FENodeSet, fes::FESetT3)\n\nConvert a mesh of triangle T3 (three-node) to triangle T6.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6annulus","page":"Functions","title":"FinEtools.MeshTriangleModule.T6annulus","text":"T6annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6block","page":"Functions","title":"FinEtools.MeshTriangleModule.T6block","text":"T6block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)\n\nMesh of a rectangle of T6 elements.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6blockx","page":"Functions","title":"FinEtools.MeshTriangleModule.T6blockx","text":"T6blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)\n\nGraded mesh of a 2-D block of T6 finite elements.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#Meshing-with-quadrilaterals-1","page":"Functions","title":"Meshing with quadrilaterals","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshQuadrilateralModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4annulus-Tuple{Float64,Float64,Int64,Int64,Float64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4annulus","text":"Q4annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4block-Tuple{Float64,Float64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4block","text":"Q4block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)\n\nMesh of a rectangle, Q4 elements.\n\nDivided into elements: nL, nW in the first, second (x,y).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4blockx-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4blockx","text":"Q4blockx(xs::FFltVec, ys::FFltVec)\n\nGraded mesh  of a rectangle, Q4 finite elements.\n\nMesh of a 2-D block, Q4 finite elements. The nodes are located at the\nCartesian product of the two intervals on the input.  This allows for\nconstruction of graded meshes.\n\nxs,ys - Locations of the individual planes of nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4circlen-Tuple{Float64,Any}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4circlen","text":"Q4circlen(radius::FFlt, nperradius::FFlt)\n\nMesh of a quarter circle with a given number of elements per radius.\n\nThe parameter nperradius should be an even  number; if that isn't so is adjusted to by adding one. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4elliphole-Tuple{Float64,Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4elliphole","text":"Q4elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt,\n  nL::FInt, nH::FInt, nW::FInt)\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radius of the ellipse,\nL,H= and dimensions of the plate,\nnL,nH= numbers of edges along the side of the plate; this also happens\n  to be the number of edges along the circumference of the elliptical\n  hole\nnW= number of edges along the remaining straight edge (from the hole\n  in the direction of the length),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Tuple{Array{Float64,2},Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4quadrilateral","text":"Q4quadrilateral(xyz::FFltMat, nL::FInt, nW::FInt)\n\nMesh of a general quadrilateral given by the location of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet,FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4refine","text":"Q4refine(fens::FENodeSet, fes::FESetQ4)\n\nRefine a mesh of quadrilaterals by bisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4spheren-Tuple{Float64,Any}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4spheren","text":"bar(x[, y])\n\nCompute\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet,FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4toQ8","text":"Q4toQ8(fens::FENodeSet, fes::FESetQ4)\n\nConvert a mesh of quadrilateral Q4 to quadrilateral Q8.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8annulus-Tuple{Float64,Float64,Int64,Int64,Float64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8annulus","text":"Q8annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl. Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8block-Tuple{Float64,Float64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8block","text":"Q8block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)\n\nMesh of a rectangle of Q8 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8blockx-Tuple{Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8blockx","text":"Q8blockx(xs::FFltVec, ys::FFltVec)\n\nGraded mesh of a 2-D block of Q8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-tetrahedra-1","page":"Functions","title":"Meshing with tetrahedra","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTetrahedronModule, FinEtools.VoxelBoxModule, FinEtools.VoxelTetMeshingModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10block","text":"T10block(Length::FFlt, Width::FFlt, Height::FFlt,\n  nL::FInt, nW::FInt, nH::FInt; orientation::Symbol=:a)\n\nGenerate a tetrahedral  mesh of T10 elements  of a rectangular block.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10blockx","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10blockx","text":"T10blockx(xs::FFltMat, ys::FFltMat, zs::FFltMat, orientation::Symbol = :a)\n\nGenerate a graded 10-node tetrahedral mesh  of a 3D block.\n\n10-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into six tetrahedra.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10layeredplatex","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10layeredplatex","text":"T10layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec,\n    orientation::Symbol = :a)\n\nT10 mesh for a layered block (composite plate) with specified in plane coordinates.\n\nxs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer\n\nThe finite elements of each layer are labeled with the layer number, starting from 1 at the bottom.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10refine-Tuple{FENodeSet,FESetT10}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10refine","text":"T10refine(fens::FENodeSet, fes::FESetT10)\n\nRefine the mesh of quadratic tetrahedra.\n\nEach tetrahedron is converted to eight tetrahedra (each face is quadri-sected).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10toT4-Tuple{FENodeSet,FESetT10}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10toT4","text":"T10toT4(fens::FENodeSet,  fes::FESetT4)\n\nConvert a mesh of tetrahedra of type T10 (quadratic 10-node) to tetrahedra T4.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4block","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4block","text":"T4block(Length::FFlt, Width::FFlt, Height::FFlt,\n   nL::FInt, nW::FInt, nH::FInt, orientation::Symbol)\n\nGenerate a tetrahedral mesh  of the 3D block.\n\nFour-node tetrahedra in a regular arrangement, with uniform spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into six tetrahedra. Range =<0, Length> x <0, Width> x <0, Height> Divided into elements: nL,  nW,  nH in the first,  second,  and third direction (x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Symbol}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4blockx","text":"T4blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec, orientation::Symbol)\n\nGenerate a graded tetrahedral mesh  of a 3D block.\n\nFour-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into six tetrahedra.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4blockx-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},Symbol}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4blockx","text":"T4blockx(xs::FFltMat, ys::FFltMat, zs::FFltMat, orientation::Symbol)\n\nGenerate a graded tetrahedral mesh  of a 3D block.\n\nFour-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into six tetrahedra.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4meshedges-Tuple{Array{Int64,2}}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4meshedges","text":"T4meshedges(t::Array{Int, 2})\n\nCompute all the edges of the 4-node triangulation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4refine-Tuple{FENodeSet,FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4refine","text":"T4refine(fens::FENodeSet, fes::FESetT4)\n\nRefine a mesh of 4-node tetrahedra by octasection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4refine20-Tuple{FENodeSet,FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4refine20","text":"T4refine20(fens::FENodeSet, fes::FESetT4)\n\nRefine a tetrahedral four-node mesh into another four-node tetrahedral mesh, with each original tetrahedron being subdivided into 20 new tetrahedra.\n\nEach vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4toT10-Tuple{FENodeSet,FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4toT10","text":"T4toT10(fens::FENodeSet,  fes::FESetT4)\n\nConvert a mesh of tetrahedra of type T4 (four-node) to tetrahedra T10.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4voximg-Union{Tuple{DataT}, Tuple{Array{DataT,3},Array{Float64,1},Array{DataT,1}}} where DataT<:Number","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4voximg","text":"T4voximg(img::Array{DataT, 3}, voxdims::FFltVec,\n    voxval::Array{DataT, 1}) where {DataT<:Number}\n\nGenerate a tetrahedral mesh  from three-dimensional image.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv-Tuple{Array{Float64,2}}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv","text":"tetv(X)\n\nCompute the volume of a tetrahedron.\n\nX = [0  4  3\n9  2  4\n6  1  7\n0  1  5] # for these points the volume is 10.0\ntetv(X)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv1times6-Tuple{Array{Float64,2},Int64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv1times6","text":"tetv1times6(v, i1, i2, i3, i4)\n\nCompute 6 times the volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.vtkexport-Union{Tuple{DataT}, Tuple{CoordT}, Tuple{String,VoxelBoxVolume{CoordT,DataT}}} where DataT<:Number where CoordT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.vtkexport","text":"vtkexport(theFile::String, V::VoxelBoxVolume{CoordT,DataT}) where {CoordT<:Number,DataT<:Number}\n\nCompute.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.fillsolid!-Union{Tuple{DataT}, Tuple{VoxelBoxVolume,SolidCF,DataT}} where DataT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.fillsolid!","text":"fillsolid!(V::VoxelBoxVolume,\n    f::SolidCF, fillvalue::DataT) where {DataT<:Number}\n\nFilled a solid using a solid characteristic function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.fillvolume!-Union{Tuple{DataT}, Tuple{VoxelBoxVolume,DataT}} where DataT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.fillvolume!","text":"fillvolume!(V::VoxelBoxVolume, fillvalue::DataT) where {DataT<:Number}\n\nFill the volume with a given value.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.pad-Tuple{VoxelBoxVolume,Any,Any,Any,Any}","page":"Functions","title":"FinEtools.VoxelBoxModule.pad","text":"pad(V::VoxelBoxVolume, ipad, jpad, kpad, padvalue)\n\nPad voxel box with a constant value.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.solidbox-Union{Tuple{CoordT}, Tuple{Tuple{CoordT,CoordT,CoordT},Tuple{CoordT,CoordT,CoordT}}} where CoordT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.solidbox","text":"solidbox(corner1::Tuple{CoordT, CoordT, CoordT},\n    corner2::Tuple{CoordT, CoordT, CoordT}) where {CoordT<:Number}\n\nSolid box  with faces aligned with the global Cartesian axes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.solidhalfspace-Union{Tuple{CoordT}, Tuple{Tuple{CoordT,CoordT,CoordT},Tuple{CoordT,CoordT,CoordT}}} where CoordT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.solidhalfspace","text":"solidhalfspace(center::Tuple{CoordT, CoordT, CoordT},\n    normal::Tuple{CoordT, CoordT, CoordT}) where {CoordT<:Number}\n\nSolid halfspace.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.solidsphere-Union{Tuple{CoordT}, Tuple{Tuple{CoordT,CoordT,CoordT},CoordT}} where CoordT<:Number","page":"Functions","title":"FinEtools.VoxelBoxModule.solidsphere","text":"solidsphere(center::Tuple{CoordT, CoordT, CoordT}, r::CoordT) where {CoordT<:Number}\n\nSolid sphere.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.threshold-NTuple{4,Any}","page":"Functions","title":"FinEtools.VoxelBoxModule.threshold","text":"threshold(V, threshold_value, voxel_below, voxel_above)\n\nThreshold the data.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelBoxModule.trim-Tuple{VoxelBoxVolume,Any}","page":"Functions","title":"FinEtools.VoxelBoxModule.trim","text":"trim(V::VoxelBoxVolume, emptyvalue)\n\nTrim off pieces of the volume that consist only of the empty value.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.VoxelTetMeshingModule.mesh!","page":"Functions","title":"FinEtools.VoxelTetMeshingModule.mesh!","text":"mesh!(self::ImageMesher, stretch::FFlt = 1.2)\n\nPerform a meshing step.  \n\nIf  no mesh exists,  the initial mesh is created; otherwise a coarsening sequence of coarsen surface -> smooth -> coarsen volume -> smooth is performed.\n\nAfter meshing the vertices, tetrahedra, and material identifiers,  can be retrieved as self.v, self.t, and self.tmid.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.VoxelTetMeshingModule.volumes-Tuple{ImageMesher}","page":"Functions","title":"FinEtools.VoxelTetMeshingModule.volumes","text":"volumes(self::ImageMesher)\n\nCompute tetrahedral volumes in the current mesh.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-hexahedra-1","page":"Functions","title":"Meshing with hexahedra","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshHexahedronModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20block","text":"H20block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nCreate mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20blockx","text":"H20blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27block","text":"H27block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nCreate mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27blockx","text":"H27blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8block","text":"H8block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)\n\nMake  a mesh  of a 3D block consisting of  eight node hexahedra.\n\nLength, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8blockx","text":"H8blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)\n\nGraded mesh of a 3-D block of H8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8cylindern-Tuple{Float64,Float64,Any,Any}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8cylindern","text":"H8cylindern(Radius::FFlt, Length::FFlt, nperradius, nL)\n\nH8 mesh of a solid  cylinder with given number of edges per radius (nperradius) and per length (nL).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8elliphole-Tuple{Float64,Float64,Float64,Float64,Float64,Int64,Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8elliphole","text":"H8elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt, T::FFlt,\n    nL::FInt, nH::FInt, nW::FInt, nT::FInt)\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radii of the ellipse, L,H = dimensions of the plate, T = thickness of the plate nL,nH= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole nW = number of edges along the remaining straight edge (from the hole   in the radial direction),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{F}, Tuple{FENodeSet,FESetQ4,Int64,F}} where F<:Function","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8extrudeQ4","text":"H8extrudeQ4(fens::FENodeSet,  fes::FESetQ4, nLayers::FInt, extrusionh::Function)\n\nExtrude a mesh of quadrilaterals into a mesh of hexahedra (H8).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8hexahedron-Tuple{Array{Float64,2},Int64,Int64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8hexahedron","text":"H8hexahedron(xyz::FFltMat, nL::FInt, nW::FInt, nH::FInt; blockfun=nothing)\n\nMesh of a general hexahedron given by the location of the vertices.\n\nxyz = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). nL,  nW,  nH = number of elements in each direction blockfun = Optional argument: function of the block-generating mesh function      (having the signature of the function H8block()).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8layeredplatex-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8layeredplatex","text":"H8layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec)\n\nH8 mesh for a layered block (composite plate) with specified in plane coordinates.\n\nxs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer\n\nThe finite elements of each layer are labeled with the layer number, starting from 1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8refine","text":"H8refine(fens::FENodeSet,  fes::FESetH8)\n\nRefine a mesh of H8 hexahedrals by octasection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8sphere-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8sphere","text":"H8sphere(radius::FFlt, nrefine::FInt)\n\nCreate a mesh of 1/8 of the sphere of \"radius\". The  mesh will consist of\nfour hexahedral elements if \"nrefine==0\",  or more if \"nrefine>0\".\n\"nrefine\" is the number of bisections applied  to refine the mesh.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8spheren-Tuple{Float64,Int64}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8spheren","text":"H8spheren(radius::FFlt, nperradius::FInt)\n\nCreate a solid mesh of 1/8 of sphere.\n\nCreate a solid mesh of 1/8 of the sphere of \"radius\",  with nperradius elements per radius.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH20","text":"H8toH20(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H20.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet,FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH27","text":"H8toH27(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H27.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{DataT}, Tuple{Array{DataT,3},Array{Float64,1},Array{DataT,1}}} where DataT<:Number","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8voximg","text":"H8voximg(img::Array{DataT, 3}, voxdims::FFltVec,\n    voxval::Array{DataT, 1}) where {DataT<:Number}\n\nGenerate a hexahedral mesh  from three-dimensional image.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet,FESetT4}","page":"Functions","title":"FinEtools.MeshHexahedronModule.T4toH8","text":"T4toH8(fens::FENodeSet, fes::FESetT4)\n\nConvert a tetrahedral four-node mesh into eight-node hexahedra.\n\nEach vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-modification-1","page":"Functions","title":"Mesh modification","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshModificationModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshModificationModule._coldeg-Tuple{SparseArrays.SparseMatrixCSC,Int64}","page":"Functions","title":"FinEtools.MeshModificationModule._coldeg","text":"_coldeg(A::SparseMatrixCSC, j::Int)\n\nThis function has been modified from source of (https://github.com/rleegates/CuthillMcKee.jl/blob/master/src/CuthillMcKee.jl)\n\nA is assumed to be symmetric.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.adjgraph-Tuple{Any,Any}","page":"Functions","title":"FinEtools.MeshModificationModule.adjgraph","text":"adjgraph(conn, nfens)\n\nCompute the adjacency graph from the array of connectivities of the elements in the mesh.\n\nExamples\n\nconn = [9 1 8 4;\n       1 3 2 8;\n       8 2 7 5;\n       2 6 7 7];\nnfens = 9;\nadjgraph(conn, nfens)   \n\n\nshould produce 9-element Array{Array{Int64,1},1}:  [9, 8, 4, 3, 2]        [1, 3, 8, 7, 5, 6]     [1, 2, 8]   [9, 1, 8]   [8, 2, 7]   [2, 7]      [8, 2, 5, 6]  [9, 1, 4, 3, 2, 7, 5]  [1, 8, 4]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.adjgraph-Tuple{SparseArrays.SparseMatrixCSC}","page":"Functions","title":"FinEtools.MeshModificationModule.adjgraph","text":"adjgraph(A)\n\nCompute the adjacency graph from a sparse matrix. This function has been modified from source of (https://github.com/rleegates/CuthillMcKee.jl/blob/master/src/CuthillMcKee.jl)\n\nA is assumed to be symmetric.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet,BitArray{1}}","page":"Functions","title":"FinEtools.MeshModificationModule.compactnodes","text":"compactnodes(fens::FENodeSet, connected::Vector{Bool})\n\nCompact the finite element node set by deleting unconnected nodes.\n\nfens = array of finite element nodes connected = The array element connected[j] is either 0 (when j is an   unconnected node), or a positive number (when node j is connected to   other nodes by at least one finite element)\n\nOutput:\n\nfens = new set of finite element nodes new_numbering= array which tells where in the new fens array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      new_numbering[5] is 3.\n\nExamples:\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactnodes(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.fusenodes-Tuple{FENodeSet,FENodeSet,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.fusenodes","text":"fusenodes(fens1::FENodeSet, fens2::FENodeSet, tolerance:: FFlt)\n\nFuse together nodes from two node sets.\n\nFuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, fens1 and fens2,  are fused together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the new  indexes of the nodes in the set fens1 are returned.\n\nThe set fens2 will be included unchanged, in the same order, in the node set fens. The indexes of the node set fens1 will have changed.\n\nExample:\n\nAfter the call to this function we have k=new_indexes_of_fens1_nodes[j] is the node in the node set fens which used to be node j in node set fens1. The finite element set connectivity that used to refer to fens1 needs to be updated to refer to the same nodes in  the set fens as      updateconn!(fes, new_indexes_of_fens1_nodes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.interior2boundary-Tuple{Array{Int64,2},Array{Int64,2}}","page":"Functions","title":"FinEtools.MeshModificationModule.interior2boundary","text":"interior2boundary(interiorconn::Array{Int, 2}, extractb::Array{Int, 2})\n\nExtract the boundary connectivity from the connectivity of the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{FENodeSet,T1,FENodeSet,T2,Float64}} where T2<:AbstractFESet where T1<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.mergemeshes","text":"mergemeshes(fens1::FENodeSet, fes1::T1,\n  fens2::FENodeSet, fes2::T2, tolerance::FFlt) where {T1<:AbstractFESet,T2<:AbstractFESet}\n\nMerge together two meshes.\n\nMerge two meshes together by gluing together nodes within tolerance. The two meshes, fens1, fes1, and fens2, fes2, are glued together by merging the nodes that fall within a box of size tolerance. If tolerance is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.\n\nThe merged node set, fens, and the two finite element sets with renumbered  connectivities are returned.\n\nImportant notes: On entry into this function the connectivity of fes1 point into fens1 and the connectivity of fes2 point into fens2. After this function returns the connectivity of both fes1 and fes2 point into fens. The order of the nodes of the node set fens1 in the resulting set fens will have changed, whereas the order of the nodes of the node set fens2 is are guaranteed to be the same. Therefore, the connectivity of fes2 will in fact remain the same.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenmeshes-Tuple{Array{Tuple{FENodeSet,AbstractFESet},N} where N,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenmeshes","text":"mergenmeshes(meshes::Array{Tuple{FENodeSet, FESet}}, tolerance::FFlt)\n\nMerge several meshes together.\n\nThe meshes are glued together by merging the nodes that fall within  a box of size tolerance. If tolerance is set to zero, no merging of  nodes is performed; the nodes from the meshes are simply concatenated together.\n\nOutput\n\nThe merged node set, fens, and an array of finite element sets with renumbered  connectivities are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt, candidates::FIntVec)\n\nMerge together  nodes of a single node set.\n\nSimilar to mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt), but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt)\n\nMerge together  nodes of a single node set.\n\nMerge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the finite element set, fes, with renumbered  connectivities are returned.\n\nWarning: This tends to be an expensive operation!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshboundary-Union{Tuple{T}, Tuple{T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshboundary","text":"meshboundary(fes::T) where {T<:AbstractFESet}\n\nExtract the boundary finite elements from a mesh.\n\nExtract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet,T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshsmoothing","text":"meshsmoothing(fens::FENodeSet, fes::T; options...) where {T<:AbstractFESet}\n\nGeneral smoothing of meshes.\n\nKeyword options:\n\nmethod = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\nReturn\n\nThe modified  node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{FENodeSet,T,Array{Float64,1},Array{Float64,1}}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.mirrormesh","text":"mirrormesh(fens::FENodeSet, fes::T, Normal::FFltVec,\n  Point::FFltVec; kwargs...) where {T<:AbstractFESet}\n\nMirror a 2-D mesh in a plane given by its normal and one point.\n\nWarning: The code to relies on the numbering of the cells: to reverse the orientation of the mirrored cells, the connectivity is listed in reverse order.   If the mirrored cells do not follow this rule (for instance hexahedra for quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.\n\nFor instance: H8 elements require  the renumbering function to be supplied as fens1,gcells1 = mirror_mesh(fens, gcells,...           [-1,0,0], [0,0,0], @(c)c([1, 4, 3, 2, 5, 8, 7, 6]));\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodedegrees-Tuple{Array{Array{Int64,1},1}}","page":"Functions","title":"FinEtools.MeshModificationModule.nodedegrees","text":"nodedegrees(adjgr::Vector{Vector{Int}})\n\nCompute the degrees of the nodes in the adjacency graph.\n\nconn = [9 1 8 4;        1 3 2 8;        8 2 7 5;        2 6 7 7]; nfens = 9; adjgr = adjgraph(conn, nfens)   nodedegrees(adjgr)\n\njulia> degrees = node_degrees(adjgr)         9-element Array{Int64,1}:  5  6  3  3  3  2  4  7  3  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnpartitions = number of partitions, but note that the actual number of partitions is going to be a power of two.\n\nIn this variant all the nodes are to be included in the partitioning.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-Dollar(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend \nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" DollarFile`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnincluded = Boolean array: is the node to be included in the partitioning or     not? npartitions = number of partitions, but note that the actual number of     partitions is going to be a power of two.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-Dollar(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend \nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" DollarFile`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet,Any,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})\n\nCompute the inertial-cut partitioning of the nodes.\n\nfesarr = array of finite element sets that represent regions npartitions = array of the number of partitions in each region. However  note that the actual number of partitions is going to be a power of two.\n\nThe partitioning itself is carried out by nodepartitioning() with  a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to  the elements of that region, but not to elements that belong to  any of the previous regions, 1I-1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.renumberconn!-Tuple{AbstractFESet,Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.renumberconn!","text":"renumberconn!(fes::AbstractFESet, new_numbering::FIntVec)\n\nRenumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.\n\nfes =finite element set new_numbering = new serial numbers for the nodes.  The connectivity           should be changed as conn[j] > new_numbering[conn[j]]\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactfens(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.revcm-Tuple{Array{Array{Int64,1},1},Array{Int64,1}}","page":"Functions","title":"FinEtools.MeshModificationModule.revcm","text":"revcm(adjgr::Vector{Vector{Int}}, degrees::Vector{Int})\n\nReverse Cuthill-McKee node-renumbering algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vertexneighbors-Tuple{Array{Int64,2},Int64}","page":"Functions","title":"FinEtools.MeshModificationModule.vertexneighbors","text":"vertexneighbors(conn::FIntMat, nvertices::FInt)\n\nFind the node neighbors in the mesh. \n\nReturn an array of integer vectors, element I holds an array of numbers of nodes which are connected to node I (including node I).  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vsmoothing-Tuple{Array{Float64,2},Array{Int64,2}}","page":"Functions","title":"FinEtools.MeshModificationModule.vsmoothing","text":"vsmoothing(v::FFltMat, t::FIntMat; options...)\n\nInternal routine for mesh smoothing.\n\nKeyword options: method = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Utilities-1","page":"Functions","title":"Utilities","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T,T,Int64}, Tuple{T,T,Int64,Any}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.gradedspace","text":"gradedspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate quadratic space.\n\nGenerate a quadratic sequence of numbers between start and finish. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T,T,Int64}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.linearspace","text":"linearspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate linear space.\n\nGenerate a linear sequence of numbers between start and top (i. e. sequence  of number with uniform intervals inbetween).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Vector-cache-utilities-1","page":"Functions","title":"Vector-cache utilities","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.VectorCacheModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.VectorCacheModule.updateretrieve!-Tuple{VectorCache,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.VectorCacheModule.updateretrieve!","text":"updateretrieve!(self::VectorCache, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the cache and retrieve the vector.\n\nAfter the return from this function the updated vector can be read from the cache as self.cache (also returned).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Surface-normal-utilities-1","page":"Functions","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.SurfaceNormalModule.updatenormal!-Tuple{SurfaceNormal,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.SurfaceNormalModule.updatenormal!","text":"updatenormal!(self::SurfaceNormal, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the surface normal vector.\n\nReturns a vector (stored in the cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Force-intensity-1","page":"Functions","title":"Force intensity","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.ForceIntensityModule.updateforce!-Tuple{ForceIntensity,Array{Float64,2},Array{Float64,2},Int64}","page":"Functions","title":"FinEtools.ForceIntensityModule.updateforce!","text":"updateforce!(self::ForceIntensity, ndofn::FInt, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n\nUpdate the force intensity vector.\n\nReturns a vector (stored in the cache self.cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Rotation-utilities-1","page":"Functions","title":"Rotation utilities","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.RotationUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.RotationUtilModule.rotmat3!-Tuple{Array{Float64,2},Array{Float64,1}}","page":"Functions","title":"FinEtools.RotationUtilModule.rotmat3!","text":"rotmat3!(Rmout::FFltMat, a::FFltVec)\n\nCompute a 3D rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.skewmat!-Tuple{Any,Any}","page":"Functions","title":"FinEtools.RotationUtilModule.skewmat!","text":"skewmat!(S, theta)\n\nCompute skew-symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FEM-machines-1","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Base-1","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Tuple{AbstractFEMM,NodalField{Float64}}","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::AbstractFEMM,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nThere may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.\n\nGeometry field is normally passed into any routine that evaluates some  forms (integrals) over the mesh.  Whenever the geometry passed into a  routine is not consistent with the one for which associategeometry!()  was called before, associategeometry!() needs to be called with  the new geometry field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM,Int64}} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.connectionmatrix","text":"connectionmatrix(self::FEMM, nnodes::FInt) where {FEMM<:AbstractFEMM}\n\nCompute the connection matrix.\n\nThe matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.distribloads-Union{Tuple{A}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T},ForceIntensity,Int64}} where A<:AbstractSysvecAssembler where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.distribloads","text":"distribloads(self::FEMM, assembler::A, geom::NodalField{FFlt}, P::NodalField{T},\n  fi::ForceIntensity,\n  m::FInt) where {FEMM<:AbstractFEMM, T<:Number, A<:AbstractSysvecAssembler}\n\nCompute the distributed-load vector.\n\nArguments\n\nfi=force intensity object\nm= manifold dimension, 1= curve, 2= surface, 3= volume. For body loads m\n\nis set to 3, for tractions on the surface it is set to 2, and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.elemfieldfromintegpoints","text":"elemfieldfromintegpoints(self::FEMM,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;\n  context...) where {FEMM<:AbstractFEMM, T<:Number}\n\nConstruct elemental field from integration points.\n\nArguments\n\ngeom     - reference geometry field u        - displacement field dT       - temperature difference field quantity   - this is what you would assign to the 'quantity' argument            of the material update!() method. component- component of the 'quantity' array: see the material update()            method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.fieldfromintegpoints","text":"fieldfromintegpoints(self::FEMM,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;\n  context...) where {FEMM<:AbstractFEMM, T<:Number}\n\nConstruct nodal field from integration points.\n\nArguments\n\ngeom     - reference geometry field\nu        - displacement field\ndT       - temperature difference field\nquantity   - this is what you would assign to the 'quantity' argument          of the material update!() method.\ncomponent- component of the 'quantity' array: see the material update()          method.\n\nKeyword arguments\n\nnodevalmethod = :invdistance (the default) or :averaging;\nreportat = at which point should the  element quantities be reported?   This argument is interpreted inside the inspectintegpoints() method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T}}} where T where A<:AbstractSysmatAssembler where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.innerproduct","text":"innerproduct(self::FEMMHeatDiff,\n  assembler::A, geom::NodalField{FFlt},\n  temp::NodalField{FFlt}) where {A<:AbstractSysmatAssembler}\n\nCompute the inner-product (Gram) matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMM, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {FEMM<:AbstractFEMM, T<:Number, F<:Function}\n\nInspect integration points.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F<:Function where R where FL<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(self::AbstractFEMM,\n    geom::NodalField{FFlt},  afield::FL, fh::F, initial::R;\n    m::FInt=-1) where {T<:Number, FL<:ElementalField{T}, R, F<:Function}\n\nIntegrate a elemental-field function over the discrete manifold.\n\nafield = ELEMENTAL field to be supply the values  fh = function taking position and the field value as arguments, returning value of type R.\n\nReturns value of type R, which is initialized by initial. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F<:Function where R where FL<:NodalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(self::AbstractFEMM,\n    geom::NodalField{FFlt},  afield::FL, fh::F,  initial::R;\n    m::FInt=-1) where {T<:Number, FL<:NodalField{T}, R, F<:Function}\n\nIntegrate a nodal-field function over the discrete manifold.\n\nafield = NODAL field to be supply the values  fh = function taking position and the field value as arguments, returning value of type R.\n\nReturns value of type R, which is initialized by initial.    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{F}, Tuple{AbstractFEMM,NodalField{Float64},F}, Tuple{AbstractFEMM,NodalField{Float64},F,Int64}} where F<:Function","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefunction","text":"integratefunction(self::AbstractFEMM,\n    geom::NodalField{FFlt}, fh::F, m::FInt = -1) where {F<:Function}\n\nIntegrate a function over the discrete manifold.\n\nIntegrate some scalar function over the geometric cells. The function takes a single argument, the position vector.\n\nWhen the scalar function returns just +1 (such as (x) ->  1.0), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.\n\nExample:\n\nCompute the volume of the mesh and then its center of gravity:\n\nV = integratefunction(femm, geom, (x) ->  1.0)\nSx = integratefunction(femm, geom, (x) ->  x[1])\nSy = integratefunction(femm, geom, (x) ->  x[2])\nSz = integratefunction(femm, geom, (x) ->  x[3])\nCG = vec([Sx Sy Sz]/V)\n\nCompute the moments of inertia:\n\nIxx = measure(femm,geom,@(x)(norm(x-CG)^2*eye(3)-(x-CG)'*(x-CG)))\nmass = V*rhos;\nInertia = I*rhos;\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F<:ElementalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet, fc::F,\n    fensc::FENodeSet, fesc::AbstractFESet, geometricaltolerance::FFlt;\n    parametrictolerance::FFlt = 0.01 )  where {T<:Number,\n    F<:ElementalField{T}}\n\nTransfer an elemental field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ntolerance = tolerance in physical space for searches of the adjacent nodes\n\nOutput\n\nElemental field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F<:NodalField{T} where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet,\n    fc::F, fensc::FENodeSet, fesc::AbstractFESet, tolerance::FFlt\n    )  where {T<:Number, F<:NodalField{T}}\n\nTransfer a nodal field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ngeometricaltolerance = tolerance in physical space for searches of the adjacent nodes\nparametrictolerance = tolerance in parametric space for for check whether node is inside an element\n\nOutput\n\nNodal field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Heat-diffusion-1","page":"Functions","title":"Heat diffusion","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMHeatDiffModule, FinEtools.FEMMHeatDiffSurfModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMMHeatDiff, geom::NodalField{FFlt}, u::NodalField{T}, temp::NodalField{FFlt}, felist::FIntVec, inspector::F, idat, quantity=:heatflux; context...) where {F<:Function}\n\nInspect integration point quantities.\n\nInputs\n\ngeom - reference geometry field\nu - displacement field (ignored)\ntemp - temperature field\nfelist - indexes of the finite elements that are to be inspected: The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - function with the signature       idat = inspector(idat, j, conn, x, out, loc);  where   idat - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, j is the element number, conn is the element connectivity,          out is the output of the update!() method,  loc is the location          of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffModule.conductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMHeatDiffModule.conductivity","text":"conductivity(self::FEMMHeatDiff,\n  assembler::A, geom::NodalField{FFlt},\n  temp::NodalField{FFlt}) where {A<:AbstractSysmatAssembler}\n\nCompute the conductivity matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffModule.energy-Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{Float64}}","page":"Functions","title":"FinEtools.FEMMHeatDiffModule.energy","text":"energy(self::FEMMHeatDiff, geom::NodalField{FFlt},  temp::NodalField{FFlt})\n\nCompute the \"energy\" integral over the interior domain.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffModule.nzebcloadsconductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMHeatDiffModule.nzebcloadsconductivity","text":"nzebcloadsconductivity(self::FEMMHeatDiff,\n  assembler::A,  geom::NodalField{FFlt},\n  temp::NodalField{FFlt}) where {A<:AbstractSysvecAssembler}\n\nCompute load vector for nonzero EBC of prescribed temperature.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads","text":"nzebcsurfacetransferloads(self::FEMMHeatDiffSurf, assembler::A,\n  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A<:AbstractSysvecAssembler}\n\nCompute load vector for nonzero EBC for fixed temperature.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffSurfModule.surfacetransfer-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMHeatDiffSurfModule.surfacetransfer","text":"surfacetransfer(self::FEMMHeatDiffSurf,  assembler::A,\n  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A<:AbstractSysmatAssembler}\n\nCompute the surface heat transfer matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMHeatDiffSurfModule.surfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64},NodalField{Float64}}} where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMHeatDiffSurfModule.surfacetransferloads","text":"surfacetransferloads(self::FEMMHeatDiffSurf,  assembler::A,\n  geom::NodalField{FFlt}, temp::NodalField{FFlt},\n  ambtemp::NodalField{FFlt}) where {A<:AbstractSysvecAssembler}\n\nCompute the load vector corresponding to surface heat transfer.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Acoustics-1","page":"Functions","title":"Acoustics","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMAcoustModule, FinEtools.FEMMAcoustSurfModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMAcoustModule.acousticmass-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoust,A,NodalField,NodalField{T}}} where A<:AbstractSysmatAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustModule.acousticmass","text":"acousticmass(self::FEMMAcoust,\n  assembler::A, geom::NodalField,\n  P::NodalField{T}) where {T<:Number, A<:AbstractSysmatAssembler}\n\nCompute the acoustic mass matrix.\n\nArguments\n\nself   =  acoustics model assembler  =  matrix assembler geom = geometry field P = acoustic (perturbation) pressure field\n\nReturn a matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustModule.acousticstiffness-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoust,A,NodalField,NodalField{T}}} where A<:AbstractSysmatAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustModule.acousticstiffness","text":"acousticstiffness(self::FEMMAcoust, assembler::A,\n  geom::NodalField,\n  Pddot::NodalField{T}) where {T<:Number,\n  A<:AbstractSysmatAssembler}\n\nCompute the acoustic stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustModule.nzebcloadsacousticmass-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoust,A,NodalField,NodalField{T}}} where A<:AbstractSysvecAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustModule.nzebcloadsacousticmass","text":"nzebcloadsacousticmass(self::FEMMAcoust, assembler::A,\n  geom::NodalField, P::NodalField{T}) where {T<:Number,\n  A<:AbstractSysvecAssembler}\n\nCompute load vector for nonzero EBC for prescribed pressure.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustModule.nzebcloadsacousticstiffness-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoust,A,NodalField,NodalField{T}}} where A<:AbstractSysvecAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustModule.nzebcloadsacousticstiffness","text":"nzebcloadsacousticstiffness(self::FEMMAcoust, assembler::A,\n  geom::NodalField,\n  Pddot::NodalField{T}) where {T<:Number,\n  A<:AbstractSysvecAssembler}\n\nCompute load vector for nonzero EBC for prescribed second-order pressure rate.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustSurfModule.acousticABC-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoustSurf,A,NodalField,NodalField{T}}} where A<:AbstractSysmatAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustSurfModule.acousticABC","text":"acousticABC(self::FEMMAcoustSurf, assembler::A,\n  geom::NodalField,\n  Pdot::NodalField{T}) where {T<:Number, A<:AbstractSysmatAssembler}\n\nCompute the acoustic ABC (Absorbing Boundary Condition) matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustSurfModule.acousticcouplingpanels-Union{Tuple{T}, Tuple{A}, Tuple{FEMMAcoustSurf,A,NodalField,NodalField{T}}} where T where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMAcoustSurfModule.acousticcouplingpanels","text":"acousticcouplingpanels(self::FEMMAcoustSurf, geom::NodalField, u::NodalField{T}) where {T}\n\nCompute the acoustic pressure-structure coupling matrix.\n\nThe acoustic pressure-nodal force matrix transforms  the pressure distributed along the surface to forces acting on the nodes of the finite element model. Its transpose transforms displacements (or velocities, or accelerations) into the normal component of the displacement (or velocity, or acceleration) along the surface.\n\nArguments\n\ngeom=geometry field u = displacement field \n\nnote: Note\n\n\n n=outer normal (pointing into the acoustic medium).  The pressures along the surface are assumed constant (uniform) along  each finite element - panel. The panel pressures are assumed to be given the same numbers as the serial numbers of the finite elements in the block.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustSurfModule.pressure2resultantforce-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoustSurf,A,NodalField,NodalField{T},GeneralField}} where A<:AbstractSysmatAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustSurfModule.pressure2resultantforce","text":"pressure2resultantforce(self::FEMMAcoustSurf, assembler::A,\n  geom::NodalField,\n  P::NodalField{T},\n   Force::Field) where {T<:Number, A<:AbstractSysmatAssembler}\n\nCompute the rectangular coupling matrix that transcribes given pressure on the surface into the resultant force acting on the surface.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMAcoustSurfModule.pressure2resultanttorque-Union{Tuple{A}, Tuple{T}, Tuple{FEMMAcoustSurf,A,NodalField,NodalField{T},GeneralField,Array{Float64,1}}} where A<:AbstractSysmatAssembler where T<:Number","page":"Functions","title":"FinEtools.FEMMAcoustSurfModule.pressure2resultanttorque","text":"pressure2resultanttorque(self::FEMMAcoustSurf, assembler::A,\n  geom::NodalField,\n  P::NodalField{T},\n  Torque::GeneralField, CG::FFltVec) where {T<:Number, A<:AbstractSysmatAssembler}\n\nCompute the rectangular coupling matrix that transcribes given pressure on the surface into the resultant torque acting on the surface with respect to the CG.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Linear-deformation-1","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html#Model-reduction-types-1","page":"Functions","title":"Model reduction types","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.DeforModelRedModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed1D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed1D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a one-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a one-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <=  3), and mdim = number of manifold dimensions (here mdim == 1).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DAxisymm},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DAxisymm}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for axially symmetric models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in axially-symmetric setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <=  3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStrain},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStrain}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-strain models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-strain setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <=  3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStress},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStress}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-stress models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-stress setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <=  3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed3D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a three-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a three-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim ==   3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.divmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.divmat","text":"divmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the displacement divergence matrix for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim ==   3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\ndivmat = displacement divergence matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.nstressstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtools.DeforModelRedModule.nstressstrain","text":"nstressstrain(::Type{AbstractDeforModelRed})::FInt\n\nReturn the number of stress components involved in the balance equation (and how many strain components) are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.nthermstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtools.DeforModelRedModule.nthermstrain","text":"nthermstrain(::Type{DeforModelRed1D})::FInt\n\nHow many thermal strain components are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.stresscomponentmap-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtools.DeforModelRedModule.stresscomponentmap","text":"stresscomponentmap(::Type{DeforModelRed1D})\n\nConstruct a dictionary to map from stress-component symbols to indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.DeforModelRedModule.vgradmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtools.DeforModelRedModule.vgradmat","text":"vgradmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the matrix of displacement gradient in vector form for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim ==   3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nvgradm = strain-displacement matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality-1","page":"Functions","title":"Base functionality","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMDeforLinearBaseModule, FinEtools.FEMMDeforLinearModule, FinEtools.FEMMDeforWinklerModule, FinEtools.FEMMDeforLinearMSModule, FinEtools.FEMMDeforSurfaceDampingModule, FinEtools.FEMMDeforLinearNICEModule, FinEtools.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number where FEMM<:AbstractFEMMDeforLinear","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinear,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},\n  felist::FIntVec,\n  inspector::F,  idat, quantity=:Cauchy;\n  context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:    The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature       idat = inspector(idat, j, conn, x, out, loc);  where   idat - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, j is the element number, conn is the element connectivity,          out is the output of the update!() method,  loc is the location          of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.mass-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.mass","text":"mass(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the consistent mass matrix\n\nThis is a general routine for the abstract linear-deformation  FEMM.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinear, assembler::A,\n      geom::NodalField{FFlt},\n      u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.thermalstrainloads-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T},NodalField{Float64}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.thermalstrainloads","text":"thermalstrainloads(self::AbstractFEMMDeforLinear, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    dT::NodalField{FFlt}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute the thermal-strain load vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforWinklerModule.surfacenormalspringstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FEMMDeforWinkler,A,NodalField{Float64},NodalField{T},Float64,SurfaceNormal}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforWinklerModule.surfacenormalspringstiffness","text":"surfacenormalspringstiffness(self::FEMMDeforWinkler, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    springconstant::FFlt, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the stiffness matrix of surface normal spring.\n\nRationale: consider continuously distributed springs between the surface of the solid body and the 'ground', in the direction normal to the surface. If the spring coefficient becomes large, we have an approximate method of enforcing the normal displacement to the surface.gas\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMSH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMST10","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMMDeforLinear,      geom::NodalField{FFlt},  u::NodalField{T},      dT::NodalField{FFlt},      felist::FIntVec,      inspector::F,  idat, quantity=:Cauchy;      context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearMS, assembler::A,       geom::NodalField{FFlt},       u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearMSModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearMSModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearMSModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearMSModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforSurfaceDampingModule.dampingABC-Union{Tuple{T2}, Tuple{T1}, Tuple{A}, Tuple{FEMMDeforSurfaceDamping,A,NodalField{Float64},NodalField{T1},T2,SurfaceNormal}} where T2<:Number where T1<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforSurfaceDampingModule.dampingABC","text":"dampingABC(self::FEMMDeforSurfaceDamping, assembler::A,\n              geom::NodalField{FFlt}, u::NodalField{T1},\n              impedance::T2, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T1<:Number, T2<:Number}\n\nCompute the damping matrix associated with absorbing boundary conditions (ABC) representation of the effect of infinite extent of inviscid fluid next to the surface.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FinEtools.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{AbstractFEMMDeforLinearNICE,NodalField{Float64},NodalField{T}}} where T<:Number","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, geom::NodalField{FFlt},  u::NodalField{T}) where {T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICEH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICEH8}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICET4","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICET4}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinearESNICE, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearESNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearESNICEModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearESNICEModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMDeforLinearESNICEModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtools.FEMMDeforLinearESNICEModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Simple-FE-models-1","page":"Functions","title":"Simple FE models","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMDeforLinearModule, FinEtools.FEMMDeforWinklerModule,  FinEtools.FEMMDeforSurfaceDampingModule, ]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Advanced-FE-models-1","page":"Functions","title":"Advanced FE models","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMDeforLinearMSModule, FinEtools.FEMMDeforLinearNICEModule, FinEtools.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Material-models-1","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-model-abstractions-1","page":"Functions","title":"Material model abstractions","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Material-models-for-acoustics-1","page":"Functions","title":"Material models for acoustics","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatModule, FinEtools.MatAcoustFluidModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Material-models-for-heat-diffusion-1","page":"Functions","title":"Material models for heat diffusion","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatModule, FinEtools.MatHeatDiffModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Material-base-functionality-1","page":"Functions","title":"Material base functionality","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatDeforModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Material-models-for-elasticity-1","page":"Functions","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatDeforLinearElasticModule, FinEtools.MatDeforElastIsoModule, FinEtools.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Algorithms-1","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Base-2","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.bisect-NTuple{5,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.bisect","text":"bisect(fun, xl, xu, tolx, tolf)\n\nImplementation of the bisection method.\n\nTolerance both on x and on f(x) is used.\n\nfun = function,\nxl= lower value of the bracket,\nxu= upper Value of the bracket,\ntolx= tolerance on the location of the root,\ntolf= tolerance on the function value\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{T,Array{Float64,1},Array{Float64,1},Int64}} where T","page":"Functions","title":"FinEtools.AlgoBaseModule.conjugategradient","text":"conjugategradient(A, b, x0, maxiter)\n\nCompute one or more iterations of the conjugate gradient process.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.evalconvergencestudy","text":"evalconvergencestudy(modeldatasequence)\n\nEvaluate a convergence study from a model-data sequence.  \n\nmodeldatasequence = array of modeldata dictionaries.\n\nRefer to methods fieldnorm and fielddiffnorm for details on the required keys in the dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fielddiffnorm","text":"fielddiffnorm(modeldatacoarse, modeldatafine)\n\nCompute norm of the difference of the target fields.  \n\nArguments\n\nFor both the \"coarse\"- and \"fine\"-mesh modeldata the data dictionaries need to contain the mandatory keys:\n\n\"fens\" = finite element node set\n\"regions\" = array of regions\n\"targetfields\" = array of fields, one for each region\n\"geom\" = geometry field\n\"elementsize\" = representative element size,\n\"geometricaltolerance\" = geometrical tolerance (used in field transfer; refer to the documentation of transferfield!)\n\"parametrictolerance\" = parametric tolerance (used in field transfer; refer to the documentation of transferfield!)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fieldnorm","text":"fieldnorm(modeldata)\n\nCompute norm of the target field.  \n\nArgument\n\nmodeldata = data dictionary, mandatory keys:     - \"fens\" = finite element node set     - \"regions\" = array of regions     - \"targetfields\" = array of fields, one for each region     - \"geom\" = geometry field     - \"elementsize\" = representative element size,\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.penaltyebc!","text":"penaltyebc!(K, F, dofnums, prescribedvalues, penfact)\n\nApply penalty essential boundary conditions.\n\nArguments\n\nK = stiffness matrix\nF = global load vector \ndofnums, prescribedvalues = arrays computed by prescribeddofs()\npenfact = penalty multiplier, in relative terms: how many times the maximum\n\nabsolute value of the diagonal elements should the penalty term be?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qcovariance-Tuple{Any,Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qcovariance","text":"qcovariance(ps, xs, ys; ws = nothing)\n\nCompute the covariance for two 'functions' given by the arrays xs and ys  at the values of the parameter ps. ws is the optional weights vector;   if it is not supplied, uniformly distributed default weights are assumed.  \n\nNotes:   The mean is subtracted from both functions.   This function is not particularly efficient: it computes the mean of  both functions and it allocates arrays instead of overwriting the  contents of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qtrap-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qtrap","text":"qtrap(ps, xs)\n\nCompute the area under the curve given by a set of parameters along  an interval and the values of the 'function' at those parameter values.   The parameter values need not be uniformly distributed.\n\nTrapezoidal rule is used to evaluate the integral. The 'function' is  assumed to vary linearly inbetween the given points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qvariance-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qvariance","text":"qvariance(ps, xs; ws = nothing)\n\nCompute the variance of a function given by the array xs at  the values of the parameter ps. ws is the optional weights vector   with unit default weights.    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{Tn,N} where N where Tn)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapol","text":"richextrapol(solns::T, params::T) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArguments\n\nsolns =  array of three solution values\nparams = array of values of three parameters for which the solns have been obtained\n\nThis function is applicable to any the mesh sizes (monotonically increasing, or decreasing).\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nresidual = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{Tn,N} where N where Tn)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapoluniform","text":"richextrapoluniform(solns::T, params::T) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArgument\n\nsolns =  array of solution values\nparams = array of values of parameters for which the solns have been obtained. This function is applicable only to fixed (uniform) ratio between the mesh sizes, params[1]/params[2) = params[2)/params[3).\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nresidual = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Heat-conduction-1","page":"Functions","title":"Heat conduction","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoHeatDiffModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoHeatDiffModule.steadystate-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoHeatDiffModule.steadystate","text":"steadystate(modeldata::FDataDict)\n\nSteady-state heat conduction solver.\n\nArgument\n\nmodeldata = dictionary with items\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"convection_bcs\" = array of convection boundary condition dictionaries\n\"flux_bcs\" = array of flux boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains items:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\"Q\" = material internal heat generation rate (optional; default  0.0)\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"temperature\" = fixed (prescribed) temperature (scalar),  or         a function with signature             function T = f(x)         If not given, zero temperatures assumed.\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor convection boundary conditions (optional) each dictionary may hold\n\n\"femm\" = finite element mmodel machine (mandatory);\n\"ambient_temperature\" = fixed (prescribed) ambient temperature (scalar)     If not given, zero temperatures assumed.\n\nFor flux boundary conditions (optional) each dictionary would hold\n\n\"femm\" = finite element mmodel machine (mandatory);\n\"normal_flux\" = normal component of the flux through the boundary (scalar)     Positive  when outgoing.\n\nOutput\n\nmodeldata= the dictionary on input is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"temp\" = the nodal field that is the computed temperature\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Acoustics-2","page":"Functions","title":"Acoustics","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoAcoustModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoAcoustModule.steadystate-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoAcoustModule.steadystate","text":"steadystate(modeldata::FDataDict)\n\nSteady-state acoustics solver.\n\nmodeldata = dictionary with keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"ABCs\" = array of absorbing boundary condition dictionaries\n\"flux_bcs\" = array of flux boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains items:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"pressure\" = fixed (prescribed) pressure (scalar),  or         a function with signature             function T = f(x)         If not given, zero pressure assumed.\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor absorbing boundary conditions (optional) each dictionary may hold\n\n\"femm\" = finite element mmodel machine (mandatory).\n\nFor flux boundary conditions (optional) each dictionary would hold\n\n\"femm\" = finite element mmodel machine (mandatory);\n\"normal_flux\" = normal component of the flux through the boundary (scalar),     which is the normal derivative of the pressure.\n\nOutput\n\nmodeldata = the dictionary is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"P\" = the nodal field that is the computed pressure (in the general a           complex-number field)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Linear-deformation-2","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html#","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.exportdeformation-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.exportdeformation","text":"AlgoDeforLinearModule.exportdeformation(modeldata::FDataDict)\n\nAlgorithm for exporting of the deformation for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field, or\n\"us\" = array of  tuples (name, displacement field)\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - names of exported file\n\"field\" - nodal or elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.exportmode-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.exportmode","text":"AlgoDeforLinearModule.exportmode(modeldata::FDataDict)\n\nAlgorithm for exporting of the mmode shape for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"W\" = Computed free-vibration eigenvectors, neigvs columns\n\"omega\" =  Computed free-vibration angular frequencies, array of length neigvs\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"mode\" = which mode should be visualized?\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = see exportdeformation()\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.exportstress-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.exportstress","text":"AlgoDeforLinearModule.exportstress(modeldata::FDataDict)\n\nAlgorithm for exporting of the stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\"inspectormeth\" = inspector method to pass to inspectintegpoints()\n\"extrap\" = method for extrapolating from the quadrature points to the nodes within one element\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - nodal field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.exportstresselementwise-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.exportstresselementwise","text":"AlgoDeforLinearModule.exportstresselementwise(modeldata::FDataDict)\n\nAlgorithm for exporting of the elementwise stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.linearstatics-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.linearstatics","text":"AlgoDeforLinearModule.linearstatics(modeldata::FDataDict)\n\nAlgorithm for static linear deformation (stress) analysis.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"traction_bcs\" = array of traction boundary condition dictionaries\n\"temperature_change\" = dictionary of data for temperature change\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element model machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar),  or         a function with signature             function w = f(x)         If not given, zero displacement assumed.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor traction boundary conditions (optional) each dictionary would hold\n\n\"femm\" = finite element model machine (mandatory);\n\"traction_vector\" = traction vector,  either  a constant or  a function     Positive  when outgoing.\n\nOutput\n\nmodeldata = the dictionary on input is augmented with the keys\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"temp\" = the nodal field that is the temperature change\n\"work\" = work of the applied loads\n\"timing\" = dictionary with timing results\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.modal-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.modal","text":"AlgoDeforLinearModule.modal(modeldata::FDataDict)\n\nModal (free-vibration) analysis solver.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar): only zero     displacement is  allowed for modal analysis.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nControl parameters:\n\n\"neigvs\" = number of eigenvalues/eigenvectors to compute\n\"omega_shift\"= angular frequency shift for mass shifting\n\"use_lumped_mass\" = true or false?  (Default is false: consistent mass)\n\nOutput\n\nmodeldata= the dictionary on input is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"neigvs\" = Number of computed eigenvectors\n\"W\" = Computed eigenvectors, neigvs columns\n\"omega\" =  Computed angular frequencies, array of length neigvs\n\"raw_eigenvalues\" = Raw computed eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoDeforLinearModule.ssit-Tuple{Any,Any}","page":"Functions","title":"FinEtools.AlgoDeforLinearModule.ssit","text":"ssit(K, M; nev::Int=6, evshift::FFlt = 0.0,\n    v0::FFltMat = Array{FFlt}(0, 0),\n    tol::FFlt = 1.0e-3, maxiter::Int = 300, verbose::Bool=false)\n\nSubspace  Iteration (block inverse power) method.\n\nBlock inverse power method for k smallest eigenvalues of the generalized eigenvalue problem            K*v= lambda*M*v\n\nArguments\n\nK =  square symmetric stiffness matrix (if necessary mass-shifted),\nM =  square symmetric mass matrix,\n\nKeyword arguments\n\nv0 =  initial guess of the eigenvectors (for instance random),\nnev = the number of eigenvalues sought\ntol = relative tolerance on the eigenvalue, expressed in terms of norms of the     change of the eigenvalue estimates from iteration to iteration.\nmaxiter =  maximum number of allowed iterations\nwithrr = with Rayleigh-Ritz problem solved to improve the subspace?  (default   is false)\nverbose = verbose? (default is false)\n\nOutput\n\nlabm = computed eigenvalues,\nv = computed eigenvectors,\nnconv = number of converged eigenvalues\nniter = number of iterations taken\nnmult = ignore this output\nlamberr = eigenvalue errors, defined as  normalized  differences  of   successive  estimates of the eigenvalues\n\n\n\n\n\n","category":"method"}]
}
