<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · FinEtools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li class="current"><a class="toctext" href="guide.html">Guide</a><ul class="internal"><li><a class="toctext" href="#Modules-1">Modules</a></li><li><a class="toctext" href="#Arithmetic-types-1">Arithmetic types</a></li><li><a class="toctext" href="#Physical-units-1">Physical units</a></li><li><a class="toctext" href="#Mesh-entities-1">Mesh entities</a></li><li><a class="toctext" href="#Mesh-generation-1">Mesh generation</a></li><li><a class="toctext" href="#Selection-of-mesh-entities-1">Selection of mesh entities</a></li><li><a class="toctext" href="#Fields-1">Fields</a></li><li><a class="toctext" href="#Finite-element-1">Finite element</a></li><li><a class="toctext" href="#Integration-1">Integration</a></li><li><a class="toctext" href="#FEM-machines-1">FEM machines</a></li><li><a class="toctext" href="#Material-and-Material-Orientation-1">Material and Material Orientation</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li><a class="toctext" href="#Queries-of-quadrature-point-data-1">Queries of quadrature-point data</a></li><li><a class="toctext" href="#Postprocessing-1">Postprocessing</a></li><li><a class="toctext" href="#Import/export-1">Import/export</a></li><li><a class="toctext" href="#Tutorials-and-Examples-1">Tutorials and Examples</a></li><li><a class="toctext" href="#Make-up-your-own-public-interface-1">Make up your own public interface</a></li></ul></li><li><span class="toctext">Types and Functions</span><ul><li><a class="toctext" href="../man/types.html">Types</a></li><li><a class="toctext" href="../man/functions.html">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="guide.html">Guide</a></li></ul><a class="edit-page" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/guide/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guide</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://petrkryslucsd.github.io/FinEtools.jl/latest/index.html">Table of contents</a></p><h1><a class="nav-anchor" id="Guide-1" href="#Guide-1">Guide</a></h1><h2><a class="nav-anchor" id="Modules-1" href="#Modules-1">Modules</a></h2><p>The FinEtools package consists of many modules which fall into several  categories. The top-level module, <code>FinEtools</code>, includes all other modules and exports functions to constitute the public interface. The user is free to generate their own public interface, however. More details are provided <a href="guide.html#Make-up-your-own-public-interface-1">Make up your own public interface</a>.</p><ul><li><p>Top-level:    <code>FinEtools</code> is the  top-level module.  For interactive use it is enough to do <code>using FinEtools</code>, however in some  cases functions from modules need to be  brought into the scope individually (most importantly, the algorithm modules). This is the ONLY  module that EXPORTS  functions, none of the other modules exports a single function. The entire  public (i. e. exported) interface of the FinEtools package is specified  in the file <code>FinEtools.jl</code> (i. e. in the <code>FinEtools</code> module). The user is free to specify his or her own set of exported functions from the FinEtools package to create an <a href="guide/rollyourown.html">ad hoc public interface</a>.</p></li><li><p>Utilities:</p></li></ul><p><code>FTypesModule</code> (types), <code>PhysicalUnitModule</code> (definitions of  numbers with physical units), <code>AssemblyModule</code> (assembly of elementwise matrices and vectors),   <code>CSysModule</code> (coordinate system module),    <code>MatrixUtilityModule</code> (utilities for operations on elementwise matrices), <code>BoxModule</code>  (support for working with bounding boxes),  <code>ForceIntensityModule</code> (force-intensity module),        <code>RotationUtilModule</code> (support for spatial rotations).</p><ul><li><p>Mesh  entities: <code>FENodeSetModule</code>, <code>FESetModule</code> (node set and finite element set  types). </p></li><li><p>Mesh Generation:  <code>MeshLineModule</code>,  <code>MeshQuadrilateralModule</code>,   <code>MeshTriangleModule</code>,   <code>MeshTetrahedronModule</code>,             <code>TetRemeshingModule</code>,  <code>VoxelTetMeshingModule</code>,     <code>MeshHexahedronModule</code>,       <code>VoxelBoxModule</code>. </p></li><li><p>Mesh manipulation:  <code>MeshSelectionModule</code> (searching of nodes  and elements),  <code>MeshModificationModule</code> (mesh boundary, merging  of meshes and nodes, smoothing, partitioning),  <code>MeshUtilModule</code> (utilities), <code>FENodeToFEMapModule</code> (search structure from nodes to elements).</p></li><li><p>Mesh import/export:  <code>MeshImportModule</code>,  <code>MeshExportModule</code>.</p></li><li><p>Fields:</p></li></ul><p><code>FieldModule</code>,    <code>GeneralFieldModule</code>, <code>ElementalFieldModule</code>,    <code>NodalFieldModule</code> (modules for representing quantities on the mesh).</p><ul><li>Support for  integration over solids, surfaces, curves, and points:</li></ul><p><code>IntegRuleModule</code>,   <code>IntegDomainModule</code>.</p><ul><li><p>General algorithms: <code>AlgoBaseModule</code> (algorithms), <code>FEMMBaseModule</code> (FEM machine for general tasks).</p></li><li><p>Heat conduction: <code>AlgoHeatDiffModule</code> (algorithms), <code>FEMMHeatDiffModule</code>, <code>FEMMHeatDiffSurfModule</code>  (FEM machines  to evaluate  the  matrix and vector quantities), <code>MatHeatDiffModule</code>  (heat diffusion material)</p></li><li><p>Acoustics: <code>AlgoAcoustModule</code> (algorithms), <code>FEMMAcoustModule</code>, <code>FEMMAcoustSurfModule</code> (FEM machines to evaluate the matrix and vector quantities),  <code>MatAcoustFluidModule</code> (acoustic fluid material).</p></li><li><p>Linear deformation:  <code>AlgoDeforLinearModule</code> (algorithms), <code>DeforModelRedModule</code>,</p></li></ul><p><code>FEMMDeforLinearBaseModule</code>,  <code>FEMMDeforLinearModule</code>, <code>FEMMDeforLinearMSModule</code>,  <code>FEMMDeforWinklerModule</code> (FEM machines to evaluate the matrix and vector quantities), <code>MatDeforModule</code>, <code>MatDeforElastIsoModule</code>, <code>MatDeforElastOrthoModule</code> (elastic material models).</p><h2><a class="nav-anchor" id="Arithmetic-types-1" href="#Arithmetic-types-1">Arithmetic types</a></h2><p>The FinEtools package is fairly strict about typing arguments. The arithmetic types used throughout are <code>FInt</code> for integer data, <code>FFlt</code> for floating-point data, and <code>Complex{FFlt}</code> for applications that work with complex linear algebra quantities.</p><p>The module <code>FTypesModule</code> defines these types, and also defines abbreviations for vectors and matrices with entries of these types.</p><p>Some algorithms expect input in the form of the data dictionary, <code>FDataDict</code>, and also produce output in this form.</p><h2><a class="nav-anchor" id="Physical-units-1" href="#Physical-units-1">Physical units</a></h2><p>The <code>PhysicalUnitModule</code> provides a simple function, <code>phun</code>, which can help with providing input numbers with the correct conversion between physical units. For instance, it is possible to specify the input data as</p><pre><code class="language-julia">E = 200*phun(&quot;GPa&quot;);# Young&#39;s modulus
nu = 0.3;# Poisson ratio
rho = 8000*phun(&quot;KG*M^-3&quot;);# mass density
L = 10.0*phun(&quot;M&quot;); # side of the square plate
t = 0.05*phun(&quot;M&quot;); # thickness of the square plate</code></pre><p>The usual sets of units are included, <code>:US</code>, <code>:IMPERIAL</code>, <code>:CGS</code>, <code>:SIMM</code> (millimeter-based SI units), and <code>:SI</code> (meter-based SI units). The resulting  values assigned to the variables are floating-point numbers, for instance</p><pre><code class="language-julia">julia&gt; E = 200*phun(&quot;GPa&quot;)
2.0e11</code></pre><p>Numbers output by the simulation can also be converted  to appropriate units for printing as</p><pre><code class="language-julia">julia&gt; E/phun(&quot;MPa&quot;)
200000.0</code></pre><h2><a class="nav-anchor" id="Mesh-entities-1" href="#Mesh-entities-1">Mesh entities</a></h2><p>The mesh consists of one set of finite element nodes  and one or more sets of finite elements.</p><p>One of the  organizing principles of the  finite element collection  is that  finite elements can appear as representations of the interior  of the domain, but in a different model as parts of the boundary.  Thus  for instance  4-node  quadrilaterals  are finite elements that represent cross-sections of  axially symmetric models or surfaces  of membranes,  but they are also the boundaries of hexahedral  models.</p><p>A mesh  is generated by one of the functions specialized to a particular finite element type. Thus there are  <a href="guide/meshgen.md">mesh generation</a> functions for lines, triangles, quadrilaterals, tetrahedra, and hexahedra.</p><h2><a class="nav-anchor" id="Mesh-generation-1" href="#Mesh-generation-1">Mesh generation</a></h2><p>As an example,  the following code generates a hexahedral mesh of simple rectangular block.</p><pre><code class="language-julia">fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc)</code></pre><p>The finite element node set and the finite element set  are returned. More complicated meshes can be constructed from such mesh parts. There are  functions for  merging  nodes  and even multiple meshes together.</p><p>The code snippet below  constructs the mesh of an  L-shaped  domain  from  the meshes of three rectangles.</p><pre><code class="language-julia">W = 100. # width of the leg
L = 200. # length of the leg
nL = 15 # number of elements along the length of the leg
nW = 10 # number of elements along the width
tolerance = W / nW / 1.0e5 # tolerance for merging nodes
Meshes = Array{Tuple{FENodeSet,FESet},1}()
push!(Meshes, Q4quadrilateral([0.0 0.0; W W], nW, nW))
push!(Meshes, Q4quadrilateral([-L 0.0; 0.0 W], nL, nW))
push!(Meshes, Q4quadrilateral([0.0 -L; W 0.0], nW, nL))
fens, outputfes = mergenmeshes(Meshes, tolerance);
fes = cat(outputfes[1], cat(outputfes[2], outputfes[3]))</code></pre><p>As an example of the  merging  of nodes to create  the final mesh, consider the creation of  a closed hollow tube.</p><pre><code class="language-julia">fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc) # generate a block
# Shape into a cylinder
R = zeros(3, 3)
for i = 1:count(fens)
    x, y, z = fens.xyz[i,:];
    rotmat3!(R, [0, z, 0])
    Q = [cos(psi * pi / 180) sin(psi * pi / 180) 0;
        -sin(psi * pi / 180) cos(psi * pi / 180) 0;
        0 0 1]
    fens.xyz[i,:] = reshape([x + Rmed - h / 2, y - l / 2, 0], 1, 3) * Q * R;
end
# Merge the nodes where the tube  closes up
candidates = selectnode(fens, box = boundingbox([Rmed - h -Inf 0.0; Rmed + h +Inf 0.0]), inflate = tolerance)
fens, fes = mergenodes(fens, fes,  tolerance, candidates);</code></pre><p>The final mesh used for a simulation  consists of a <em>single  node set</em> and <em>one or more finite element sets</em>. The  finite elements may be  divided into separate sets  to  accommodate different material properties, different orientations of the material  coordinate systems, or different formulations  of the discrete model. The  assignment  of the finite elements to sets  may be based on geometrical proximity, topological connections, or some other characteristic. See the  &quot;mesh selection&quot; <a href="guide/selection.html">discussion</a> for details.</p><h3><a class="nav-anchor" id="Structured-mesh-generation-1" href="#Structured-mesh-generation-1">Structured mesh generation</a></h3><p>The simplest possible meshes can be generated in the form of one-dimensional, two-dimensional, and three-dimensional blocks. The spacing of the nodes can be either uniform (for instance <code>Q8block</code>), or the spacing can be given with an arbitrary distribution (for instance <code>Q4blockx</code>). Meshes of tetrahedra can be generated in various orientations of the &quot;diagonals&quot;.</p><p>More complex meshes can be generated for certain element types: for instance an annulus (<code>Q4annulus</code>), quarter of a plate with a hole (<code>Q4elliphole</code>), quarter of a sphere (<code>H8spheren</code>), layered plate (<code>H8layeredplatex</code>).</p><p>Hexahedral meshes can also be created by extrusion of  quadrilateral meshes (<code>H8extrudeQ4</code>).</p><h3><a class="nav-anchor" id="Shaping-1" href="#Shaping-1">Shaping</a></h3><p>Simple meshes  such as blocks can be deformed into geometrically complex shapes, for instance  by tapering  or oother relocation of the nodes. For instance, we can generate a block  and then bend it  into one quarter  of  an annulus as</p><pre><code class="language-julia">fens,fes = Q4block(rex-rin,pi/2,5,20);
for i=1:count(fens)
    r=rin+fens.xyz[i,1]; a=fens.xyz[i,2];
    fens.xyz[i,:]=[r*cos(a) r*sin(a)];
end</code></pre><h3><a class="nav-anchor" id="Merging-1" href="#Merging-1">Merging</a></h3><p>Multiple mesh regions  can be generated and then merged together into a single mesh. Refer to the <code>MeshModificationModule</code>. Meshes can be also mirrored.</p><h3><a class="nav-anchor" id="Biomedical-image-mesh-generation-1" href="#Biomedical-image-mesh-generation-1">Biomedical image mesh generation</a></h3><p>The function <code>H8voximg</code> can generate a hexahedral mesh from a three-dimensional image (such as a CT scan). The resulting meshes can be smoothed (<code>meshsmoothing</code>).</p><p>A similar functionality  is also available for tetrahedra (<code>T4voximg</code>). A more sophisticated strategy is available in the <code>VoxelTetMeshingModule</code> module: the initial mesh can be progressively coarsened and smoothed, resulting  in a much more realistic looking geometry compared  to the initial jagged representation.</p><h3><a class="nav-anchor" id="Boundary-extraction-1" href="#Boundary-extraction-1">Boundary extraction</a></h3><p>Mesh  composed of  any element type can be passed to the function  <code>meshboundary</code>, and  the boundary of the mesh is extracted. As an example, the code</p><pre><code class="language-julia">fens,fes = Q4block(rex-rin,pi/2,5,20);
bdryfes = meshboundary(fes);</code></pre><p>generates a mesh of quadrilaterals in the set <code>fes</code>,  and <code>bdryfes = meshboundary(fes)</code> finds the boundary elements of the type L2 (line elements with two nodes) and stores them in the  finite element set <code>bdryfes</code>.</p><h3><a class="nav-anchor" id="Conversion-between-element-types-1" href="#Conversion-between-element-types-1">Conversion  between element types</a></h3><p>For any element shape  (line, triangle,  quadrilateral, hexahedron, tetrahedron) there is  the linear version and the quadratic version. Conversion routines are provided so tthat, for example, mesh can be generated as eight-node  hexahedra  and then converted  to twenty node hexahedra as</p><pre><code class="language-julia">fens,fes = H8toH20(fens,fes)</code></pre><p>Other conversion routines NEEDS  TO BE WRITTEN</p><h3><a class="nav-anchor" id="Refinement-1" href="#Refinement-1">Refinement</a></h3><p>Meshes composed of some  element types can be uniformly refined. For instance, quadrilateral meshes can be refined by bisection with <code>Q4refine</code>.</p><h2><a class="nav-anchor" id="Selection-of-mesh-entities-1" href="#Selection-of-mesh-entities-1">Selection of mesh entities</a></h2><p>There are many instances of problem definitions where it is important to partition meshes into subsets. As an example,  consider a tube consisting of inner ABS core and  outer fiber-reinforced  laminate  layer. The mesh may consist  of hexahedra.  This mesh would then need to be partitioned into two subsets, because the materials and the  material orientation data  are different between the two regions.</p><p>As another example, consider a simple beam  of rectangular cross-section, clamped  at one end,  and  loaded with shear tractions at the  free end. The  entire boundary of the beam needs to be separated  into three subsets:  the first subset,  for the traction-free boundary, is ignored. The second subset, for the clamped cross-section, is extracted  and  its nodes  are used  to  formulate the essential boundary condition. The third subset is extracted and used to define an FEM machine to compute the load vector due to the shear traction.</p><p>There are  several  ways  in which mesh entities (nodes and finite elements) can be selected. The simplest uses element labels: some mesh-generation routines label the generated elements. For example,</p><pre><code class="language-julia">fens,fes = H8layeredplatex(xs, ys, ts, nts)</code></pre><p>generates a plate-like mesh where the layers are labeled. It is therefore possible to select  the bottom-most layer as</p><pre><code class="language-julia">rls = selectelem(fens, fes, label = 1)</code></pre><p>where <code>rls</code> is a list of integer indexes into the  set <code>fes</code>, so that we can extract a subset corresponding to this layer as</p><pre><code class="language-julia">botskin = subset(fes, rls)</code></pre><p>Geometrical techniques for selecting finite elements  or nodes can be based on</p><ul><li>the location within or overlap  with boxes;</li><li>distance from  a given point;</li><li>distance from a given plane;</li><li>connectedness (selection by flooding).</li></ul><p>Additionally, surface-like  finite elements (quadrilaterals and triangles embedded in three dimensions, or lines embedded in two dimensions) can be selected based upon the orientation of their normal (<code>facing</code>  criterion).</p><p>As an example, consider a straight duct with anechoic termination. A triangle mesh is generated as</p><pre><code class="language-julia">fens,fes  =  T3block(Lx,Ly,n,2);</code></pre><p>and its boundary is extracted as</p><pre><code class="language-julia">bfes  =  meshboundary(fes)</code></pre><p>The finite elements from the  piece of the boundary on the left parallel to the Y axis can be extracted as</p><pre><code class="language-julia">L0 = selectelem(fens,bfes,facing = true, direction = [-1.0 0.0])</code></pre><p>where the numbers of the finite elements  whose normals point in the general direction of the vector [-1.0 0.0] are returned in the integer array <code>L0</code>.</p><h2><a class="nav-anchor" id="Fields-1" href="#Fields-1">Fields</a></h2><p>The structure to maintain the numbering  and values of the degrees of freedom in the mesh  is the field.</p><h3><a class="nav-anchor" id="Abstract-Field-1" href="#Abstract-Field-1">Abstract  Field</a></h3><p>The assumption is that a field has one set of degrees of freedom per node or per element. For simplicity we will refer to the nodes and elements as entities. It assumes that concrete  subtypes of the abstract field  have the following data, one row per entity:</p><ul><li><code>values::FMat{T}</code>: Array of the values of the degrees of freedom, one row  for each entity. All the arrays below have the same dimensions as this one.</li><li><code>dofnums::FIntMat</code>: Array  of the numbers of the free degrees of freedom. If the degree of freedom is fixed (prescribed), the corresponding entry is zero.</li><li><code>is_fixed::Matrix{Bool}</code>: Array of  Boolean flags,  <code>true</code> for fixed  (prescribed) degrees of freedom, <code>false</code> otherwise.</li><li><code>fixed_values::FMat{T}</code>: Array  of the same size and type  as  <code>values</code>. Its entries are only relevant  for the fixed (prescribed)  degrees of freedom.</li><li><code>nfreedofs::FInt</code>:  the total number of free degrees of freedom.</li></ul><p>The methods defined for the abstract field  include:</p><ul><li><p>Return the number of degrees of freedom and the number of entities.</p></li><li><p>Gather and scatter the system vector.</p></li><li><p>Gather elementwise  vectors or matrices of values, the degree of freedom numbers, or the fixed values of the degrees of freedom.</p></li><li><p>Set  or clear essential boundary conditions..</p></li><li><p>Copy a field. Clear the entries of the field.</p></li></ul><h3><a class="nav-anchor" id="Nodal-Field-1" href="#Nodal-Field-1">Nodal Field</a></h3><p>In this case  the  abstract field is subtyped to a concrete field where the entities are nodes.</p><h3><a class="nav-anchor" id="Elemental-Field-1" href="#Elemental-Field-1">Elemental Field</a></h3><p>In this case  the  abstract field  is subtyped to a concrete field where the entities are the elements.</p><h3><a class="nav-anchor" id="General-Field-1" href="#General-Field-1">General Field</a></h3><p>In this case  the  abstract field  is subtyped to a concrete field where the entities are  use-case  specific.</p><h3><a class="nav-anchor" id="Numbering-of-the-degrees-of-freedom-1" href="#Numbering-of-the-degrees-of-freedom-1">Numbering of the degrees of freedom</a></h3><p>The simplest method is at the moment implemented: number all free degrees of freedom, row-by-row and column-by-column, starting from 1 up to <code>f.nfreedofs</code>, for the field <code>f</code>.</p><p>The prescribed degrees of freedom are not numbered, and the prescribed degrees of freedom are marked with 0.</p><h2><a class="nav-anchor" id="Finite-element-1" href="#Finite-element-1">Finite element</a></h2><p>The  finite element set is one of the basic entities in FinEtools.</p><p>The finite element set is a collection of  finite elements defined by the connectivity (collection of node numbers, listing the nodes connected by the element in  a specific order). The finite element set  provides  specialized methods  to compute values of basis functions and the values of  the gradients of the basis functions  with respect to the parametric coordinates.</p><h3><a class="nav-anchor" id="Element-types-1" href="#Element-types-1">Element types</a></h3><p>The finite element sets are instances of concrete types. Each particular shape and order of element has its own type. There are types for  linear  and quadratic quadrilaterals, for instance, <code>FESetQ4</code> and <code>FESetQ8</code>. Each element set provides access to the number of nodes  connected by the element (<code>nodesperelem</code>),  the connectivity as the two dimensional array    <code>conn</code>,  and the  integer label vector <code>label</code>.</p><p>The concrete finite element set types are subtypes of the abstract type for elements of different manifold dimension (3, 2, 1, and 0), for instance for the quadrilaterals that would be <code>AbstractFESet2Manifold</code>. These types are in turn  subtypes of the abstract finite element set type <code>AbstractFESet</code>.</p><p>The concrete finite element set type provides specialized methods to compute the values of the basis functions, <code>bfun</code>, and methods to compute  the gradients of the basis functions with respect to the parametric coordinates, <code>bfundpar</code>.</p><h3><a class="nav-anchor" id="Finite-element-set-functions-1" href="#Finite-element-set-functions-1">Finite element set functions</a></h3><ul><li><p>Methods defined for  the abstract type:</p><ul><li><code>nodesperelem</code>: Get the number of nodes  connected  by  the finite element.</li><li><code>count</code>:  Get the number of individual connectivities in the FE set.</li><li><code>setlabel!</code>: Set the label of the entire finite elements set.</li><li><code>connasarray</code>: Retrieve  connectivity  as an integer array.</li><li><code>fromarray!</code>: Set  connectivity from an integer array.</li><li><code>subset</code>: Extract a subset of the finite elements from the given finite element set.</li><li><code>cat</code>: Concatenate the connectivities of two FE sets.</li><li><code>updateconn!</code>: Update the connectivity after the IDs of nodes changed.</li><li><code>map2parametric</code>: Map a spatial location to parametric coordinates.</li></ul></li><li><p>Methods dispatched based on the manifold type:</p><ul><li><code>manifdim</code>: Return the manifold dimension.</li><li><code>Jacobian</code>: Evaluate the  Jacobian.</li><li><code>gradN!</code>: Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</li></ul></li><li><p>Methods dispatched on the concrete type:</p><ul><li><code>boundaryconn</code>: Get boundary connectivity.</li><li><code>boundaryfe</code>: Return the constructor of the type of the boundary finite element.</li><li><code>bfun</code>: Compute the values of the basis functions at a given parametric coordinate.</li><li><code>bfundpar</code>: Compute the values of the basis function gradients at a given parametric coordinate.</li><li><code>inparametric</code>: Are given parametric coordinates inside the element parametric domain?</li><li><code>centroidparametric</code>: Return the parametric coordinates  of the centroid of the element.</li></ul></li></ul><h2><a class="nav-anchor" id="Integration-1" href="#Integration-1">Integration</a></h2><p>There are two kinds of integrals in the weighted-residual finite element method: integrals over the interior  of the domain,  and integrals over the boundary of the domain.</p><p>Consequently, in a typical simulation one would need  two meshes: one for the interior  of the domain,  and one for the boundary. Obviously, the one for the boundary will be derived from the mesh  constructed for the interior.</p><p>Often only a part  of the entire boundary   is   used:  on some parts of the boundary  the  boundary condition is implied as homogeneous (i. e. zero). For instance, a traction-free boundary. Therefore the necessary integrals are typically evaluated over a subset of the entire boundary.</p><h3><a class="nav-anchor" id="Manifold-dimension-1" href="#Manifold-dimension-1">Manifold dimension</a></h3><p>Finite elements  have  a certain manifold dimension.  Tetrahedra  and hexahedra are three-manifolds, triangles and quadrilaterals are two-manifolds, triangles and quadrilaterals are two-manifolds, lines are one-manifolds, and points are zero-manifolds.</p><p>Elements are equipped with an &quot;other&quot; dimension which boosts the manifold dimension to produce the required dimension for  the integration. For instance,  a line element can be equipped with an &quot;other&quot; dimension to represent a cross-section so that a volume integral can be evaluated over a line element. Or, a line element can be given an &quot;other&quot; dimension as a thickness to result in a physical dimension needed to evaluate a surface integral.</p><p>The &quot;other&quot;  dimension  has the following meaning  for finite elements of different manifold dimensions:</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Volume integral</th><th style="text-align: right">Surface integral</th></tr><tr><td style="text-align: right">3</td><td style="text-align: right">NA</td><td style="text-align: right">NA</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">Thickness</td><td style="text-align: right">NA</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">Cross-section</td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right">Volume</td><td style="text-align: right">Cross-section</td></tr></table><h3><a class="nav-anchor" id="Integration-over-the-interior-1" href="#Integration-over-the-interior-1">Integration  over the interior</a></h3><p>The integrals are always  <em>volume</em> integrals. This means that for elements which are of  lower manifold dimension than three the &quot;other&quot;  dimension needs to compensate.</p><p>For  three-manifold finite elements (tetrahedra and hexahedra) the &quot;other&quot; dimension is always 1.0. This really means there is no &quot;other&quot; dimension to a volume-like element.</p><p>For  finite elements of manifold dimension  less than tthree, the  &quot;other&quot; dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Axially symmetric</th><th style="text-align: right">Plane 2D</th></tr><tr><td style="text-align: right">2</td><td style="text-align: right"><span>$2\pi r$</span></td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right"><span>$2\pi r\times$</span>  Thickness</td><td style="text-align: right">Cross-section</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right"><span>$2\pi r\times$</span> Cross-section</td><td style="text-align: right">Volume</td></tr></table><p>The integral  is approximated with numerical quadrature as</p><div>\[\int_{\Omega} f dV \approx \sum_q f(\xi_q) J(\xi_q) W_q\]</div><p>Here <span>$f$</span>  is the integrand, <span>$f(\xi_q)$</span>  is the  value of the integrand  at the quadrature point, <span>$J(\xi_q)$</span>  is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the &quot;other&quot; dimension,  and therefore it is the  <em>volume</em> Jacobian. (For the interior integrals the Jacobian  is computed by the <code>Jacobianvolume</code> method.)</p><h3><a class="nav-anchor" id="Integration-over-the-boundary-1" href="#Integration-over-the-boundary-1">Integration  over the boundary</a></h3><p>The integrals are always  <em>surface</em> integrals. This means that for elements which are of  lower manifold dimension than two the &quot;other&quot;  dimension needs to compensate.</p><p>For  two-manifold finite elements (triangles and quadrilaterals) the &quot;other&quot; dimension is always 1.0. This really means there is no &quot;other&quot; dimension to a surface-like element.</p><p>For  finite elements of manifold dimension  less than two, the  &quot;other&quot; dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.</p><table><tr><th style="text-align: right">Manifold dimension</th><th style="text-align: right">Axially symmetric</th><th style="text-align: right">Plane 2D</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right"><span>$2\pi r$</span></td><td style="text-align: right">Thickness</td></tr><tr><td style="text-align: right">0</td><td style="text-align: right"><span>$2\pi r\times$</span>   Thickness</td><td style="text-align: right">Cross-section</td></tr></table><p>The integral  is approximated with numerical quadrature as</p><div>\[\int_{\partial \Omega} f dS \approx \sum_q f(\xi_q) J(\xi_q) W_q  \]</div><p>Here <span>$f$</span>  is the integrand, <span>$f(\xi_q)$</span> is the  value of the integrand  at the quadrature point, <span>$J(\xi_q)$</span> is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the &quot;other&quot; dimension,  and therefore it is the  <em>surface</em> Jacobian. (For the boundary integrals the Jacobian  is computed by the <code>Jacobiansurface</code> method.)</p><h4><a class="nav-anchor" id="Example:-axially-symmetric-model,-line-element-L2-1" href="#Example:-axially-symmetric-model,-line-element-L2-1">Example: axially symmetric model, line element L2</a></h4><p>The surface Jacobian in this case  is  equal to the curve Jacobian times <code>2*pi*r</code>.</p><h3><a class="nav-anchor" id="Integration-Data-1" href="#Integration-Data-1">Integration Data</a></h3><p>The  module <code>IntegDomainModule</code> supports  the processing of  the geometry necessary for the evaluation of the various integrals. The module data structure  groups together  a finite element set with an appropriate integration rule, information about the model (axially symmetric or not), and a callback to evaluate  the &quot;other&quot; dimension.</p><h3><a class="nav-anchor" id="Other-dimension-1" href="#Other-dimension-1">Other dimension</a></h3><p>The  discussion of the surface and volume integrals introduces the notion  of the  &quot;other&quot;  dimension. In order to evaluate Jacobians of various space dimensions  the  Geometry Data module takes into account  whether or not the model is axially symmetric, and evaluates the &quot;other&quot; dimension based upon this information.</p><p>A finite element set is equipped with  a way of  calculating  the &quot;other&quot; dimension.  For instance, the line element with two nodes, L2, can be given  the &quot;other&quot; dimension  as a  &quot;thickness&quot;  so that  surface integrals  can be evaluated over the line element. However, if this line element  is used in an axially symmetric model, the same  &quot;other&quot; dimension  of &quot;thickness&quot;  will result in the integral  along the length of this line element  being a volume integral.</p><p>Thus, the way in which the &quot;other&quot;  dimension gets used by the Geometry Data methods depends on the model. As an example, consider  the  method</p><pre><code class="language-julia">function Jacobianvolume(self::IntegDomain{T}, J::FFltMat, loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {T&lt;:AbstractFESet2Manifold, CC&lt;:AbstractArray{FInt}}
    Jac = Jacobiansurface(self, J, loc, conn, N)::FFlt
    if self.axisymmetric
        return Jac*2*pi*loc[1];
    else
        return Jac*self.otherdimension(loc, conn,  N)
    end
end</code></pre><p>which  evaluates the volume Jacobian  for an element  of manifold dimension  2  (surface). Note that  first  the surface Jacobian  is calculated, which is then boosted to a volume Jacobian in two different ways, depending on whether  the model is axially symmetric or not. For the axially symmetric case  the &quot;other&quot;  dimension is implied,</p><p>The callback function computes the &quot;other&quot; dimension from  two kinds of  information: (a) the physical location  of the quadrature point,  and (b) the interpolation data for the element  (connectivity and the values of the basis functions at the quadrature point).</p><ul><li>The approach ad (a) is suitable  when the &quot;other&quot; dimension is given as a function of the physical coordinates. The  simplest case is obviously  a uniform distribution of the &quot;other&quot; dimension. When  no  callback is explicitly provided,  the  &quot;other&quot;  dimension  callback is  automatically generated as the trivial</li></ul><pre><code class="language-julia">function otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {CC&lt;:AbstractArray{FInt}}
    return 1.0
end</code></pre><p>which simply returns 1.0 as the default value.</p><ul><li>The approach ad (b) is appropriate when the &quot;other&quot; dimension  is given by values given at the nodes of the  mesh. Than the connectivity  and  the array of the values of the basis functions  can be used to interpolate the &quot;other&quot;  dimension  to the quadrature point.</li></ul><h3><a class="nav-anchor" id="Evaluation-of-integration-data-1" href="#Evaluation-of-integration-data-1">Evaluation of integration data</a></h3><p>Importantly, the  Integration Domain (<code>IntegDomain</code>) method <code>integrationdata</code> evaluates quantities  needed for numerical integration: locations and weights of quadrature points, and the values of basis functions and of the basis function gradients with respect to the parametric coordinates at the quadrature points.</p><h2><a class="nav-anchor" id="FEM-machines-1" href="#FEM-machines-1">FEM machines</a></h2><p>The construction of the matrices and vectors of the discrete form of the weighted residual equation is performed in FEM  machines. (FEM = Finite Element Method.)</p><p>As an example consider the weighted-residual form of the heat balance equation</p><div>\[\int_{V}  \vartheta c_V\frac{\partial T}{\partial t} \; \mathrm{d} V
            +\int_{V}(\mathrm{grad}\vartheta)\; \kappa (\mathrm{grad}T
            )^T\; \mathrm{d} V
            -\int_{V}  \vartheta Q \; \mathrm{d} V  
            +\int_{S_2} \vartheta\;\overline{q}_{n}\; \mathrm{d} S+ \int_{S_3} \vartheta\;h
            (T-T_a)  \; \mathrm{d} S = 0\]</div><p>where <span>$\vartheta(x) =0$</span>  for  <span>$x \in{S_1}$</span> .</p><p>The  test function is  taken to be  one  finite element basis function at a time, <span>$\vartheta = N_{\left&lt;j\right&gt;}$</span>, and the trial function is</p><div>\[T = \sum_{i= 1} ^{N} N_{\left&lt;i\right&gt;} T_i .\]</div><p>Here by <span>$N_{\left&lt;j\right&gt;}$</span> we mean the basis function constructed on the mesh and associated with the node <span>$\left&lt;j\right&gt;$</span>. We use the notation inspected times two to mean node number at which the degree of freedom  <span>$j$</span> lives.</p><p>Now the test function and the trial function is substituted  into the  weighted residual equation.  </p><h3><a class="nav-anchor" id="Example:-internal-heat-generation-rate-term-1" href="#Example:-internal-heat-generation-rate-term-1">Example:  internal heat generation rate term</a></h3><p>For instance,  for the term</p><div>\[\int_{V}  \vartheta Q \; \mathrm{d} V\]</div><p>we obtain</p><div>\[\int_{V} N_{\left&lt;j\right&gt;} Q \; \mathrm{d} V\]</div><p>This integral evaluates to a number, the heat load  applied to the degree of freedom <span>$j$</span>. When these numbers are evaluated for all  the free degrees of freedom,  they constitute the entries of the global heat load vector.</p><p>Evaluating integrals of this form is so common that there is a module <code>FEMMBaseModule</code> with the method <code>distribloads</code> that computes and assembles the global vector. For instance to evaluate this heat load vector  on the mesh composed of three-node triangles, for a uniform heat generation rate <code>Q</code>, we can write</p><pre><code class="language-julia">fi = ForceIntensity(FFlt[Q]);
F1 = distribloads(FEMMBase(IntegDomain(fes, TriRule(1))), geom, Temp, fi, 3);</code></pre><p><code>IntegDomain(fes, TriRule(1))</code> constructs integration domain for the  finite elements <code>fes</code> using a triangular  integration rule with a single point. <code>FEMMBase</code> is the base  FEM  machine,  and all it needs at this point is the integration domain. The method  <code>distribloads</code> is defined for the  base FEM machine, the geometry field <code>geom</code>, the numbering of the degrees of freedom is taken from the field <code>Temp</code>, the internal heat generation rate is defined as the force intensity <code>fi</code>, and the integrals  are volume integrals  (3).</p><h3><a class="nav-anchor" id="Example:-conductivity-term-1" href="#Example:-conductivity-term-1">Example: conductivity term</a></h3><p>The conductivity term from the weighted residual equation</p><div>\[\int_{V}(\mathrm{grad}\vartheta)\; \kappa (\mathrm{grad}T
            )^T\; \mathrm{d} V\]</div><p>is rewritten with the test and trial functions as</p><div>\[\sum_{i=1}^N \int_{V}(\mathrm{grad}N_{\left&lt;j\right&gt;})\; \kappa (\mathrm{grad}N_{\left&lt;i\right&gt;}
            )^T\; \mathrm{d} V \; T_i\]</div><p>The sum over the degree of freedom number <span>$i$</span> should be split: some of the  coefficients <span>$T_i$</span> are for free degrees of freedom (<span>$1 \le i \le  N_{\mathrm{f}}$</span>, with <span>$N_{\mathrm{f}}$</span> being the total number of free degrees of freedom), while some are  fixed (prescribed) for nodes  which are located on the essential boundary condition surface <span>$S_1$</span>  (<span>$N_{\mathrm{f}} &lt; i \le N$</span>).</p><p>Thus the term splits into two  pieces,</p><div>\[\sum_{i=1}^{N_{\mathrm{f}}} \int_{V}(\mathrm{grad}N_{\left&lt;j\right&gt;})\; \kappa (\mathrm{grad}N_{\left&lt;i\right&gt;}
            )^T\; \mathrm{d} V \; T_i\]</div><p>where the  individual integrals are entries of the conductivity matrix, and</p><div>\[\sum_{i=N_{\mathrm{f}}+1}^N \int_{V}(\mathrm{grad}N_{\left&lt;j\right&gt;})\; \kappa (\mathrm{grad}N_{\left&lt;i\right&gt;}
            )^T\; \mathrm{d} V \; T_i\]</div><p>which  will represent heat loads  due to nonzero  prescribed boundary condition.</p><p>The FEM machine  for heat conduction  can be created as</p><pre><code class="language-julia">material = MatHeatDiff(thermal_conductivity)
femm = FEMMHeatDiff(IntegDomain(fes, TriRule(1)), material)</code></pre><p>where we first create a <code>material</code> to  deliver the thermal conductivity matrix <span>$\kappa$</span>, and then  we create  the FEM  machine  from the integration domain  for a mesh  consisting of three node triangles, using one-point integration rule, and the material. This  FEM machine  can then be passed to a method</p><pre><code class="language-julia">K = conductivity(femm, geom, Temp)</code></pre><p>to evaluate the global conductivity matrix <code>K</code>, where the geometry comes from the geometry field <code>geom</code>, and the temperature field <code>Temp</code> provides the  numbering of the degrees of freedom.</p><p>The heat load term  due to the  nonzero essential boundary conditions  is evaluated with the method <code>nzebcloadsconductivity</code></p><pre><code class="language-julia">F2 = nzebcloadsconductivity(femm, geom, Temp);</code></pre><p>where the geometry comes from the geometry field <code>geom</code>, and the temperature field <code>Temp</code> provides the  numbering of the degrees of freedom and the values of the prescribed (fixed) degrees of freedom. The result is a contribution to the global heat load vector.</p><h3><a class="nav-anchor" id="Base-FEM-machine-1" href="#Base-FEM-machine-1">Base FEM machine</a></h3><p>The following  operations are provided  by the base FEM machine:</p><ul><li><p>Integrate  a function expressed in terms of a field. This is typically used  to  evaluate RMS discretization errors.</p></li><li><p>Integrate a function of the position. Perhaps the evaluation of the moments of inertia,  or the calculation of the volume.</p></li><li><p>Transfer field between meshes of different resolutions.</p></li><li><p>Calculate  the distributed-load system vector.</p></li><li><p>Construct a field  from integration-point quantities. This is typically used in the postprocessing phase, for instance to construct continuous distribution of stresses in the structure.</p></li></ul><h3><a class="nav-anchor" id="Acoustics-FEM-machines-1" href="#Acoustics-FEM-machines-1">Acoustics FEM machines</a></h3><p>There is one for  the interior integrals  and one for  boundary integrals. The  machine for the interior integrals can be used to compute:</p><ul><li><p>Evaluate the acoustic-mass matrix and the acoustic-stiffness matrix.</p></li><li><p>Evaluate the load vector corresponding to prescribed pressure  or the prescribed second order  rate of the pressure.</p></li></ul><p>The machine for the boundary integrals can be used to compute:</p><ul><li><p>Compute  transformation matrix to convert  pressure  to resultant force  or pressure to resultant torque.</p></li><li><p>Compute the acoustic  ABC  (absorbing boundary condition) matrix.</p></li></ul><h3><a class="nav-anchor" id="Heat-conduction-FEM-machines-1" href="#Heat-conduction-FEM-machines-1">Heat  conduction FEM machines</a></h3><p>There is one for  the interior integrals  and one for  boundary integrals. The  machine for the interior integrals can be used to compute:</p><ul><li><p>Evaluate the conductivity matrix.</p></li><li><p>Evaluate the load vector corresponding to prescribed temperature.</p></li></ul><p>The machine for the boundary integrals can be used to compute:</p><ul><li><p>Compute surface heat transfer  matrix.</p></li><li><p>Compute  the heat load vector for surface heat transfer.</p></li><li><p>Compute the heat load vector  corresponding to prescribed temperatures on the boundary  with surface heat transfer.</p></li></ul><h3><a class="nav-anchor" id="Linear-deformation-FEM-machines-1" href="#Linear-deformation-FEM-machines-1">Linear deformation FEM  machines</a></h3><p>For  the base machine for linear deformation, <code>FEMMDeforLinearBase</code>, assumes standard isoparametric  finite elements. It evaluates  the interior integrals:</p><ul><li><p>The stiffness matrix, the mass matrix.</p></li><li><p>The load vector corresponding to thermal strains.</p></li></ul><p>Additionally:</p><ul><li>Function to inspect  integration points.</li></ul><p>The FEM machine <code>FEMMDeforLinear</code> simply stores the data required by the base <code>FEMMDeforLinearBase</code>.</p><p>The machine <code>FEMMDeforWinkler</code> is specialized for the boundary integrals for bodies  supported  on continuously distributed springs:</p><ul><li>Compute the stiffness matrix corresponding to the springs.</li></ul><p>The  mean-strain FEM machine <code>FEMMDeforLinearMS</code> implements advanced hexahedral and tetrahedral elements based on multi-field theory and  energy-sampling  stabilization. It provides functions to compute:</p><ul><li><p>The stiffness matrix, the mass matrix.</p></li><li><p>The load vector corresponding to thermal strains.</p></li></ul><p>Additionally it defines:</p><ul><li>Function to inspect  integration points.</li></ul><h2><a class="nav-anchor" id="Material-and-Material-Orientation-1" href="#Material-and-Material-Orientation-1">Material and Material Orientation</a></h2><p>The material response  is described in  material-point-attached coordinate system. These coordinate systems  are Cartesian, and the material coordinate system is typically chosen to make  the response particularly simple.  So for orthotropic or transversely isotropic materials the axes would be aligned with the axes of orthotropy.</p><p>The type <code>CSys</code> (module <code>CSysModule</code>) is the updater of the material coordinate system matrix. The object is equipped with a callback to store the current orientation matrix. For instance: the coordinate system for an orthotropic material wound around a cylinder could be described in the coordinate system <code>CSys(3, 3, updatecs!)</code>, where the callback is defined as</p><pre><code class="language-julia">function updatecs!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    csmatout[:, 2] = [0.0 0.0 1.0]
    csmatout[:, 3] = XYZ
    csmatout[3, 3] = 0.0
    csmatout[:, 3] = csmatout[:, 3]/norm(csmatout[:, 3])
    csmatout[:, 1] = cross(csmatout[:, 2], csmatout[:, 3])
end</code></pre><h3><a class="nav-anchor" id="Materials-for-linear-deformation-analysis-1" href="#Materials-for-linear-deformation-analysis-1">Materials for linear deformation analysis</a></h3><p>The module <code>MatDeforModule</code> provides functions to convert between vector and matrix (tensor) representations of stress and strain. Further, functions to rotate stress and strain between different coordinate systems (based upon the model-reduction type, 3-D, 2-D, or 1-D) are provided.</p><p>Currently  there are material types for isotropic and orthotropic linear elastic materials. The user may add  additional material types by deriving from <code>AbstractMatDefor</code> and equipping them with three methods: (1) compute the tangent moduli, (2) update the material state, (3) compute the thermal strain.</p><p>For full generality, material types  should implement these methods for fully three-dimensional, plane strain and plane stress, 2D axially symmetric, and one-dimensional deformation models.</p><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><p>Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.</p><p>Algorithms typically (not always) accept a single argument, <code>modeldata</code>, a dictionary of data, keyed by Strings. Algorithms  also return <code>modeldata</code>,  typically  including additional key/value pairs that represent the data computed by the algorithm.</p><h3><a class="nav-anchor" id="Base-algorithms-1" href="#Base-algorithms-1">Base algorithms</a></h3><p>These are not specific to the particular physics at hand. Examples of  algorithms are  Richardson extrapolation,  calculation of the norm of the field, or calculation of the norm  of the difference of two fields. These algorithms are the exceptions, they do not return <code>modeldata</code> but rather return directly computed values.</p><h3><a class="nav-anchor" id="Acoustics-algorithms-1" href="#Acoustics-algorithms-1">Acoustics algorithms</a></h3><p>At the moment there is one algorithm, for steady-state (harmonic) acoustics.</p><h4><a class="nav-anchor" id="Example:-baffled-piston-1" href="#Example:-baffled-piston-1">Example:  baffled piston</a></h4><p>After the mesh  has been generated, the <code>modeldata</code> can be set up: Here we begin with  the region.</p><pre><code class="language-julia">material = MatAcoustFluid(bulk, rho)
region1 =  FDataDict(&quot;femm&quot;=&gt;FEMMAcoust(IntegDomain(fes, GaussRule(3, 2)), material))</code></pre><p>We set up a definition of the absorbing boundary condition:</p><pre><code class="language-julia">abc1  =  FDataDict(&quot;femm&quot;=&gt;FEMMAcoustSurf(IntegDomain(outer_fes, GaussRule(2, 2)),
          material))</code></pre><p>The  surface of the piston is associated with a known-flux  boundary condition:</p><pre><code class="language-julia">flux1  =  FDataDict(&quot;femm&quot;=&gt;FEMMAcoustSurf(IntegDomain(piston_fes, GaussRule(2, 2)),
          material),  &quot;normal_flux&quot;=&gt; -rho*a_piston+0.0im);</code></pre><p>And finally we make the model data,</p><pre><code class="language-julia">modeldata =  FDataDict(&quot;fens&quot;=&gt;  fens,
                 &quot;omega&quot;=&gt;omega,
                 &quot;regions&quot;=&gt;[region1],
                 &quot;flux_bcs&quot;=&gt;[flux1], &quot;ABCs&quot;=&gt;[abc1])</code></pre><p>and call  the solver:</p><pre><code class="language-julia">modeldata = FinEtools.AlgoAcoustModule.steadystate(modeldata)</code></pre><p>When  the algorithm completes, <code>modeldata[&quot;P&quot;]</code> is the computed pressure field.</p><h3><a class="nav-anchor" id="Heat-diffusion-algorithms-1" href="#Heat-diffusion-algorithms-1">Heat diffusion algorithms</a></h3><p>There is an implementation of an algorithm for steady-state heat conduction.</p><h3><a class="nav-anchor" id="Linear-deformation-algorithms-1" href="#Linear-deformation-algorithms-1">Linear deformation algorithms</a></h3><p>There are algorithms for</p><ul><li>Linear static analysis;</li><li>Export  of the deformed shape for visualization;</li><li>Export  of the nodal and elementwise stress fields for visualization;</li><li>Modal (free-vibration) analysis;</li><li>Export  of modal shapes for visualization;</li><li>Subspace-iteration method implementation.</li></ul><h3><a class="nav-anchor" id="Model-data-1" href="#Model-data-1">Model data</a></h3><p>Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method <code>linearstatics</code> of the <code>AlgoDeforLinearModule</code>, the <code>modeldata</code> dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.</p><p>The <code>modeldata</code> may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.</p><h2><a class="nav-anchor" id="Queries-of-quadrature-point-data-1" href="#Queries-of-quadrature-point-data-1">Queries of quadrature-point data</a></h2><p>NEEDS  TO BE WRITTEN</p><h2><a class="nav-anchor" id="Postprocessing-1" href="#Postprocessing-1">Postprocessing</a></h2><h3><a class="nav-anchor" id="Compute-continuous-stress-fields-1" href="#Compute-continuous-stress-fields-1">Compute continuous stress fields</a></h3><h3><a class="nav-anchor" id="Compute-elementwise-stress-fields-1" href="#Compute-elementwise-stress-fields-1">Compute elementwise stress fields</a></h3><p>NEEDS  TO BE WRITTEN</p><h2><a class="nav-anchor" id="Import/export-1" href="#Import/export-1">Import/export</a></h2><h3><a class="nav-anchor" id="Importing-1" href="#Importing-1">Importing</a></h3><p>At the moment importing is mostly limited to the mesh data (properties, boundary conditions, analysis of data, etc. are typically not imported). The following formats of finite element input files can be handled:</p><ul><li>NASTRAN (<code>.nas</code> files).</li><li>Abaqus (<code>.inp</code> files).</li></ul><h3><a class="nav-anchor" id="Exporting-1" href="#Exporting-1">Exporting</a></h3><ul><li>VTK (<code>.vtk</code> so-called legacy files). Export of geometry and fields (nodal and elemental) is supported.</li><li>Abaqus (<code>.inp</code> files). Mesh data and selected property, boundary condition, and procedure commands can be handled.</li><li>NASTRAN (<code>.nas</code> files). Very basic mesh and select other attributes are handled.</li><li>STL file export of surface data.</li><li>H2Lib triangular-surface export (<code>.tri</code> files).</li><li>CSV file export of numerical data is supported.</li></ul><h2><a class="nav-anchor" id="Tutorials-and-Examples-1" href="#Tutorials-and-Examples-1">Tutorials and Examples</a></h2><h3><a class="nav-anchor" id="Tutorials-1" href="#Tutorials-1">Tutorials</a></h3><p>The <code>FinEtools</code> tutorials are written up in the repositories for the applications, heat diffusion, linear and nonlinear deformation and so on.</p><p>The tutorials are in the form of Julia files with markdown. These are converted to markdown files (or to Jupyter notebooks) using the <a href="https://github.com/fredrikekre/Literate.jl">Literate</a> workflow.</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>The examples of the use of the <code>FinEtools</code> package are separated in their own separate repositories, for instance  <a href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl.git"><code>FinEtoolsHeatDiff</code></a>, <a href="https://github.com/PetrKryslUCSD/FinEtoolsAcoustics.jl.git"><code>FinEtoolsAcoustics</code></a>, and so on. For a complete information refer to <a href="https://github.com/PetrKryslUCSD?tab=repositories">the list of the repositories</a>.</p><p>The examples are in the form of  Julia files with multiple functions, where each function defines one or more related examples. Take for instance the example file <code>Fahy_examples.jl</code>. This incantation will run all the examples from the example file:</p><pre><code class="language-none">include(&quot;Fahy_examples.jl&quot;); Fahy_examples.allrun()</code></pre><p>This will run just a single example from this file:</p><pre><code class="language-none">include(&quot;Fahy_examples.jl&quot;); Fahy_examples.fahy_H8_example()</code></pre><p>The example file <code>Fahy_examples.jl</code> consists of a module (whose name matches the name of the file), and  the module defines multiple functions,  one for each example, and one to run <em>all</em> examples, <code>allrun</code>.</p><h3><a class="nav-anchor" id="Tests-1" href="#Tests-1">Tests</a></h3><p>Check out the numerous tests in the <code>test</code> folder. There are hundreds of tests which exercise the various functions of the library. These examples may help you understand how to extract the desired outcome.</p><h2><a class="nav-anchor" id="Make-up-your-own-public-interface-1" href="#Make-up-your-own-public-interface-1">Make up your own public interface</a></h2><p>Here we assume that the FinEtools package is installed. We also assume the user works in his or her own folder, which for simplicity we assume is a package folder in the same tree as the package folder for FinEtools.</p><p>The user may have his or her additions to the FinEtools library, for instance a new material implementation, or a new FEMM (finite element model machine). Additionally, the user writes some code to solve particular problems.</p><p>In order to facilitate interactive work at the command line(REPL), it is convenient to have one or two modules so that <code>using</code> them allows for the user&#39;s code to resolve function names from the FinEtools package and from the user&#39;s own code.</p><p>Here are two ways in which this can be accomplished.</p><ol><li><p>The user exports his or her own additions from the module <code>add2FinEtools</code> (the name of this module is not obligatory, it can be anything). In addition, the public interface to the FinEtools package needs to be brought in separately.</p><p><code>using FinEtools  using add2FinEtools</code></p></li><li><p>The user may change entirely the public interface to the FinEtools package by selectively including parts of the <code>FinEtools.jl</code> file and the code to export his or her own functionality in a single module, let us say <code>myFinEtools</code> (this name is arbitrary), so that when the user invokes</p><p><code>using myFinEtools</code></p><p>all the functionality that the USER considers to be public is made available by exports.</p></li></ol><p>Method 1 has the <em>advantage</em> that the interface definition of the FinEtools package itself does not change, which means that package code does not need to be touched. It also has a <em>disadvantage</em> that the interface to FinEtools does not change which means that if there is a conflict with one of the exported functions from FinEtools, it needs to be resolved by fiddling with other packages.</p><p>Method 2 has the advantage that when there is a conflict between one of the exported FinEtools functions and some other function, be it from another package or the user&#39;s own, the conflict can be resolved by changing the public interface to FinEtools by the USER (as opposed to  by the DEVELOPER). Also, in this method the USER has the power to define the public interface to the FinEtools package, and if the user decides that nothing should be exported for implicit resolution of functions, that is easily accomplished.</p><p>These two methods have been described by examples in the <a href="https://github.com/PetrKryslUCSD/FinEtoolsUseCase">FinEtoolsUseCase</a> package. Refer to the Readme  file and to the method descriptions  in the  method 1 and 2 folders.</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../man/types.html"><span class="direction">Next</span><span class="title">Types</span></a></footer></article></body></html>
