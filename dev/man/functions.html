<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · FinEtools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtools.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../howto/howto.html">How to</a></li><li><a class="tocitem" href="../tutorials/tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li><li><a class="tocitem" href="man.html">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/main/docs/src/man/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="functions.html#Functions">Functions</a></li><li class="no-marker"><ul><li><a href="functions.html#Contents">Contents</a></li><li><a href="functions.html#Physical-units">Physical units</a></li><li><a href="functions.html#Bounding-box-functions">Bounding box functions</a></li><li><a href="functions.html#Coordinate-systems">Coordinate systems</a></li><li><a href="functions.html#Matrix-utilities">Matrix utilities</a></li><li><a href="functions.html#Data-cache">Data cache</a></li><li><a href="functions.html#Surface-normal-utilities">Surface-normal utilities</a></li><li><a href="functions.html#Force-intensity">Force intensity</a></li><li><a href="functions.html#Rotation-utilities">Rotation utilities</a></li><li><a href="functions.html#Finite-element-sets">Finite element sets</a></li><li><a href="functions.html#Finite-element-nodes">Finite element nodes</a></li><li><a href="functions.html#Finite-element-node-to-element-map">Finite element node-to-element map</a></li><li><a href="functions.html#Selecting-nodes-and-elements">Selecting nodes and elements</a></li><li><a href="functions.html#Fields">Fields</a></li><li><a href="functions.html#Integration-rule">Integration rule</a></li><li><a href="functions.html#Integration-domain">Integration domain</a></li><li><a href="functions.html#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a></li><li><a href="functions.html#Meshing">Meshing</a></li><li class="no-marker"><ul><li><a href="functions.html#Meshing-with-line-elements">Meshing with line elements</a></li><li><a href="functions.html#Meshing-with-triangles">Meshing with triangles</a></li><li><a href="functions.html#Meshing-with-quadrilaterals">Meshing with quadrilaterals</a></li><li><a href="functions.html#Meshing-with-tetrahedra">Meshing with tetrahedra</a></li><li><a href="functions.html#Meshing-with-hexahedra">Meshing with hexahedra</a></li><li><a href="functions.html#Mesh-selection">Mesh selection</a></li><li><a href="functions.html#Mesh-modification">Mesh modification</a></li><li><a href="functions.html#Meshing-utilities">Meshing utilities</a></li><li><a href="functions.html#Mesh-import">Mesh import</a></li><li><a href="functions.html#Mesh-export">Mesh export</a></li></ul></li><li><a href="functions.html#FEM-machines">FEM machines</a></li><li class="no-marker"><ul><li><a href="functions.html#Base">Base</a></li></ul></li><li><a href="functions.html#Algorithms">Algorithms</a></li><li class="no-marker"><ul><li><a href="functions.html#Base-2">Base</a></li></ul></li><li><a href="functions.html#Material-models">Material models</a></li><li class="no-marker"><ul><li><a href="functions.html#Material-model-abstractions">Material model abstractions</a></li></ul></li></ul></li></ul><h2 id="Physical-units"><a class="docs-heading-anchor" href="#Physical-units">Physical units</a><a id="Physical-units-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-units" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.PhysicalUnitModule.phun-Tuple{String}" href="#FinEtools.PhysicalUnitModule.phun-Tuple{String}"><code>FinEtools.PhysicalUnitModule.phun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phun(str::String; system_of_units = :SI, base_time_units = :SEC)</code></pre><p>Evaluate an expression in physical units.</p><p>Inputs: –<code>system_of_units</code></p><pre><code class="nohighlight hljs">if system_of_units  ==  :US
   basic assumed units are American Engineering:
   LENGTH = FT, TIME = SEC, MASS = SLUG TEMPERATURE = RAN FORCE = LB
elseif system_of_units  ==  :CGS
   basic assumed units are Centimeter,Gram,Second:
   LENGTH = CM, TIME = SEC, MASS = GM TEMPERATURE = K FORCE = DYNE
elseif system_of_units  ==  :IMPERIAL
   basic assumed units are Imperial:
   LENGTH = FT, TIME = SEC, MASS = SLUG TEMPERATURE = RAN FORCE = LB
otherwise,
   basic assumed units are :SIM (equivalent to :SI, default):
   LENGTH = M , TIME = SEC, MASS = KG   TEMPERATURE = K   FORCE = N</code></pre><p>–<code>base_time_units</code> defaults to :SEC</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pu = ustring -&gt; phun(ustring; system_of_units = :SIMM)
E1s = 130.0*pu(&quot;GPa&quot;)</code></pre><p>yields 1.3e+5 (in mega Pascal) whereas</p><pre><code class="nohighlight hljs">130.0*phun(&quot;GPa&quot;; system_of_units = :SI)</code></pre><p>yields 1.3e+11 (in Pascal)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/PhysicalUnitModule.jl#L253-L291">source</a></section></article><h2 id="Bounding-box-functions"><a class="docs-heading-anchor" href="#Bounding-box-functions">Bounding box functions</a><a id="Bounding-box-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-box-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}" href="#FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}"><code>FinEtools.BoxModule.boundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundingbox(x::AbstractArray)</code></pre><p>Compute the bounding box of the points in <code>x</code>.</p><p><code>x</code> = holds points, one per row.</p><p>Returns <code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.boxesoverlap-Tuple{AbstractVector, AbstractVector}" href="#FinEtools.BoxModule.boxesoverlap-Tuple{AbstractVector, AbstractVector}"><code>FinEtools.BoxModule.boxesoverlap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boxesoverlap(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Do the given boxes overlap?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.inbox-Tuple{AbstractVector, AbstractVector}" href="#FinEtools.BoxModule.inbox-Tuple{AbstractVector, AbstractVector}"><code>FinEtools.BoxModule.inbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inbox(box::AbstractVector, x::AbstractVector)</code></pre><p>Is the given location inside the box?</p><ul><li><code>box</code> = vector entries arranged as <a href="man/or adjusted for lower space dimension">minx,maxx,miny,maxy,minz,maxz</a>.</li></ul><p>Note: point on the boundary of the box is counted as being inside.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.inflatebox!-Union{Tuple{T}, Tuple{AbstractVector, T}} where T" href="#FinEtools.BoxModule.inflatebox!-Union{Tuple{T}, Tuple{AbstractVector, T}} where T"><code>FinEtools.BoxModule.inflatebox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inflatebox!(box::AbstractVector, inflatevalue::T) where {T}</code></pre><p>Inflate the box by the value supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.initbox!-Tuple{AbstractVector, AbstractVector}" href="#FinEtools.BoxModule.initbox!-Tuple{AbstractVector, AbstractVector}"><code>FinEtools.BoxModule.initbox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initbox!(box::AbstractVector, x::AbstractVector)</code></pre><p>Initialize a bounding box with a single point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.intersectboxes-Tuple{AbstractVector, AbstractVector}" href="#FinEtools.BoxModule.intersectboxes-Tuple{AbstractVector, AbstractVector}"><code>FinEtools.BoxModule.intersectboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectboxes(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Compute the intersection of two boxes.</p><p>The function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.updatebox!-Tuple{AbstractVector, AbstractArray}" href="#FinEtools.BoxModule.updatebox!-Tuple{AbstractVector, AbstractArray}"><code>FinEtools.BoxModule.updatebox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updatebox!(box::AbstractVector, x::AbstractArray)</code></pre><p>Update a box with another location, or create a new box.</p><p>If the  <code>box</code> does not have  the correct dimensions,  it is correctly sized.</p><p><code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code>     The <code>box</code> is expanded to include the     supplied location <code>x</code>.   The variable <code>x</code>  can hold multiple points in rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/BoxModule.jl#L55-L68">source</a></section></article><h2 id="Coordinate-systems"><a class="docs-heading-anchor" href="#Coordinate-systems">Coordinate systems</a><a id="Coordinate-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.csmat-Tuple{CSys}" href="#FinEtools.CSysModule.csmat-Tuple{CSys}"><code>FinEtools.CSysModule.csmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">csmat(self::CSys)</code></pre><p>Return coordinate system rotation matrix.</p><p>No allocation is involved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/CSysModule.jl#L218-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.gen_iso_csmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}" href="#FinEtools.CSysModule.gen_iso_csmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}"><code>FinEtools.CSysModule.gen_iso_csmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_iso_csmat!(csmatout::Matrix{T}, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T, IT}</code></pre><p>Compute the coordinate system  for an isotropic material using information available  by looking at the coordinate curves of isoparametric finite elements.</p><ul><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>feid</code>= finite element identifier;</li><li><code>qpid</code> = quadrature point identifier.</li></ul><p>The basic assumption here is that the material is isotropic, and therefore the choice of the material directions does not really matter as long as they correspond to the dimensionality of the element. For instance a one-dimensional element (L2 as an example) may be embedded in a three-dimensional space.</p><p>This function assumes that it is being called for an <code>mdim</code>-dimensional manifold element, which is embedded in a <code>sdim</code>-dimensional Euclidean space. If <code>mdim == sdim</code>, the coordinate system matrix is the identity; otherwise the local coordinate directions are aligned with the linear subspace defined by the tangent vectors.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This <em>cannot</em> be reliably used to produce consistent stresses because each quadrature point gets a local coordinate system which depends on the orientation of the element, in general different from the neighboring elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/CSysModule.jl#L229-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.updatecsmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{CSys, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}" href="#FinEtools.CSysModule.updatecsmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{CSys, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}"><code>FinEtools.CSysModule.updatecsmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updatecsmat!(self::CSys,
    XYZ::Matrix{T},
    tangents::Matrix{T},
    feid::IT1,
    qpid::IT2) where {T, IT1, IT2}</code></pre><p>Update the coordinate system orientation matrix.</p><p>The  coordinate system matrix is updated based upon the location <code>XYZ</code> of the evaluation point, and possibly on the Jacobian matrix <code>tangents</code> within the element in which the coordinate system matrix is evaluated,  or perhaps on the identifier <code>feid</code> of the finite element and/or the quadrature point identifier.</p><p>After this function returns, the coordinate system matrix can be read in the buffer as <code>self.csmat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/CSysModule.jl#L192-L208">source</a></section></article><h2 id="Matrix-utilities"><a class="docs-heading-anchor" href="#Matrix-utilities">Matrix utilities</a><a id="Matrix-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_b1tdb2!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.add_b1tdb2!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.add_b1tdb2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_b1tdb2!(
    Ke::Matrix{T},
    B1::Matrix{T},
    B2::Matrix{T},
    Jac_w::T,
    D::Matrix{T},
    DB2::Matrix{T},
) where {T}</code></pre><p>Add the product  <code>(B1&#39;*(D*(Jac_w))*B2)</code>, to the matrix <code>Ke</code>.</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized: the results of this computation are <strong>added</strong>. The matrix <code>Ke</code> may be rectangular.</p><p>The matrix <code>D</code> may be rectangular.</p><p>The matrix Ke is modified.  The matrices <code>B1</code>, <code>B2</code>, and <code>D</code> are not modified inside this function. The scratch buffer <code>DB</code> is overwritten during each call of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L218-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.add_btdb_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_btdb_ut_only!(Ke::Matrix{T}, B::Matrix{T}, Jac_w::T, D::Matrix{T}, DB::Matrix{T}) where {T}</code></pre><p>Add the product  <code>(B&#39;*(D*(Jac*w[j]))*B)</code>, to the matrix Ke.</p><p><em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix Ke is assumed to be suitably initialized.</p><p>The matrix Ke is modified.  The matrices B and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_btsigma!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, T, Vector{T}}} where T" href="#FinEtools.MatrixUtilityModule.add_btsigma!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, T, Vector{T}}} where T"><code>FinEtools.MatrixUtilityModule.add_btsigma!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_btsigma!(Fe::Vector{T}, B::Matrix{T}, coefficient::T, sigma::Vector{T}) where {T}</code></pre><p>Add the product  <code>B&#39;*(sigma*coefficient)</code>, to the elementwise vector <code>Fe</code>.</p><p>The vector <code>Fe</code> is assumed to be suitably initialized.</p><p>The vector <code>Fe</code> is modified.  The vector <code>sigma</code> is not modified inside this function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L273-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.add_gkgt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_gkgt_ut_only!(
    Ke::Matrix{T},
    gradN::Matrix{T},
    Jac_w::T,
    kappa_bar::Matrix{T},
    kappa_bargradNT::Matrix{T},
) where {T}</code></pre><p>Add the product <code>gradN*kappa_bar*gradNT*(Jac*w[j])</code> to the matrix <code>Ke</code>.</p><p><em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized.</p><p>Upon return,  the matrix <code>Ke</code> is updated.  The scratch buffer <code>kappa_bargradNT</code> is overwritten during each call of this function. The matrices <code>gradN</code> and <code>kappa_bar</code> are not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L98-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Union{Tuple{T}, Tuple{MT}, Tuple{Matrix{MT}, Matrix{T}, Any}} where {MT, T}" href="#FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Union{Tuple{T}, Tuple{MT}, Tuple{Matrix{MT}, Matrix{T}, Any}} where {MT, T}"><code>FinEtools.MatrixUtilityModule.add_mggt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_mggt_ut_only!(Ke::Matrix{T}, gradN::Matrix{T}, mult) where {T}</code></pre><p>Add the product <code>gradN*mult*gradNT</code> to the matrix <code>Ke</code>.</p><p>The argument <code>mult</code> is a scalar. <em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized.</p><p>The matrix <code>Ke</code> is modified.  The matrix <code>gradN</code> is not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L68-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_n1n2t!-Union{Tuple{T}, Tuple{Matrix{T}, VecOrMat{T}, VecOrMat{T}, T}} where T&lt;:Number" href="#FinEtools.MatrixUtilityModule.add_n1n2t!-Union{Tuple{T}, Tuple{Matrix{T}, VecOrMat{T}, VecOrMat{T}, T}} where T&lt;:Number"><code>FinEtools.MatrixUtilityModule.add_n1n2t!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_n1n2t!(Ke::Matrix{T}, N1::Matrix{T}, N2::Matrix{T}, Jac_w_coeff::T) where {T&lt;:Number}</code></pre><p>Add the product  <code>N1*(N2&#39;*(coeff*(Jac*w(j)))</code>, to the matrix <code>Ke</code>.</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized. The matrices <code>N1</code> and <code>N2</code> have a single column each.</p><p>The matrix <code>Ke</code> is modified.  The matrix <code>N1</code> and <code>N2</code> are  not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L324-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T}} where T&lt;:Number" href="#FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T}} where T&lt;:Number"><code>FinEtools.MatrixUtilityModule.add_nnt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_nnt_ut_only!(Ke::Matrix{T}, N::Matrix{T}, Jac_w_coeff::T) where {T&lt;:Number}</code></pre><p>Add the product  <code>Nn*(Nn&#39;*(coeff*(Jac*w(j)))</code>, to the matrix <code>Ke</code>.</p><p><em>Only the upper triangle</em> is computed; the lower triangle is not touched.</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized. The  matrix <code>Nn</code> has a single column.</p><p>The matrix <code>Ke</code> is modified.  The matrix <code>Nn</code> is not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L299-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any, Any}" href="#FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any, Any}"><code>FinEtools.MatrixUtilityModule.adjugate3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjugate3!(B, A)</code></pre><p>Compute the adjugate matrix of 3x3 matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.complete_lt!-Union{Tuple{Matrix{T}}, Tuple{T}} where T" href="#FinEtools.MatrixUtilityModule.complete_lt!-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>FinEtools.MatrixUtilityModule.complete_lt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete_lt!(Ke::Matrix{T}) where {T}</code></pre><p>Complete the lower triangle of the elementwise matrix <code>Ke</code>.</p><p>The matrix <code>Ke</code> is modified  inside this function. The upper-triangle  entries  are copied  across the diagonal to the lower triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.detC-Union{Tuple{T}, Tuple{Val{3}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.detC-Union{Tuple{T}, Tuple{Val{3}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.detC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detC(::Val{3}, C::Matrix{T})</code></pre><p>Compute determinant of 3X3 <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.export_sparse-Tuple{Any, Any}" href="#FinEtools.MatrixUtilityModule.export_sparse-Tuple{Any, Any}"><code>FinEtools.MatrixUtilityModule.export_sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">export_sparse(filnam, M)</code></pre><p>Export sparse matrix to a text file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L601-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.import_sparse-Tuple{Any}" href="#FinEtools.MatrixUtilityModule.import_sparse-Tuple{Any}"><code>FinEtools.MatrixUtilityModule.import_sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_sparse(filnam)</code></pre><p>Import sparse matrix from a text file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L616-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.jac!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.jac!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.jac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jac!(J::Matrix{T}, ecoords::Matrix{T}, gradNparams::Matrix{T}) where {T}</code></pre><p>Compute the Jacobian matrix at the quadrature point.</p><p>Arguments: <code>J</code> = Jacobian matrix, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>gradNparams</code> = matrix of basis function gradients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.loc!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.loc!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.loc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loc!(loc::Matrix{T}, ecoords::Matrix{T}, N::Matrix{T}) where {T}</code></pre><p>Compute the location of the quadrature point.</p><p>Arguments: <code>loc</code> = matrix of coordinates, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>N</code> = matrix of basis function values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.locjac!-Union{Tuple{T}, NTuple{5, Matrix{T}}} where T" href="#FinEtools.MatrixUtilityModule.locjac!-Union{Tuple{T}, NTuple{5, Matrix{T}}} where T"><code>FinEtools.MatrixUtilityModule.locjac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">locjac!(
    loc::Matrix{T},
    J::Matrix{T},
    ecoords::Matrix{T},
    N::Matrix{T},
    gradNparams::Matrix{T},
) where {T}</code></pre><p>Compute location and Jacobian matrix at the quadrature point.</p><p>Arguments: <code>loc</code> = matrix of coordinates, overwritten  inside the function <code>J</code> = Jacobian matrix, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>N</code> = matrix of basis function values <code>gradNparams</code> = matrix of basis function gradients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L42-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCAB!(C, A, B)</code></pre><p>Compute the matrix <code>C = A * B</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p><p>Note: See the thread https://discourse.julialang.org/t/ann-loopvectorization/32843/36</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L508-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3}, Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3}, Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCAB!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = A * B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L394-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Vector{T}, Any, Vector{T}}} where T" href="#FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Vector{T}, Any, Vector{T}}} where T"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCAB!(C::Vector{T}, A, B::Vector{T})  where {T}</code></pre><p>Compute the product <code>C = A * B</code>, where <code>C</code> and <code>B</code> are &quot;vectors&quot;.</p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L580-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCABt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCABt!(C, A, B)</code></pre><p>Compute the matrix <code>C = A * B&#39;</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L543-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3}, Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3}, Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCABt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCABt!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = A * Transpose(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L434-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCAtB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCAtB!(C, A, B)</code></pre><p>Compute the matrix <code>C = A&#39; * B</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L454-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3}, Any, Any, Any}" href="#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3}, Any, Any, Any}"><code>FinEtools.MatrixUtilityModule.mulCAtB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mulCAtB!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = Transpose(A) * B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}" href="#FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}"><code>FinEtools.MatrixUtilityModule.symmetrize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize!(a)</code></pre><p>Make the matrix on input symmetric.</p><p>The operation is in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatrixUtilityModule.jl#L377-L383">source</a></section></article><h2 id="Data-cache"><a class="docs-heading-anchor" href="#Data-cache">Data cache</a><a id="Data-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Data-cache" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{DataCache}" href="#Base.size-Tuple{DataCache}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(self::DataCache)</code></pre><p>Size of the data cache value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/DataCacheModule.jl#L102-L106">source</a></section></article><h2 id="Surface-normal-utilities"><a class="docs-heading-anchor" href="#Surface-normal-utilities">Surface-normal utilities</a><a id="Surface-normal-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-normal-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.updatenormal!-Union{Tuple{IT}, Tuple{T}, Tuple{SurfaceNormal, Matrix{T}, Matrix{T}, IT, IT}} where {T, IT}" href="#FinEtools.SurfaceNormalModule.updatenormal!-Union{Tuple{IT}, Tuple{T}, Tuple{SurfaceNormal, Matrix{T}, Matrix{T}, IT, IT}} where {T, IT}"><code>FinEtools.SurfaceNormalModule.updatenormal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updatenormal!(self::SurfaceNormal, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T, IT}</code></pre><p>Update the surface normal vector.</p><p>Returns the normal vector (stored in the cache).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/SurfaceNormalModule.jl#L133-L139">source</a></section></article><h2 id="Force-intensity"><a class="docs-heading-anchor" href="#Force-intensity">Force intensity</a><a id="Force-intensity-1"></a><a class="docs-heading-anchor-permalink" href="#Force-intensity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.updateforce!-Union{Tuple{IT}, Tuple{T}, Tuple{ForceIntensity, Matrix{T}, Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.ForceIntensityModule.updateforce!-Union{Tuple{IT}, Tuple{T}, Tuple{ForceIntensity, Matrix{T}, Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.ForceIntensityModule.updateforce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateforce!(self::ForceIntensity, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Update the force intensity vector.</p><p>Returns a vector (stored in the cache <code>self.cache</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/ForceIntensityModule.jl#L93-L99">source</a></section></article><h2 id="Rotation-utilities"><a class="docs-heading-anchor" href="#Rotation-utilities">Rotation utilities</a><a id="Rotation-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.cross2-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}" href="#FinEtools.RotationUtilModule.cross2-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}"><code>FinEtools.RotationUtilModule.cross2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cross2(theta::AbstractVector{T1}, v::AbstractVector{T2}) where {T1, T2}</code></pre><p>Compute the cross product of two vectors in two-space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, AbstractVector{T3}}} where {T1, T2, T3}" href="#FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, AbstractVector{T3}}} where {T1, T2, T3}"><code>FinEtools.RotationUtilModule.cross3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cross3!(
    result::AbstractVector{T1},
    theta::AbstractVector{T2},
    v::AbstractVector{T3},
) where {T1, T2, T3}</code></pre><p>Compute the cross product of two vectors in three-space in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, Union{AbstractVector{T2}, Tuple{T2, T2, T2}}, Union{AbstractVector{T3}, Tuple{T3, T3, T3}}}} where {T1, T2, T3}" href="#FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, Union{AbstractVector{T2}, Tuple{T2, T2, T2}}, Union{AbstractVector{T3}, Tuple{T3, T3, T3}}}} where {T1, T2, T3}"><code>FinEtools.RotationUtilModule.cross3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cross3!(
    result::AbstractVector{T1},
    theta::Union{AbstractVector{T2}, Tuple{T2, T2, T2}},
    v::Union{AbstractVector{T3}, Tuple{T3, T3, T3}}
) where {T1, T2, T3}</code></pre><p>Compute the cross product of two vectors in three-space in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}" href="#FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}"><code>FinEtools.RotationUtilModule.rotmat3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotmat3!(Rmout::Matrix{T}, a::VT) where {T, VT}</code></pre><p>Compute a 3D rotation matrix in-place.</p><p><code>a</code> = array, vector, or tuple with three floating-point numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.rotmat3-Tuple{VT} where VT" href="#FinEtools.RotationUtilModule.rotmat3-Tuple{VT} where VT"><code>FinEtools.RotationUtilModule.rotmat3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotmat3(a::VT) where {VT}</code></pre><p>Prepare a rotation matrix from a rotation vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.skewmat!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}" href="#FinEtools.RotationUtilModule.skewmat!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}"><code>FinEtools.RotationUtilModule.skewmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">skewmat!(S::Matrix{T}, theta::VT) where {T, VT}</code></pre><p>Compute skew-symmetric matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/RotationUtilModule.jl#L69-L73">source</a></section></article><h2 id="Finite-element-sets"><a class="docs-heading-anchor" href="#Finite-element-sets">Finite element sets</a><a id="Finite-element-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.cat-Union{Tuple{ET}, Tuple{ET, ET}} where ET&lt;:AbstractFESet" href="#Base.cat-Union{Tuple{ET}, Tuple{ET, ET}} where ET&lt;:AbstractFESet"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cat(self::T,  other::T) where {T&lt;:AbstractFESet}</code></pre><p>Concatenate the connectivities of two FE sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{T} where T&lt;:AbstractFESet" href="#Base.count-Tuple{T} where T&lt;:AbstractFESet"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count(self::T)::FInt where {T&lt;:AbstractFESet}</code></pre><p>Get the number of individual connectivities in the FE set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachindex-Tuple{FES} where FES&lt;:AbstractFESet" href="#Base.eachindex-Tuple{FES} where FES&lt;:AbstractFESet"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachindex(fes::AbstractFESet)</code></pre><p>Create an iterator for elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet0Manifold, FT}" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet0Manifold, FT}"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobian(self::ET, J::Matrix{FT}) where {ET&lt;:AbstractFESet0Manifold, FT}</code></pre><p>Evaluate the point Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L341-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet1Manifold, FT}" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet1Manifold, FT}"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobian(self::ET, J::Matrix{FT}) where {ET&lt;:AbstractFESet1Manifold, FT}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L352-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet2Manifold, FT}" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet2Manifold, FT}"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobian(self::ET, J::Matrix{FT}) where {ET&lt;:AbstractFESet2Manifold, FT}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L389-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet3Manifold, FT}" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET&lt;:AbstractFESet3Manifold, FT}"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobian(self::ET, J::Matrix{FT}) where {ET&lt;:AbstractFESet3Manifold, FT}</code></pre><p>Evaluate the volume Jacobian.</p><p><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L440-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.accepttodelegate-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.accepttodelegate-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.accepttodelegate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accepttodelegate(self::T, delegateof) where {T&lt;:AbstractFESet}</code></pre><p>Accept to delegate for an object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET&lt;:AbstractFESet, T}" href="#FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET&lt;:AbstractFESet, T}"><code>FinEtools.FESetModule.bfun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfun(self::ET, param_coords::Vector{T}) where {ET&lt;:AbstractFESet, T}</code></pre><p>Compute the values of the basis functions.</p><p>Compute the values of the basis functions at a given parametric coordinate. One basis function per row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET&lt;:AbstractFESet, T}" href="#FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET&lt;:AbstractFESet, T}"><code>FinEtools.FESetModule.bfundpar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bfundpar(self::ET, param_coords::Vector{T}) where {ET&lt;:AbstractFESet, T}</code></pre><p>Compute the values of the basis function gradients.</p><p>Compute the values of the basis function gradients with respect to the parametric coordinates at a given parametric coordinate. One basis function gradients per row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.boundaryconn-Tuple{T} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.boundaryconn-Tuple{T} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.boundaryconn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryconn(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Get boundary connectivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.boundaryfe-Tuple{T} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.boundaryfe-Tuple{T} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.boundaryfe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryfe(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Return the constructor of the type of the boundary finite element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.centroidparametric-Tuple{T} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.centroidparametric-Tuple{T} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.centroidparametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroidparametric(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Return the parametric coordinates  of the centroid of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.connasarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connasarray(self::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Return the connectivity as an array.</p><p>Return the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.delegateof-Tuple{T} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.delegateof-Tuple{T} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.delegateof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delegateof(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Return the object of which the elements set is a delegate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM}, AbstractArray}} where NODESPERELEM" href="#FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM}, AbstractArray}} where NODESPERELEM"><code>FinEtools.FESetModule.fromarray!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fromarray!(self::AbstractFESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}</code></pre><p>Set  the connectivity from an integer array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet1Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT" href="#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet1Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradN!(
    self::AbstractFESet1Manifold,
    gradN::Matrix{FT},
    gradNparams::Matrix{FT},
    redJ::Matrix{FT},
) where {FT}</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L365-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet2Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT" href="#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet2Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradN!(
    self::AbstractFESet2Manifold,
    gradN::Matrix{FT},
    gradNparams::Matrix{FT},
    redJ::Matrix{FT},
) where {FT}</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L407-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet3Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT" href="#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet3Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradN!(
    self::AbstractFESet3Manifold,
    gradN::Matrix{FT},
    gradNparams::Matrix{FT},
    redJ::Matrix{FT},
) where {FT}</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L457-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.inparametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Vector{FT}}} where {ET&lt;:AbstractFESet, FT}" href="#FinEtools.FESetModule.inparametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Vector{FT}}} where {ET&lt;:AbstractFESet, FT}"><code>FinEtools.FESetModule.inparametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inparametric(self::AbstractFESet, param_coords)</code></pre><p>Are given parametric coordinates inside the element parametric domain?</p><p>Return a Boolean: is the point inside, true or false?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L272-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.manifdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifdim(me)</code></pre><p>Get the manifold dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.map2parametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}, Vector{FT}}} where {ET&lt;:AbstractFESet, FT}" href="#FinEtools.FESetModule.map2parametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}, Vector{FT}}} where {ET&lt;:AbstractFESet, FT}"><code>FinEtools.FESetModule.map2parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map2parametric(
    self::ET,
    x::Matrix{FT},
    pt::Vector{FT};
    tolerance = 0.001,
    maxiter = 5,
) where {ET&lt;:AbstractFESet, FT}</code></pre><p>Map a spatial location to parametric coordinates.</p><ul><li><code>x</code>=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,</li><li><code>c</code>= spatial location</li><li><code>tolerance</code> = tolerance in parametric coordinates; default is 0.001.</li></ul><p><strong>Return</strong></p><ul><li><code>success</code> = Boolean flag, true if successful, false otherwise.</li><li><code>pc</code> = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L285-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.nodesperelem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodesperelem(fes::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Provide the number of nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.nodesperelem-Union{Tuple{Type{T}}, Tuple{T}, Tuple{NODESPERELEM}} where {NODESPERELEM, T&lt;:AbstractFESet{NODESPERELEM}}" href="#FinEtools.FESetModule.nodesperelem-Union{Tuple{Type{T}}, Tuple{T}, Tuple{NODESPERELEM}} where {NODESPERELEM, T&lt;:AbstractFESet{NODESPERELEM}}"><code>FinEtools.FESetModule.nodesperelem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodesperelem(::Type{T}) where {NODESPERELEM, T&lt;:AbstractFESet{NODESPERELEM}}</code></pre><p>Provide the number of nodes per element for a given type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, IT}} where {ET&lt;:AbstractFESet, IT}" href="#FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, IT}} where {ET&lt;:AbstractFESet, IT}"><code>FinEtools.FESetModule.setlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setlabel!(self::ET, val::IT) where {ET&lt;:AbstractFESet, IT}</code></pre><p>Set the label of the entire finite elements set.</p><p>All elements are labeled with this number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET&lt;:AbstractFESet, IT}" href="#FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET&lt;:AbstractFESet, IT}"><code>FinEtools.FESetModule.setlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setlabel!(self::ET, val::Vector{IT}) where {ET&lt;:AbstractFESet, IT}</code></pre><p>Set the labels of individual elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.subset-Union{Tuple{ET}, Tuple{ET, Any}} where ET&lt;:AbstractFESet" href="#FinEtools.FESetModule.subset-Union{Tuple{ET}, Tuple{ET, Any}} where ET&lt;:AbstractFESet"><code>FinEtools.FESetModule.subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset(self::T, L) where {T&lt;:AbstractFESet}</code></pre><p>Extract a subset of the finite elements from the given finite element set.</p><ul><li><code>L</code>: an integer vector, tuple, or a range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.updateconn!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET&lt;:AbstractFESet, IT}" href="#FinEtools.FESetModule.updateconn!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET&lt;:AbstractFESet, IT}"><code>FinEtools.FESetModule.updateconn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateconn!(self::ET, newids::Vector{IT}) where {ET&lt;:AbstractFESet, IT}</code></pre><p>Update the connectivity after the IDs of nodes changed.</p><p><code>newids</code>= new node IDs. Note that indexes in the conn array &quot;point&quot; <em>into</em> the  <code>newids</code> array. After the connectivity was updated this will no longer be true!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FESetModule.jl#L253-L261">source</a></section></article><h2 id="Finite-element-nodes"><a class="docs-heading-anchor" href="#Finite-element-nodes">Finite element nodes</a><a id="Finite-element-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{FENodeSet}" href="#Base.count-Tuple{FENodeSet}"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count(self::FENodeSet)</code></pre><p>Get the number of finite element nodes in the node set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FENodeSetModule.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachindex-Tuple{FENodeSet}" href="#Base.eachindex-Tuple{FENodeSet}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachindex(fens::FENodeSet)</code></pre><p>Create the finite element node iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FENodeSetModule.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}" href="#FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}"><code>FinEtools.FENodeSetModule.spacedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spacedim(self::FENodeSet)</code></pre><p>Number of dimensions of the space in which the node lives, 1, 2, or 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FENodeSetModule.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}" href="#FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}"><code>FinEtools.FENodeSetModule.xyz3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xyz3(self::FENodeSet)</code></pre><p>Get the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FENodeSetModule.jl#L41-L47">source</a></section></article><h2 id="Finite-element-node-to-element-map"><a class="docs-heading-anchor" href="#Finite-element-node-to-element-map">Finite element node-to-element map</a><a id="Finite-element-node-to-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-node-to-element-map" title="Permalink"></a></h2><h2 id="Selecting-nodes-and-elements"><a class="docs-heading-anchor" href="#Selecting-nodes-and-elements">Selecting nodes and elements</a><a id="Selecting-nodes-and-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-nodes-and-elements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectedelems-Union{Tuple{IT}, Tuple{AbstractFESet, Vector{IT}, IT}} where IT&lt;:Integer" href="#FinEtools.MeshSelectionModule.connectedelems-Union{Tuple{IT}, Tuple{AbstractFESet, Vector{IT}, IT}} where IT&lt;:Integer"><code>FinEtools.MeshSelectionModule.connectedelems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectedelems(fes::AbstractFESet, node_list::FIntVec)</code></pre><p>Extract the list of numbers for the fes  that are connected to given nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}" href="#FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}"><code>FinEtools.MeshSelectionModule.connectednodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectednodes(fes::AbstractFESet)</code></pre><p>Extract the node numbers of the nodes connected by given finite elements.</p><p>Extract the list of unique node numbers for the nodes that are connected by the finite element set <code>fes</code>. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet, AbstractFESet}" href="#FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet, AbstractFESet}"><code>FinEtools.MeshSelectionModule.findunconnnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findunconnnodes(fens::FENodeSet, fes::AbstractFESet)</code></pre><p>Find nodes that are not connected to any finite element.</p><p>connected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).</p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L670-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectelem-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET&lt;:AbstractFESet" href="#FinEtools.MeshSelectionModule.selectelem-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET&lt;:AbstractFESet"><code>FinEtools.MeshSelectionModule.selectelem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectelem(fens::FENodeSet, fes::T; kwargs...) where {T&lt;:AbstractFESet}</code></pre><p>Select finite elements.</p><p><strong>Arguments</strong></p><ul><li><code>fens</code> = finite element node set</li><li><code>fes</code> = finite element set</li><li><code>kwargs</code> = keyword arguments to specify the selection criteria</li></ul><p><strong>Selection criteria</strong></p><p><strong>facing</strong></p><p>Select all &quot;boundary&quot; elements that &quot;face&quot; a certain direction.</p><pre><code class="nohighlight hljs">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);</code></pre><p>or</p><pre><code class="nohighlight hljs">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);</code></pre><p>where</p><pre><code class="nohighlight hljs">function dout(xyz)
    return xyz/norm(xyz)
end</code></pre><p>and <code>xyz</code> is the location of the centroid  of  a boundary element. Here the finite element is considered &quot;facing&quot; in the given direction if the dot product of its normal and the direction vector is greater than <code>dotmin</code>. The default value for <code>dotmin</code> is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).</p><p>This selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).</p><p><strong>label</strong></p><p>Select elements based on their label.</p><pre><code class="nohighlight hljs">rl1 = selectelem(fens, fes, label=1)</code></pre><p><strong>box, distance</strong></p><p>Select elements based on some criteria that their nodes satisfy.  See the function <code>selectnode()</code>.</p><p>Example: Select all  elements whose nodes are closer than <code>R+inflate</code> from the point <code>from</code>.</p><pre><code class="nohighlight hljs">linner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],
  inflate = tolerance)</code></pre><p>Example:</p><pre><code class="nohighlight hljs">exteriorbfl = selectelem(fens, bdryfes,
   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);</code></pre><p><strong>withnodes</strong></p><p>Select elements whose nodes are in a given list of node numbers.</p><p>Example:</p><pre><code class="language-julia hljs">l = selectelem(fens, fes, withnodes = [13, 14])</code></pre><p><strong>flood</strong></p><p>Select all FEs connected together, starting from a given node. Connections through a vertex (node) are sufficient.</p><p>Example: Select all FEs connected together (Starting from node 13):</p><pre><code class="language-julia hljs">l = selectelem(fens, fes, flood = true, startnode = 13)</code></pre><p><strong>Optional keyword arguments</strong></p><p>Should we consider the element only if all its nodes are in?</p><ul><li><code>allin</code> = Boolean: if true, then all nodes of an element must satisfy</li></ul><p>the criterion; otherwise  one is enough.</p><p><strong>Output</strong></p><p><code>felist</code> = list of finite elements from the set that satisfy the criteria</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L105-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}" href="#FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}"><code>FinEtools.MeshSelectionModule.selectnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectnode(fens::FENodeSet; kwargs...)</code></pre><p>Select nodes using some criterion.</p><p><strong>Arguments</strong></p><ul><li><code>v</code> = array of locations, one location per row</li><li><code>kwargs</code> = pairs of keyword argument/value</li></ul><p><strong>Selection criteria</strong></p><p><strong>box</strong></p><pre><code class="nohighlight hljs">nLx = vselect(fens.xyz, box = [0.0 Lx  0.0 0.0 0.0 0.0], inflate = Lx/1.0e5)</code></pre><p>The keyword &#39;inflate&#39; may be used to increase or decrease the extent of the box (or the distance) to make sure some nodes which would be on the boundary are either excluded or included.</p><p><strong>distance</strong></p><pre><code class="nohighlight hljs">list = selectnode(fens.xyz, distance=1.0+0.1/2^nref, from=[0. 0.],
        inflate=tolerance);</code></pre><p><strong>plane</strong></p><pre><code class="nohighlight hljs">candidates = selectnode(fens, plane = [0.0 0.0 1.0 0.0], thickness = h/1000)</code></pre><p>The keyword <code>plane</code> defines the plane by its normal (the first two or three numbers) and its distance from the origin (the last number). Nodes are selected they lie on the plane,  or near the plane within the distance <code>thickness</code> from the plane. The normal is assumed to be of unit length, if it isn&#39;t apply as such, it will be normalized internally.</p><p><strong>nearestto</strong></p><p>Find the node nearest to the location given.</p><pre><code class="nohighlight hljs">nh = selectnode(fens, nearestto = [R+Ro/2, 0.0, 0.0] )</code></pre><p><strong>farthestfrom</strong></p><p>Find the node farthest from the location given.</p><pre><code class="nohighlight hljs">nh = selectnode(fens, farthestfroms = [R+Ro/2, 0.0, 0.0] )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L50-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.vselect-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.MeshSelectionModule.vselect-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.MeshSelectionModule.vselect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vselect(v::Matrix{T}; kwargs...) where {T&lt;:Number}</code></pre><p>Select locations (vertices) from the array based on some criterion.</p><p>See the function <code>selectnode()</code> for examples of the criteria that can be used to search vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshSelectionModule.jl#L557-L564">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractField" href="#Base.copyto!-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractField"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(DEST::F,  SRC::F) where {F&lt;:AbstractField}</code></pre><p>Copy data from one field to another.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.anyfixedvaluenz-Union{Tuple{CC}, Tuple{F}, Tuple{F, CC}} where {F&lt;:AbstractField, CC}" href="#FinEtools.FieldModule.anyfixedvaluenz-Union{Tuple{CC}, Tuple{F}, Tuple{F, CC}} where {F&lt;:AbstractField, CC}"><code>FinEtools.FieldModule.anyfixedvaluenz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anyfixedvaluenz(self::F, conn::CC) where {F&lt;:AbstractField, CC}</code></pre><p>Is any degree of freedom fixed (prescribed) to be non-zero?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.applyebc!-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.applyebc!-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.applyebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">applyebc!(self::F) where {F&lt;:AbstractField}</code></pre><p>Apply EBCs (essential boundary conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L705-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.fixeddofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.fixeddofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.fixeddofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixeddofs(self::F) where {F&lt;:AbstractField}</code></pre><p>Return range corresponding to the fixed degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.freedofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.freedofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.freedofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freedofs(self::F) where {F&lt;:AbstractField}</code></pre><p>Return range corresponding to the free degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{F}, Tuple{F, A, CC}} where {F&lt;:AbstractField, A, CC}" href="#FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{F}, Tuple{F, A, CC}} where {F&lt;:AbstractField, A, CC}"><code>FinEtools.FieldModule.gatherdofnums!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gatherdofnums!(self::F, dest::A, conn::CC) where {F&lt;:AbstractField, A, CC}</code></pre><p>Gather dofnums from the field.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom for that node,  then the next node  and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L363-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F&lt;:AbstractField, T, CC}" href="#FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F&lt;:AbstractField, T, CC}"><code>FinEtools.FieldModule.gatherfixedvalues_asmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gatherfixedvalues_asmat!(
    self::F,
    dest::AbstractArray{T,2},
    conn::CC,
) where {F&lt;:AbstractField, T, CC}</code></pre><p>Gather FIXED values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L311-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F&lt;:AbstractField, T, CC}" href="#FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F&lt;:AbstractField, T, CC}"><code>FinEtools.FieldModule.gatherfixedvalues_asvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gatherfixedvalues_asvec!(
    self::F,
    dest::AbstractArray{T,1},
    conn::CC,
) where {F&lt;:AbstractField, T, CC}</code></pre><p>Gather FIXED values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L276-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, Vector{T}}, Tuple{F, Vector{T}, Any}} where {F&lt;:AbstractField, T}" href="#FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, Vector{T}}, Tuple{F, Vector{T}, Any}} where {F&lt;:AbstractField, T}"><code>FinEtools.FieldModule.gathersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gathersysvec!(self::F,
    vec::Vector{T}, which = :f) where {F&lt;:AbstractField, T}</code></pre><p>Gather values from the field for the system vector.</p><p><strong>Arguments</strong></p><ul><li><code>self</code>: field;</li><li><code>which</code>:<ul><li><code>:f</code> - Collect a vector that includes the free degrees of freedom (default);</li><li><code>:d</code> - Collect a vector that includes the fixed (data) degrees of freedom;</li><li><code>:a</code> - Collect a vector that includes all the degrees of freedom, free and fixed.</li></ul></li></ul><p>The system vector consists of two parts: the first part, from <code>1</code> to <code>nfreedofs (self)</code> are the free degrees of freedom, the second part from <code>nfreedofs (self)+1</code> to <code>nalldofs(self)</code> are the fixed degrees of freedom.</p><p>This function gathers either the entire vector, or one of the parts. The length of the supplied buffer <code>vec</code> must be correct, either <code>nfreedofs (self)</code>, <code>nalldofs(self)</code>, or <code>nfixeddofs(self)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L156-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F, Any}} where F&lt;:AbstractField" href="#FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F, Any}} where F&lt;:AbstractField"><code>FinEtools.FieldModule.gathersysvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gathersysvec(self::F, which = :f) where {F&lt;:AbstractField}</code></pre><p>Gather values from the field for the system vector.</p><p><strong>Arguments</strong></p><ul><li><code>self</code>: field;</li><li><code>which</code>:<ul><li><code>:f</code> - Collect a vector that includes the free degrees of freedom (default);</li><li><code>:d</code> - Collect a vector that includes the fixed (data) degrees of freedom;</li><li><code>:a</code> - Collect a vector that includes all the degrees of freedom, free and fixed.</li></ul></li></ul><p>The system vector consists of two parts: the first part, from <code>1</code> to <code>nfreedofs (self)</code> are the free degrees of freedom, the second part from <code>nfreedofs (self)+1</code> to <code>nalldofs(self)</code> are the fixed degrees of freedom.</p><p>This function returns either the entire vector, or one of the parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L122-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F&lt;:AbstractField, T, CC}" href="#FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F&lt;:AbstractField, T, CC}"><code>FinEtools.FieldModule.gathervalues_asmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gathervalues_asmat!(
    self::F,
    dest::AbstractArray{T,2},
    conn::CC,
) where {F&lt;:AbstractField, T, CC}</code></pre><p>Gather values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F&lt;:AbstractField, T, CC}" href="#FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F&lt;:AbstractField, T, CC}"><code>FinEtools.FieldModule.gathervalues_asvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gathervalues_asvec!(
    self::F,
    dest::AbstractArray{T,1},
    conn::CC,
) where {F&lt;:AbstractField, T, CC}</code></pre><p>Gather values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L220-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number}" href="#FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number}"><code>FinEtools.FieldModule.incrscattersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incrscattersysvec!(self::F, vec::AbstractVector{T}) where {F&lt;:AbstractField, T&lt;:Number}</code></pre><p>Increment values of the field by scattering a system vector.</p><p>The vector may be either for just the free degrees of freedom, or for all the degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L738-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.nalldofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.nalldofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.nalldofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nalldofs(self::F)</code></pre><p>Return to number of ALL degrees of freedom (total number of degrees of freedom, which is equal to the number of degrees of freedom per entity times the number of entities).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.ndofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.ndofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.ndofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndofs(self::F)</code></pre><p>Dimension of the degree of freedom parameters (i. e. how many degrees of freedom per entity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.nents-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.nents-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.nents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nents(self::F)</code></pre><p>Number of nodes associated with the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.nfixeddofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.nfixeddofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.nfixeddofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nfixeddofs(self::F)</code></pre><p>Return to number of FIXED degrees of freedom (known, data).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.nfreedofs-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.nfreedofs-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.nfreedofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nfreedofs(self::F)</code></pre><p>Return to number of FREE degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.numberdofs!-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.numberdofs!-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.numberdofs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numberdofs!(self::F) where {F&lt;:AbstractField}</code></pre><p>Number the degrees of freedom.</p><p>The free components in the field are numbered consecutively, then all the fixed components are numbered, again consecutively.</p><p>No effort is made to optimize the numbering in any way. If you&#39;d like to optimize the numbering of the degrees of freedom, use a form that sets the permutation of the degrees of freedom, or the permutation of the nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L382-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.numberdofs!-Union{Tuple{F}, Tuple{F, Any}} where F&lt;:AbstractField" href="#FinEtools.FieldModule.numberdofs!-Union{Tuple{F}, Tuple{F, Any}} where F&lt;:AbstractField"><code>FinEtools.FieldModule.numberdofs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numberdofs!(self::F, entperm) where {F&lt;:AbstractField}</code></pre><p>Number the degrees of freedom.</p><p>The free components in the field are numbered consecutively, then all the fixed components are numbered, again consecutively.</p><p>The sequence of the entities is given by the <code>entperm</code> permutation (array or range).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L398-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.prescribeddofs-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1&lt;:AbstractField, F2&lt;:AbstractField}" href="#FinEtools.FieldModule.prescribeddofs-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1&lt;:AbstractField, F2&lt;:AbstractField}"><code>FinEtools.FieldModule.prescribeddofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prescribeddofs(uebc::F1, u::F2) where {F1&lt;:AbstractField,  F2&lt;:AbstractField}</code></pre><p>Find which degrees of freedom are prescribed. <code>uebc</code> = field which defines the constraints (is the dof fixed and to which value), <code>u</code> = field which does not have the constraints applied, and serves as the source of equation numbers; <code>uebc</code> and <code>u</code> may be one and the same field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L761-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number}" href="#FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number}"><code>FinEtools.FieldModule.scattersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scattersysvec!(self::F, vec::AbstractVector{T}) where {F&lt;:AbstractField, T&lt;:Number}</code></pre><p>Scatter values to the field from a system vector.</p><p>The vector may be either for just the free degrees of freedom, or for all the degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L715-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.setebc!-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(self::F)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>All essential boundary conditions are CLEARED.</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L684-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, AbstractVector{IT}}} where {F&lt;:AbstractField, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, AbstractVector{IT}}} where {F&lt;:AbstractField, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(self::F, fenids::AbstractVector{IT})  where {IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given nodes.</p><p><code>fenids</code>         - array of N node identifiers</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L642-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, IT}} where {F&lt;:AbstractField, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, IT}} where {F&lt;:AbstractField, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(self::F, fenid::IT) where {IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given node.</p><p><code>fenid</code>         - One integer as a node identifier</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L665-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenids::AbstractVector{IT},
    is_fixed::Bool,
    comp::AbstractVector{IT},
    val::T = 0.0,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer vector, which degree of freedom (component), <code>val</code> = scalar of type <code>T</code>, default is <code>0.0</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L611-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenids::AbstractVector{IT},
    is_fixed::Bool,
    comp::IT,
    val::AbstractVector{T},
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L483-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT}, Tuple{F, AbstractVector{IT}, Bool, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT}, Tuple{F, AbstractVector{IT}, Bool, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenids::AbstractVector{IT},
    is_fixed::Bool,
    comp::IT,
    val::T = 0.0,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L521-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT, AbstractVector{T}}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenids::AbstractVector{IT},
    comp::IT,
    val::AbstractVector{T},
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type <code>T</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L559-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT}, Tuple{F, AbstractVector{IT}, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT}, Tuple{F, AbstractVector{IT}, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenids::AbstractVector{IT},
    comp::IT,
    val::T = 0.0,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type <code>T</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L585-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, IT, Bool, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, IT, Bool, IT, T}} where {F&lt;:AbstractField, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setebc!(
    self::F,
    fenid::IT,
    is_fixed::Bool,
    comp::IT,
    val::T,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>_nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L448-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.wipe!-Tuple{F} where F&lt;:AbstractField" href="#FinEtools.FieldModule.wipe!-Tuple{F} where F&lt;:AbstractField"><code>FinEtools.FieldModule.wipe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wipe!(self::F) where {F&lt;:AbstractField}</code></pre><p>Wipe all the data from the field.</p><p>This includes values, prescribed values, degree of freedom numbers, and &quot;is fixed&quot; flags. The number of free degrees of freedom is set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FieldModule.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}" href="#FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}"><code>FinEtools.NodalFieldModule.nnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nnodes(self::NodalField)</code></pre><p>Provide the number of nodes  in the nodal field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/NodalFieldModule.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}" href="#FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}"><code>FinEtools.ElementalFieldModule.nelems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nelems(self::ElementalField)</code></pre><p>Provide the number of elements  in the elemental field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/ElementalFieldModule.jl#L59-L63">source</a></section></article><h2 id="Integration-rule"><a class="docs-heading-anchor" href="#Integration-rule">Integration rule</a><a id="Integration-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-rule" title="Permalink"></a></h2><h2 id="Integration-domain"><a class="docs-heading-anchor" href="#Integration-domain">Integration domain</a><a id="Integration-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-domain" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobiancurve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobiancurve(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L154-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobiancurve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobiancurve(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L289-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number, IT}" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number, IT}"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianmdim(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
    m::IT,
) where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number, IT}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 0-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=0: +1</li><li>m=1: <code>Jacobiancurve</code></li><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L253-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number, IT}" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number, IT}"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianmdim(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
    m::IT,
) where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number, IT}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 1-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=1: <code>Jacobiancurve</code></li><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L382-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number, IT}" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number, IT}"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianmdim(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
    m::IT,
) where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number, IT}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 2-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L473-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number, IT}" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number, IT}"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianmdim(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
    m::IT,
) where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number, IT}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 3-dimensional cell,  the manifold Jacobian is</p><ul><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L527-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobianpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianpoint(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the point Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobiansurface(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the zero-dimensional cell, the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> times the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L183-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobiansurface(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code>.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L313-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobiansurface(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the surface Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L415-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianvolume(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet0Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the zero-dimensional cell, the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length squared).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L218-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianvolume(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet1Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L347-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianvolume(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet2Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point <code>loc</code> (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L439-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobianvolume(
    self::IntegDomain{MT},
    J::Matrix{T},
    loc::Matrix{T},
    conn::CC,
    N::Matrix{T},
) where {MT&lt;:AbstractFESet3Manifold, CC, T&lt;:Number}</code></pre><p>Evaluate the volume Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L503-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.integrationdata-Tuple{ID} where ID&lt;:IntegDomain" href="#FinEtools.IntegDomainModule.integrationdata-Tuple{ID} where ID&lt;:IntegDomain"><code>FinEtools.IntegDomainModule.integrationdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrationdata(self::IntegDomain)</code></pre><p>Calculate the data needed for  numerical quadrature for the integration rule stored by the integration domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L552-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.integrationdata-Union{Tuple{IR}, Tuple{ID}, Tuple{ID, IR}} where {ID&lt;:IntegDomain, IR&lt;:AbstractIntegRule}" href="#FinEtools.IntegDomainModule.integrationdata-Union{Tuple{IR}, Tuple{ID}, Tuple{ID, IR}} where {ID&lt;:IntegDomain, IR&lt;:AbstractIntegRule}"><code>FinEtools.IntegDomainModule.integrationdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrationdata(
    self::IntegDomain,
    integration_rule::IR,
) where {IR&lt;:AbstractIntegRule}</code></pre><p>Calculate the data needed for a given numerical quadrature rule.</p><p>For given integration domain, compute the quantities needed for numerical integration. The integration rule does not necessarily have to be the one associated originally with the integration domain.</p><p><strong>Return</strong></p><p><code>npts</code>, <code>Ns</code>, <code>gradNparams</code>, <code>w</code>, <code>pc</code> = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L562-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{T}, Tuple{CC}, Tuple{Matrix{T}, CC, Matrix{T}}} where {CC, T&lt;:Number}" href="#FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{T}, Tuple{CC}, Tuple{Matrix{T}, CC, Matrix{T}}} where {CC, T&lt;:Number}"><code>FinEtools.IntegDomainModule.otherdimensionunity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">otherdimensionunity(loc::Matrix{T}, conn::CC, N::Matrix{T}) where {CC, T&lt;:Number}</code></pre><p>Evaluate the other dimension: default is 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/IntegDomainModule.jl#L121-L125">source</a></section></article><h2 id="Assembly-of-matrices-and-vectors"><a class="docs-heading-anchor" href="#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a><a id="Assembly-of-matrices-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-of-matrices-and-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparse, MBT, CIT, CIT}} where {MBT, CIT}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparse, MBT, CIT, CIT}} where {MBT, CIT}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    self::SysmatAssemblerSparse,
    mat::MT,
    dofnums_row::IT,
    dofnums_col::IT,
) where {MT, IT}</code></pre><p>Assemble a rectangular matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L195-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseDiag, MBT, CIT, CIT}} where {MBT, CIT}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseDiag, MBT, CIT, CIT}} where {MBT, CIT}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    self::SysmatAssemblerSparseDiag,
    mat::MT,
    dofnums_row::IV,
    dofnums_col::IV,
) where {MT, IV}</code></pre><p>Assemble a square symmetric diagonal matrix.</p><ul><li><code>dofnums</code> = the row degree of freedom numbers, the column degree of freedom</li></ul><p>number input is ignored (the row and column numbers are assumed to be the same).</p><ul><li><code>mat</code> = <strong>diagonal</strong> square matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L622-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseHRZLumpingSymm, MBT, CIT, CIT}} where {MBT, CIT}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseHRZLumpingSymm, MBT, CIT, CIT}} where {MBT, CIT}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    self::SysmatAssemblerSparseHRZLumpingSymm,
    mat::MT,
    dofnums::IV,
    ignore::IV,
) where {MT, IV}</code></pre><p>Assemble a HRZ-lumped square symmetric matrix.</p><p>Assembly of a HRZ-lumped square symmetric matrix. The method assembles the scaled diagonal of the square symmetric matrix using the two vectors of equation numbers for the rows and columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L945-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseSymm, MBT, CIT, CIT}} where {MBT, CIT}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseSymm, MBT, CIT, CIT}} where {MBT, CIT}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    self::SysmatAssemblerSparseSymm,
    mat::MT,
    dofnums::IT,
    ignore
) where {MT, IT}</code></pre><p>Assemble a square symmetric matrix.</p><p><code>dofnums</code> are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are assumed to be the same).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L422-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SV}, Tuple{SV, MV, IV}} where {SV&lt;:AbstractSysvecAssembler, MV, IV}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SV}, Tuple{SV, MV, IV}} where {SV&lt;:AbstractSysvecAssembler, MV, IV}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(self::SysvecAssembler{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L739-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SysvecAssembler, MV, IV}} where {MV, IV}" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SysvecAssembler, MV, IV}} where {MV, IV}"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(self::SysvecAssembler{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L803-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerReduced}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerReduced}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix!(self::SysmatAssemblerReduced)</code></pre><p>Make a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L1108-L1112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseDiag}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseDiag}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix!(self::SysmatAssemblerSparseDiag)</code></pre><p>Make a sparse symmetric square diagonal matrix.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>nomatrixresult</code> is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When the matrix is constructed (<code>nomatrixresult</code> is false), the buffers are not deallocated, and the <code>buffer_pointer</code> is set to 1. It is then possible to immediately start assembling another matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L664-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)</code></pre><p>Make a sparse HRZ-lumped <strong>symmetric square</strong>  matrix.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>nomatrixresult</code> is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When the matrix is constructed (<code>nomatrixresult</code> is false), the buffers are not deallocated, and the <code>buffer_pointer</code> is set to 1. It is then possible to immediately start assembling another matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L991-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix!(self::SysmatAssemblerSparseSymm)</code></pre><p>Make a sparse symmetric square matrix.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>nomatrixresult</code> is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When the matrix is constructed (<code>nomatrixresult</code> is false), the buffers are not deallocated, and the <code>buffer_pointer</code> is set to 1. It is then possible to immediately start assembling another matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L468-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix!(self::SysmatAssemblerSparse)</code></pre><p>Make a sparse matrix.</p><p>A named tuple of the four matrix blocks is returned, as described in the documentation for the constructor.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>nomatrixresult</code> is set to true, dummy (zero) sparse matrices are returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When the matrix is constructed (<code>nomatrixresult</code> is false), the buffers are not deallocated, and the <code>buffer_pointer</code> is set to 1. It is then possible to immediately start assembling another matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L237-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!-Tuple{SV} where SV&lt;:AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.makevector!-Tuple{SV} where SV&lt;:AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makevector!(self::SysvecAssembler)</code></pre><p>Make the global vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L752-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}" href="#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makevector!(self::SysvecAssembler)</code></pre><p>Make the global vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L823-L827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SV}, Tuple{SV, Tuple{IT, IT}}} where {SV&lt;:AbstractSysvecAssembler, IT}" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SV}, Tuple{SV, Tuple{IT, IT}}} where {SV&lt;:AbstractSysvecAssembler, IT}"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysvecAssembler{T}, ndofs_row::FInt) where {T&lt;:Number}</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.</p><ul><li><code>elem_mat_nmatrices</code> = number of element matrices expected to be processed during the assembly.</li><li><code>ndofs_row</code>= Total number of degrees of freedom.</li></ul><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L721-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SysvecAssembler, IT}} where IT&lt;:Integer" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SysvecAssembler, IT}} where IT&lt;:Integer"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysvecAssembler, ndofs_row)</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.</p><p><code>ndofs_row</code>= Total number of degrees of freedom.</p><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L783-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseDiag{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseDiag{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysmatAssemblerSparseDiag{T},
    expected_ntriples::IT,
    row_nalldofs::IT,
    col_nalldofs::IT;
    force_init = false
    ) where {T, IT&lt;:Integer}</code></pre><p>Start the assembly of a symmetric square diagonal matrix.</p><p>The method makes buffers for matrix assembly. It must be called before the first call to the method <code>assemble!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>expected_ntriples</code>= expected number of coordinate triples, i.e. the number of terms in the <code>I</code>, <code>J</code>, <code>V</code> vectors;</li><li><code>row_nalldofs</code>= The total number of rows as a tuple;</li><li><code>col_nalldofs</code>= The total number of columns as a tuple.</li></ul><p>The values stored in the buffers are initially undefined!</p><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L572-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},
        expected_ntriples::IT,
        row_nalldofs::IT,
        col_nalldofs::IT;
        force_init = false
        ) where {T, IT&lt;:Integer}</code></pre><p>Start the assembly of a symmetric lumped diagonal square global matrix.</p><p>The method makes buffers for matrix assembly. It must be called before the first call to the method <code>assemble!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>expected_ntriples</code>= expected number of coordinate triples, i.e. the number of terms in the <code>I</code>, <code>J</code>, <code>V</code> vectors;</li><li><code>row_nalldofs</code>= The total number of rows as a tuple;</li><li><code>col_nalldofs</code>= The total number of columns as a tuple.</li></ul><p>The values stored in the buffers are initially undefined!</p><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L895-L918">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysmatAssemblerSparseSymm{T},
    expected_ntriples::IT,
    row_nalldofs::IT,
    col_nalldofs::IT;
    force_init = false
    ) where {T, IT&lt;:Integer}</code></pre><p>Start the assembly of a global matrix.</p><p>The method makes buffers for matrix assembly. It must be called before the first call to the method <code>assemble!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>expected_ntriples</code>= expected number of coordinate triples, i.e. the number of terms in the <code>I</code>, <code>J</code>, <code>V</code> vectors;</li><li><code>row_nalldofs</code>= The total number of rows as a tuple;</li><li><code>col_nalldofs</code>= The total number of columns as a tuple.</li></ul><p>If the <code>buffer_pointer</code> field of the assembler is 0, which is the case after that assembler was created, the buffers are resized appropriately given the dimensions on input. Otherwise, the buffers are left completely untouched. The <code>buffer_pointer</code> is set to the beginning of the buffer, namely 1.</p><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The buffers may be automatically resized if more numbers are assembled then initially intended. However, this operation will not necessarily be efficient and fast.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The buffers are initially not filled with anything meaningful. After the assembly, only the <code>(self.buffer_pointer - 1)</code> entries are meaningful numbers. Beware!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L356-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparse{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparse{T, T1, MBT, IJT} where {T1, MBT&lt;:AbstractVector{T1}, IJT&lt;:AbstractVector{T}}, IT, IT, IT}} where {T, IT&lt;:Integer}"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startassembly!(self::SysmatAssemblerSparse{T},
    expected_ntriples::IT,
    row_nalldofs::IT,
    col_nalldofs::IT;
    force_init = false
    ) where {T, IT&lt;:Integer}</code></pre><p>Start the assembly of a global matrix.</p><p>The method makes buffers for matrix assembly. It must be called before the first call to the method <code>assemble!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>expected_ntriples</code>= expected number of coordinate triples, i.e. the number of terms in the <code>I</code>, <code>J</code>, <code>V</code> vectors;</li><li><code>row_nalldofs</code>= The total number of rows as a tuple;</li><li><code>col_nalldofs</code>= The total number of columns as a tuple.</li></ul><p>If the <code>buffer_pointer</code> field of the assembler is 0, which is the case after that assembler was created, the buffers are resized appropriately given the dimensions on input. Otherwise, the buffers are left completely untouched. The <code>buffer_pointer</code> is set to the beginning of the buffer, namely 1.</p><p><strong>Returns</strong></p><ul><li><code>self</code>: the modified assembler.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The buffers are initially not filled with anything meaningful. After the assembly, only the <code>(self.buffer_pointer - 1)</code> entries are meaningful numbers. Beware!</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The buffers may be automatically resized if more numbers are assembled then initially intended. However, this operation will not necessarily be efficient and fast.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AssemblyModule.jl#L130-L168">source</a></section></article><h2 id="Meshing"><a class="docs-heading-anchor" href="#Meshing">Meshing</a><a id="Meshing-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing" title="Permalink"></a></h2><h3 id="Meshing-with-line-elements"><a class="docs-heading-anchor" href="#Meshing-with-line-elements">Meshing with line elements</a><a id="Meshing-with-line-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-with-line-elements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L2block-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshLineModule.L2block-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshLineModule.L2block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L2block(Length::T, nL::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a 1-D block of L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshLineModule.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L2blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.MeshLineModule.L2blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.MeshLineModule.L2blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L2blockx(xs::Vector{T}) where {T&lt;:Number}</code></pre><p>Graded mesh of a 1-D block, L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshLineModule.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L3blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.MeshLineModule.L3blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.MeshLineModule.L3blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L3blockx(xs::Vector{T}) where {T&lt;:Number}</code></pre><p>Graded mesh of a 1-D block, L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshLineModule.jl#L41-L45">source</a></section></article><h3 id="Meshing-with-triangles"><a class="docs-heading-anchor" href="#Meshing-with-triangles">Meshing with triangles</a><a id="Meshing-with-triangles-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-with-triangles" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.Q4toT3" href="#FinEtools.MeshTriangleModule.Q4toT3"><code>FinEtools.MeshTriangleModule.Q4toT3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)</code></pre><p>Convert a mesh of quadrilateral Q4&#39;s to two T3 triangles  each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T3annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T3annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3annulus(rin::T, rex::T, nr::IT, nc::IT, angl::T, orientation::Symbol=:a)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T3block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T3block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3block(Length::T, Width::T, nL::IT, nW::IT, orientation::Symbol = :a
    ) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>T3 mesh of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number" href="#FinEtools.MeshTriangleModule.T3blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number"><code>FinEtools.MeshTriangleModule.T3blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, orientation::Symbol = :a
    ) where {T&lt;:Number}</code></pre><p>T3 mesh of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T3circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T3circlen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3circlen(radius::T, nperradius::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a quarter circle with a given number of elements per radius.</p><p>The parameter <code>nperradius</code> should be an even  number; if that isn&#39;t so is adjusted to by adding one. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L305-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3circleseg-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T3circleseg-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T3circleseg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3circleseg(
    angle::T,
    radius::T,
    ncircumferentially::IT,
    nperradius::IT,
    orientation::Symbol = :a,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a segment of a circle.</p><p>The subtended angle is <code>angle</code> in radians. The orientation: refer to <code>T3block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L342-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet, FESetT3}" href="#FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet, FESetT3}"><code>FinEtools.MeshTriangleModule.T3refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3refine(fens::FENodeSet,fes::FESetT3)</code></pre><p>Refine a mesh of 3-node triangles by quadrisection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet, FESetT3}" href="#FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet, FESetT3}"><code>FinEtools.MeshTriangleModule.T3toT6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T3toT6(fens::FENodeSet, fes::FESetT3)</code></pre><p>Convert a mesh of triangle T3 (three-node) to triangle T6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T6annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T6annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T6annulus(
    rin::T,
    rex::T,
    nr::IT,
    nc::IT,
    angl::T,
    orientation::Symbol = :a,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L269-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTriangleModule.T6block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTriangleModule.T6block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T6block(Length::T, Width::T, nL::IT, nW::IT, orientation::Symbol = :a
    ) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a rectangle of T6 elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number" href="#FinEtools.MeshTriangleModule.T6blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number"><code>FinEtools.MeshTriangleModule.T6blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T6blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, orientation::Symbol = :a
    ) where {T&lt;:Number}</code></pre><p>Graded mesh of a 2-D block of T6 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTriangleModule.jl#L157-L162">source</a></section></article><h3 id="Meshing-with-quadrilaterals"><a class="docs-heading-anchor" href="#Meshing-with-quadrilaterals">Meshing with quadrilaterals</a><a id="Meshing-with-quadrilaterals-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-with-quadrilaterals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4annulus(rin::T, rex::T, nr::IT, nc::IT, Angl::T) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4block(Length::T, Width::T, nL::IT, nW::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a rectangle, Q4 elements.</p><p>Divided into elements: nL, nW in the first, second (x,y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshQuadrilateralModule.Q4blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshQuadrilateralModule.Q4blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4blockx(xs::Vector{T}, ys::Vector{T})</code></pre><p>Graded mesh  of a rectangle, Q4 finite elements.</p><p>Mesh of a 2-D block, Q4 finite elements. The nodes are located at the Cartesian product of the two intervals on the input.  This allows for construction of graded meshes.</p><p>xs,ys - Locations of the individual planes of nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L155-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4circlen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4circlen(radius::T, nperradius::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a quarter circle with a given number of elements per radius.</p><p>The parameter <code>nperradius</code> should be an even  number; if that isn&#39;t so is adjusted to by adding one. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L469-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4elliphole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4elliphole(
    xradius::T,
    yradius::T,
    L::T,
    H::T,
    nL::IT,
    nH::IT,
    nW::IT,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><p><code>xradius</code>,<code>yradius</code> = radius of the ellipse, <code>L,H</code>= and dimensions of the plate, <code>nL,nH</code>= numbers of edges along the side of the plate; this also happens     to be the number of edges along the circumference of the elliptical     hole <code>nW</code>= number of edges along the remaining straight edge (from the hole     in the direction of the length),</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L85-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4extrudeL2-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetL2, IT, F}} where {F&lt;:Function, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4extrudeL2-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetL2, IT, F}} where {F&lt;:Function, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4extrudeL2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4extrudeL2(
    fens::FENodeSet,
    fes::FESetL2,
    nLayers::IT,
    extrusionh::F,
) where {F&lt;:Function, IT&lt;:Integer}</code></pre><p>Extrude a mesh of linear segments into a mesh of quadrilaterals (Q4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L527-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4quadrilateral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4quadrilateral(xyz::Matrix{T}, nL::IT, nW::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a general quadrilateral given by the location of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet, FESetQ4}" href="#FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet, FESetQ4}"><code>FinEtools.MeshQuadrilateralModule.Q4refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4refine(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Refine a mesh of quadrilaterals by bisection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q4spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q4spheren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4spheren(radius::T, nperradius::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Generate mesh of a spherical surface (1/8th of the sphere).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L440-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet, FESetQ4}" href="#FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet, FESetQ4}"><code>FinEtools.MeshQuadrilateralModule.Q4toQ8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q4toQ8(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Convert a mesh of quadrilateral Q4 to quadrilateral Q8.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q8annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q8annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q8annulus(rin::T, rex::T, nr::IT, nc::IT, Angl::T) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius rin<code>, and  external radius</code>rex<code>, and  development angle Angl. Divided into elements:</code>nr<code>,</code>nc` in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L406-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshQuadrilateralModule.Q8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshQuadrilateralModule.Q8block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q8block(Length::T, Width::T, nL::IT, nW::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a rectangle of Q8 elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshQuadrilateralModule.Q8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshQuadrilateralModule.Q8blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q8blockx(xs::Vector{T}, ys::Vector{T}) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Graded mesh of a 2-D block of Q8 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q9blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshQuadrilateralModule.Q9blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshQuadrilateralModule.Q9blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q9blockx(xs::Vector{T}, ys::Vector{T}) where {T&lt;:Number}</code></pre><p>Create a block of the quadratic Lagrangean Q9 nine-node quadrilaterals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshQuadrilateralModule.jl#L348-L352">source</a></section></article><h3 id="Meshing-with-tetrahedra"><a class="docs-heading-anchor" href="#Meshing-with-tetrahedra">Meshing with tetrahedra</a><a id="Meshing-with-tetrahedra-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-with-tetrahedra" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T10block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T10block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10block(
    Length::T,
    Width::T,
    Height::T,
    nL::IT,
    nW::IT,
    nH::IT;
    orientation::Symbol = :a,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Generate a tetrahedral  mesh of T10 elements  of a rectangular block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L231-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number" href="#FinEtools.MeshTetrahedronModule.T10blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number"><code>FinEtools.MeshTetrahedronModule.T10blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, zs::VecOrMat{T}, orientation::Symbol = :a) where {T&lt;:Number}</code></pre><p>Generate a graded 10-node tetrahedral mesh  of a 3D block.</p><p>10-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into six tetrahedra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L256-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T10cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T10cylindern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10cylindern(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Ten-node tetrahedron mesh of solid  cylinder with given number of edges per radius.</p><p>The axis of the cylinder is along the Z axis. </p><p>Even though the orientation is controllable, for some orientations the mesh is highly distorted (<code>:a</code>, <code>:ca</code>, <code>:cb</code>). So a decent mesh can only be expected for the orientation <code>:b</code> (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L1050-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T10layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T10layeredplatex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10layeredplatex(
    xs::VecOrMat{T},
    ys::VecOrMat{T},
    ts::VecOrMat{T},
    nts::VecOrMat{IT},
    orientation::Symbol = :a,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>T10 mesh for a layered block (composite plate) with specified in plane coordinates.</p><p>xs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer</p><p>The finite elements of each layer are labeled with the layer number, starting from 1 at the bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L276-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T10quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T10quartercyln</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10quartercyln(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Ten-node tetrahedron mesh of one quarter of solid  cylinder with given number of edges per radius.</p><p>See: T4quartercyln</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L923-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10refine-Tuple{FENodeSet, FESetT10}" href="#FinEtools.MeshTetrahedronModule.T10refine-Tuple{FENodeSet, FESetT10}"><code>FinEtools.MeshTetrahedronModule.T10refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10refine(fens::FENodeSet, fes::FESetT10)</code></pre><p>Refine the mesh of quadratic tetrahedra.</p><p>Each tetrahedron is converted to eight tetrahedra (each face is quadri-sected).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L681-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10toT4-Tuple{FENodeSet, FESetT10}" href="#FinEtools.MeshTetrahedronModule.T10toT4-Tuple{FENodeSet, FESetT10}"><code>FinEtools.MeshTetrahedronModule.T10toT4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T10toT4(fens::FENodeSet,  fes::FESetT4)</code></pre><p>Convert a mesh of tetrahedra of type T10 (quadratic 10-node) to tetrahedra T4.</p><p>If desired, the array of nodes may be compacted so that unconnected nodes are deleted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}, Tuple{T, T, T, IT, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}, Tuple{T, T, T, IT, IT, IT, Symbol}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T4block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4block(
    Length::T,
    Width::T,
    Height::T,
    nL::IT,
    nW::IT,
    nH::IT,
    orientation::Symbol = :a,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Generate a tetrahedral mesh  of the 3D block.</p><p>Four-node tetrahedra in a regular arrangement, with uniform spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into five or six tetrahedra, depending on the orientation: <code>orientation</code> = <code>:a</code>, <code>:b</code> generates 6 tetrahedra per cell. <code>:ca</code>, <code>:cb</code> generates 5 tetrahedra per cell.</p><p>Range =&lt;0, Length&gt; x &lt;0, Width&gt; x &lt;0, Height&gt;. Divided into elements: nL x nW x nH.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L31-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number" href="#FinEtools.MeshTetrahedronModule.T4blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T&lt;:Number"><code>FinEtools.MeshTetrahedronModule.T4blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, zs::VecOrMat{T}, orientation::Symbol = :a) where {T&lt;:Number}</code></pre><p>Generate a graded tetrahedral mesh  of a 3D block.</p><p>Four-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into five or six tetrahedra: refer to <code>T4block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T4cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T4cylindern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4cylindern(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Four-node tetrahedron mesh of solid  cylinder with given number of edges per radius.</p><p>The axis of the cylinder is along the Z axis. </p><p>Even though the orientation is controllable, for some orientations the mesh is highly distorted (<code>:a</code>, <code>:ca</code>, <code>:cb</code>). So a decent mesh can only be expected for the orientation <code>:b</code> (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L1025-L1036">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4extrudeT3-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetT3, IT, F}} where {F&lt;:Function, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T4extrudeT3-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetT3, IT, F}} where {F&lt;:Function, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T4extrudeT3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4extrudeT3(
    fens::FENodeSet,
    fes::FESetT3,
    nLayers::IT,
    extrusionh::F,
) where {F&lt;:Function, IT&lt;:Integer}</code></pre><p>Extrude a mesh of triangles into a mesh of tetrahedra (T4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L986-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4meshedges-Union{Tuple{Matrix{IT}}, Tuple{IT}} where IT&lt;:Integer" href="#FinEtools.MeshTetrahedronModule.T4meshedges-Union{Tuple{Matrix{IT}}, Tuple{IT}} where IT&lt;:Integer"><code>FinEtools.MeshTetrahedronModule.T4meshedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4meshedges(t::Array{IT,2}) where {IT&lt;:Integer}</code></pre><p>Compute all the edges of the 4-node triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L468-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshTetrahedronModule.T4quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshTetrahedronModule.T4quartercyln</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4quartercyln(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Four-node tetrahedron mesh of one quarter of solid  cylinder with given number of edges per radius.</p><p>The axis of the cylinder is along the Z axis. The mesh may be mirrored to create half a cylinder or a full cylinder.</p><p>Even though the orientation is controllable, for some orientations the mesh is highly distorted (<code>:a</code>, <code>:ca</code>, <code>:cb</code>). So a decent mesh can only be expected for the orientation <code>:b</code> (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L847-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4refine-Tuple{FENodeSet, FESetT4}" href="#FinEtools.MeshTetrahedronModule.T4refine-Tuple{FENodeSet, FESetT4}"><code>FinEtools.MeshTetrahedronModule.T4refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4refine(fens::FENodeSet, fes::FESetT4)</code></pre><p>Refine a mesh of 4-node tetrahedra by octasection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L637-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4refine20-Tuple{FENodeSet, FESetT4}" href="#FinEtools.MeshTetrahedronModule.T4refine20-Tuple{FENodeSet, FESetT4}"><code>FinEtools.MeshTetrahedronModule.T4refine20</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4refine20(fens::FENodeSet, fes::FESetT4)</code></pre><p>Refine a tetrahedral four-node mesh into another four-node tetrahedral mesh, with each original tetrahedron being subdivided into 20 new tetrahedra.</p><p>Each vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L726-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4toT10-Tuple{FENodeSet, FESetT4}" href="#FinEtools.MeshTetrahedronModule.T4toT10-Tuple{FENodeSet, FESetT4}"><code>FinEtools.MeshTetrahedronModule.T4toT10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4toT10(fens::FENodeSet,  fes::FESetT4)</code></pre><p>Convert a mesh of tetrahedra of type T4 (four-node) to tetrahedra T10.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, T, Vector{DataT}}} where {DataT&lt;:Number, T}" href="#FinEtools.MeshTetrahedronModule.T4voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, T, Vector{DataT}}} where {DataT&lt;:Number, T}"><code>FinEtools.MeshTetrahedronModule.T4voximg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4voximg(
    img::Array{DataT,3},
    voxdims::T,
    voxval::Array{DataT,1},
) where {DataT&lt;:Number, T}</code></pre><p>Generate a tetrahedral mesh  from three-dimensional image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L612-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{Matrix{T}}, Tuple{T}} where T" href="#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>FinEtools.MeshTetrahedronModule.tetv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tetv(X)</code></pre><p>Compute the volume of a tetrahedron.</p><pre><code class="nohighlight hljs">X = [0  4  3
9  2  4
6  1  7
0  1  5] # for these points the volume is 10.0
tetv(X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L321-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, NTuple{12, T}} where T&lt;:Number" href="#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, NTuple{12, T}} where T&lt;:Number"><code>FinEtools.MeshTetrahedronModule.tetv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tetv(X)</code></pre><p>Compute the volume of a tetrahedron.</p><pre><code class="nohighlight hljs">X = [0  4  3
9  2  4
6  1  7
0  1  5] # for these points the volume is 10.0
tetv(X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L354-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Int64, Int64}} where T" href="#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Int64, Int64}} where T"><code>FinEtools.MeshTetrahedronModule.tetv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tetv(X)</code></pre><p>Compute the volume of a tetrahedron.</p><pre><code class="nohighlight hljs">X = Float64[0  4  3
9  2  4
6  1  7
0  1  5] # for these points the volume is 10.0
tetv(X, 1, 2, 3, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L394-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.tetv1times6-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Int64, Int64}} where T" href="#FinEtools.MeshTetrahedronModule.tetv1times6-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Int64, Int64}} where T"><code>FinEtools.MeshTetrahedronModule.tetv1times6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tetv1times6(v, i1, i2, i3, i4)</code></pre><p>Compute 6 times the volume of the tetrahedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshTetrahedronModule.jl#L448-L452">source</a></section></article><h3 id="Meshing-with-hexahedra"><a class="docs-heading-anchor" href="#Meshing-with-hexahedra">Meshing with hexahedra</a><a id="Meshing-with-hexahedra-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-with-hexahedra" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H20block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H20block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H20block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Create mesh of a 3-D block of H20 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L522-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshHexahedronModule.H20blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshHexahedronModule.H20blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H20blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T&lt;:Number}</code></pre><p>Graded mesh of a 3-D block of H20 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L537-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H27block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H27block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H27block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Create mesh of a 3-D block of H27 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshHexahedronModule.H27blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshHexahedronModule.H27blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H27blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T&lt;:Number}</code></pre><p>Graded mesh of a 3-D block of H27 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L363-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Make  a mesh  of a 3D block consisting of  eight node hexahedra.</p><p>Length, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number" href="#FinEtools.MeshHexahedronModule.H8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Number"><code>FinEtools.MeshHexahedronModule.H8blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T&lt;:Number}</code></pre><p>Graded mesh of a 3-D block of H8 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8cylindern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8cylindern(Radius::T, Length::T, nperradius::IT, nL::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>H8 mesh of a solid  cylinder with given number of edges per radius (<code>nperradius</code>) and per length (<code>nL</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L787-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, T, IT, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, T, IT, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8elliphole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8elliphole(
    xradius::T,
    yradius::T,
    L::T,
    H::T,
    T::T,
    nL::IT,
    nH::IT,
    nW::IT,
    nT::IT,
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><p><code>xradius</code>,<code>yradius</code> = radii of the ellipse, <code>L</code>,<code>H</code> = dimensions of the plate, <code>Th</code> = thickness of the plate <code>nL</code>,<code>nH</code>= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole <code>nW</code> = number of edges along the remaining straight edge (from the hole   in the radial direction),</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L746-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetQ4, IT, F}} where {F&lt;:Function, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetQ4, IT, F}} where {F&lt;:Function, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8extrudeQ4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8extrudeQ4(
    fens::FENodeSet,
    fes::FESetQ4,
    nLayers::IT,
    extrusionh::F,
) where {F&lt;:Function, IT&lt;:Integer}</code></pre><p>Extrude a mesh of quadrilaterals into a mesh of hexahedra (H8).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8hexahedron-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8hexahedron-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8hexahedron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8hexahedron(xyz::Matrix{T}, nL::IT, nW::IT, nH::IT; blockfun = nothing) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Mesh of a general hexahedron given by the location of the vertices.</p><p><code>xyz</code> = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). <code>nL</code>,  <code>nW</code>,  <code>nH</code> = number of elements in each direction <code>blockfun</code> = Optional argument: function of the block-generating mesh function      (having the signature of the function <code>H8block()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L298-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{IT}}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{IT}}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8layeredplatex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8layeredplatex(xs::Vector{T}, ys::Vector{T}, ts::Vector{T}, nts::Vector{IT}) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>H8 mesh for a layered block (composite plate) with specified in plane coordinates.</p><p>xs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer</p><p>The finite elements of each layer are labeled with the layer number, starting from 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L713-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet, FESetH8}" href="#FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet, FESetH8}"><code>FinEtools.MeshHexahedronModule.H8refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8refine(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Refine a mesh of H8 hexahedrals by octasection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8sphere-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8sphere-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8sphere(radius::T, nrefine::IT) where {T&lt;:Number, IT&lt;:Integer}

Create a mesh of 1/8 of the sphere of &quot;radius&quot;. The  mesh will consist of
four hexahedral elements if &quot;nrefine==0&quot;,  or more if &quot;nrefine&gt;0&quot;.
&quot;nrefine&quot; is the number of bisections applied  to refine the mesh.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshHexahedronModule.H8spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshHexahedronModule.H8spheren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8spheren(radius::T, nperradius::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Create a solid mesh of 1/8 of sphere.</p><p>Create a solid mesh of 1/8 of the sphere of <code>radius</code>,  with <code>nperradius</code> elements per radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L428-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet, FESetH8}" href="#FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet, FESetH8}"><code>FinEtools.MeshHexahedronModule.H8toH20</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8toH20(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Convert a mesh of hexahedra H8 to hexahedra H20.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L547-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet, FESetH8}" href="#FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet, FESetH8}"><code>FinEtools.MeshHexahedronModule.H8toH27</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8toH27(fens::FENodeSet,  fes::FESetH8)

Convert a mesh of hexahedra H8 to hexahedra H27.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, Vector{T}, Vector{DataT}}} where {DataT&lt;:Number, T&lt;:Number}" href="#FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, Vector{T}, Vector{DataT}}} where {DataT&lt;:Number, T&lt;:Number}"><code>FinEtools.MeshHexahedronModule.H8voximg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H8voximg(
    img::Array{DataT,3},
    voxdims::Vector{T},
    voxval::Array{DataT,1},
) where {DataT&lt;:Number}</code></pre><p>Generate a hexahedral mesh  from three-dimensional image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L688-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet, FESetT4}" href="#FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet, FESetT4}"><code>FinEtools.MeshHexahedronModule.T4toH8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T4toH8(fens::FENodeSet, fes::FESetT4)</code></pre><p>Convert a tetrahedral four-node mesh into eight-node hexahedra.</p><p>Each vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshHexahedronModule.jl#L815-L823">source</a></section></article><h3 id="Mesh-selection"><a class="docs-heading-anchor" href="#Mesh-selection">Mesh selection</a><a id="Mesh-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-selection" title="Permalink"></a></h3><p>See above as &quot;Selecting nodes and elements&quot;.</p><h3 id="Mesh-modification"><a class="docs-heading-anchor" href="#Mesh-modification">Mesh modification</a><a id="Mesh-modification-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-modification" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet, BitVector}" href="#FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet, BitVector}"><code>FinEtools.MeshModificationModule.compactnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compactnodes(fens::FENodeSet, connected::Vector{Bool})</code></pre><p>Compact the finite element node set by deleting unconnected nodes.</p><p><code>fens</code> = array of finite element nodes <code>connected</code> = The array element <code>connected[j]</code> is either 0 (when <code>j</code> is an   unconnected node), or a positive number (when node <code>j</code> is connected to   other nodes by at least one finite element)</p><p><strong>Output</strong></p><p><code>fens</code> = new set of finite element nodes <code>new_numbering</code>= array which tells where in the new <code>fens</code> array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      <code>new_numbering[5]</code> is 3.</p><p><strong>Examples</strong></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="nohighlight hljs">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactnodes(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="nohighlight hljs">validate_mesh(fens, fes);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L298-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.distortblock-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, T, T, IT, IT, T, T}} where {F&lt;:Function, T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshModificationModule.distortblock-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, T, T, IT, IT, T, T}} where {F&lt;:Function, T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshModificationModule.distortblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distortblock(
    B::F,
    Length::T,
    Width::T,
    nL::IT,
    nW::IT,
    xdispmul::T,
    ydispmul::T,
) where {F&lt;:Function, T&lt;:Number, IT&lt;:Integer}</code></pre><p>Distort a block mesh by shifting around the nodes. The goal is to distort the horizontal and vertical mesh lines into slanted lines. This is useful when testing finite elements where special directions must be avoided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L1094-L1108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.distortblock-Union{Tuple{T}, Tuple{FENodeSet{T}, T, T}} where T&lt;:Number" href="#FinEtools.MeshModificationModule.distortblock-Union{Tuple{T}, Tuple{FENodeSet{T}, T, T}} where T&lt;:Number"><code>FinEtools.MeshModificationModule.distortblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distortblock(ofens::FENodeSet{T}, xdispmul::T, ydispmul::T) where {T&lt;:Number}</code></pre><p>Distort a block mesh by shifting around the nodes. The goal is to distort the horizontal and vertical mesh lines into slanted lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L1067-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.fusenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, FENodeSet{T}, T}} where T&lt;:Number" href="#FinEtools.MeshModificationModule.fusenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, FENodeSet{T}, T}} where T&lt;:Number"><code>FinEtools.MeshModificationModule.fusenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fusenodes(fens1::FENodeSet{T}, fens2::FENodeSet{T}, tolerance::T) where {T&lt;:Number}</code></pre><p>Fuse together nodes from two node sets.</p><p>Fuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, <code>fens1</code> and <code>fens2</code>,  are fused together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the new  indexes of the nodes in the set <code>fens1</code> are returned.</p><p>The set <code>fens2</code> will be included unchanged, in the same order, in the node set <code>fens</code>. The indexes of the node set <code>fens1</code> will have changed.</p><p><strong>Example</strong></p><p>After the call to this function we have <code>k=new_indexes_of_fens1_nodes[j]</code> is the node in the node set <code>fens</code> which used to be node <code>j</code> in node set <code>fens1</code>. The finite element set connectivity that used to refer to <code>fens1</code> needs to be updated to refer to the same nodes in  the set <code>fens</code> as      <code>updateconn!(fes, new_indexes_of_fens1_nodes);</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L187-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.interior2boundary-Union{Tuple{IT}, Tuple{Matrix{IT}, Matrix{IT}}} where IT&lt;:Integer" href="#FinEtools.MeshModificationModule.interior2boundary-Union{Tuple{IT}, Tuple{Matrix{IT}, Matrix{IT}}} where IT&lt;:Integer"><code>FinEtools.MeshModificationModule.interior2boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interior2boundary(interiorconn::Array{IT,2}, extractb::Array{IT,2}) where {IT&lt;:Integer}</code></pre><p>Extract the boundary connectivity from the connectivity of the interior.</p><p><code>extractb</code> = array that defines in which order the bounding faces are traversed. For     example, for tetrahedra this array is     <code>extractb = [1 3 2; 1 2 4; 2 3 4; 1 4 3]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{FENodeSet{T}, T1, FENodeSet{T}, T2, T}} where {T, T1&lt;:AbstractFESet, T2&lt;:AbstractFESet}" href="#FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{FENodeSet{T}, T1, FENodeSet{T}, T2, T}} where {T, T1&lt;:AbstractFESet, T2&lt;:AbstractFESet}"><code>FinEtools.MeshModificationModule.mergemeshes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergemeshes(
    fens1::FENodeSet{T},
    fes1::T1,
    fens2::FENodeSet{T},
    fes2::T2,
    tolerance::T,
) where {T, T1&lt;:AbstractFESet, T2&lt;:AbstractFESet}</code></pre><p>Merge together two meshes.</p><p>Merge two meshes together by gluing together nodes within tolerance. The two meshes, <code>fens1</code>, <code>fes1</code>, and <code>fens2</code>, <code>fes2</code>, are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.</p><p>The merged node set, <code>fens</code>, and the two finite element sets with renumbered  connectivities are returned.</p><p>Important notes: On entry into this function the connectivity of <code>fes1</code> point into <code>fens1</code> and the connectivity of <code>fes2</code> point into <code>fens2</code>. After this function returns the connectivity of both <code>fes1</code> and <code>fes2</code> point into <code>fens</code>. The order of the nodes of the node set <code>fens1</code> in the resulting set <code>fens</code> will have changed, whereas the order of the nodes of the node set <code>fens2</code> is are guaranteed to be the same. Therefore, the connectivity of <code>fes2</code> will in fact remain the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L345-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenmeshes-Union{Tuple{T}, Tuple{Array{Tuple{FENodeSet, AbstractFESet}}, T}} where T&lt;:Number" href="#FinEtools.MeshModificationModule.mergenmeshes-Union{Tuple{T}, Tuple{Array{Tuple{FENodeSet, AbstractFESet}}, T}} where T&lt;:Number"><code>FinEtools.MeshModificationModule.mergenmeshes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergenmeshes(meshes::Array{Tuple{FENodeSet{T},AbstractFESet}}, tolerance::T) where {T&lt;:Number}</code></pre><p>Merge several meshes together.</p><p>The meshes are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of nodes is performed; the nodes from the meshes are simply concatenated together.</p><p><strong>Output</strong></p><p>The merged node set, <code>fens</code>, and an array of finite element sets with renumbered  connectivities are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L389-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenodes-Union{Tuple{IT}, Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T, AbstractVector{IT}}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshModificationModule.mergenodes-Union{Tuple{IT}, Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T, AbstractVector{IT}}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshModificationModule.mergenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergenodes(
    fens::FENodeSet{T},
    fes::AbstractFESet,
    tolerance::T,
    candidates::AbstractVector{IT},
) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Merge together  nodes of a single node set.</p><p>Similar to <code>mergenodes(fens, fes, tolerance)</code>, but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L484-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T}} where T&lt;:Number" href="#FinEtools.MeshModificationModule.mergenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T}} where T&lt;:Number"><code>FinEtools.MeshModificationModule.mergenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergenodes(fens::FENodeSet{T}, fes::AbstractFESet, tolerance::T) where {T&lt;:Number}</code></pre><p>Merge together nodes of a single node set.</p><p>Merge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the finite element set, <code>fes</code>, with renumbered  connectivities are returned.</p><p>Warning: This tends to be an expensive operation!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L422-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshboundary-Tuple{T} where T&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.meshboundary-Tuple{T} where T&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.meshboundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meshboundary(fes::T) where {T&lt;:AbstractFESet}</code></pre><p>Extract the boundary finite elements from a mesh.</p><p>Extract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet, T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet, T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.meshsmoothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meshsmoothing(fens::FENodeSet, fes::T; options...) where {T&lt;:AbstractFESet}</code></pre><p>General smoothing of meshes.</p><p><strong>Keyword options</strong></p><p><code>method</code> = :taubin (default) or :laplace <code>fixedv</code> = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) <code>npass</code> = number of passes (default 2)</p><p><strong>Return</strong></p><p>The modified  node set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L625-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{ET}, Tuple{FENodeSet, ET, Vector{T}, Vector{T}}} where {ET&lt;:AbstractFESet, T&lt;:Number}" href="#FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{ET}, Tuple{FENodeSet, ET, Vector{T}, Vector{T}}} where {ET&lt;:AbstractFESet, T&lt;:Number}"><code>FinEtools.MeshModificationModule.mirrormesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mirrormesh(
    fens::FENodeSet,
    fes::ET,
    Normal::Vector{T},
    Point::Vector{T};
    kwargs...,
) where {ET&lt;:AbstractFESet, T&lt;:Number}</code></pre><p>Mirror a mesh in a plane given by its normal and one point.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renumb</code> = node renumbering function for the mirrored element</li></ul><p>Warning: The code to relies on the numbering of the finite elements: to reverse the orientation of the mirrored finite elements, the connectivity is listed in reverse order.   If the mirrored finite elements do not follow this rule (for instance hexahedra or quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.</p><p>For instance: H8 elements require the renumbering function to be supplied as</p><pre><code class="nohighlight hljs">renumb = (c) -&gt; c[[1, 4, 3, 2, 5, 8, 7, 6]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L735-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning" href="#FinEtools.MeshModificationModule.nodepartitioning"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nodepartitioning(fens::FENodeSet, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>npartitions</code> = number of partitions, but note that the actual number of partitions will be a power of two.</p><p>In this variant all the nodes are to be included in the partitioning.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia hljs">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-Dollar(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; DollarFile`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L970-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning" href="#FinEtools.MeshModificationModule.nodepartitioning"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>nincluded</code> = Boolean array: is the node to be included in the partitioning or     not? <code>npartitions</code> = number of partitions, but note that the actual number of     partitions is going to be a power of two.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia hljs">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-$(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; $File`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L935-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet, Any, Vector{Int64}}" href="#FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet, Any, Vector{Int64}}"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>fesarr</code> = array of finite element sets that represent regions <code>npartitions</code> = array of the number of partitions in each region. However note that the actual number of partitions will be a power of two.</p><p>The partitioning itself is carried out by <code>nodepartitioning()</code> with a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to the elements of that region, but not to elements that belong to any of the previous regions, 1…I-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L1023-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.outer_surface_of_solid-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.outer_surface_of_solid-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.outer_surface_of_solid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outer_surface_of_solid(fens, bdry_fes)</code></pre><p>Find the finite elements that form the outer boundary surface.</p><p>!!! note:</p><p>The code will currently not work correctly for 2D axially symmetric geometries.</p><p><strong>Return</strong></p><p>Set of boundary finite elements that enclose the solid. Now cavities  are included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L1158-L1171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.pointpartitioning" href="#FinEtools.MeshModificationModule.pointpartitioning"><code>FinEtools.MeshModificationModule.pointpartitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pointpartitioning(xyz, npartitions::Int = 2)</code></pre><p>Compute the inertial-cut partitioning of a set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L1006-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.renumberconn!-Union{Tuple{IT}, Tuple{AbstractFESet, AbstractVector{IT}}} where IT&lt;:Integer" href="#FinEtools.MeshModificationModule.renumberconn!-Union{Tuple{IT}, Tuple{AbstractFESet, AbstractVector{IT}}} where IT&lt;:Integer"><code>FinEtools.MeshModificationModule.renumberconn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renumberconn!(fes::AbstractFESet, new_numbering::AbstractVector{IT}) where {IT&lt;:Integer}</code></pre><p>Renumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.</p><p><code>fes</code> =finite element set <code>new_numbering</code> = new serial numbers for the nodes.  The connectivity           should be changed as <code>conn[j]</code> –&gt; <code>new_numbering[conn[j]]</code></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="nohighlight hljs">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactnodes(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="language-julia hljs">validate_mesh(fens, fes);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L552-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.vertexneighbors-Union{Tuple{IT}, Tuple{Matrix{IT}, IT}} where IT&lt;:Integer" href="#FinEtools.MeshModificationModule.vertexneighbors-Union{Tuple{IT}, Tuple{Matrix{IT}, IT}} where IT&lt;:Integer"><code>FinEtools.MeshModificationModule.vertexneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertexneighbors(conn::Matrix{IT}, nvertices::IT) where {IT&lt;:Integer}</code></pre><p>Find the node neighbors in the mesh.</p><p>Return an array of integer vectors, element I holds an array of numbers of nodes which are connected to node I (including node I).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L710-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.vsmoothing-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, Matrix{IT}}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.MeshModificationModule.vsmoothing-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, Matrix{IT}}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.MeshModificationModule.vsmoothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vsmoothing(v::Matrix{T}, t::Matrix{IT}; kwargs...) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Internal routine for mesh smoothing.</p><p>Keyword options: <code>method</code> = :taubin (default) or :laplace <code>fixedv</code> = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) <code>npass</code> = number of passes (default 2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshModificationModule.jl#L584-L594">source</a></section></article><h3 id="Meshing-utilities"><a class="docs-heading-anchor" href="#Meshing-utilities">Meshing utilities</a><a id="Meshing-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.addhyperface!-Tuple{Any, Any, Any}" href="#FinEtools.MeshUtilModule.addhyperface!-Tuple{Any, Any, Any}"><code>FinEtools.MeshUtilModule.addhyperface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addhyperface!(container,hyperface,newn)</code></pre><p>Add a hyper face to the container.</p><p>The new node is stored in hyper face data in the container and can be retrieved later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.findhyperface!-Tuple{Any, Any}" href="#FinEtools.MeshUtilModule.findhyperface!-Tuple{Any, Any}"><code>FinEtools.MeshUtilModule.findhyperface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findhyperface!(container,hyperface)</code></pre><p>Find a hyper face in the container.</p><p>If the container holds the indicated hyper face, it is returned together with the stored new node number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T, T, Int64}, Tuple{T, T, Int64, Any}} where T&lt;:Number" href="#FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T, T, Int64}, Tuple{T, T, Int64, Any}} where T&lt;:Number"><code>FinEtools.MeshUtilModule.gradedspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradedspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate quadratic space.</p><p>Generate a quadratic sequence of <code>N</code> numbers between <code>start</code> and <code>stop</code>. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; gradedspace(2.0, 3.0, 5)
5-element Array{Float64,1}:
 2.0
 2.0625
 2.25
 2.5625
 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L112-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Number" href="#FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Number"><code>FinEtools.MeshUtilModule.linearspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate linear space.</p><p>Generate a linear sequence of <code>N</code> numbers between  <code>start</code> and <code>stop</code> (i. e. sequence  of number with uniform intervals inbetween).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; linearspace(2.0, 3.0, 5)
2.0:0.25:3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.logspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Number" href="#FinEtools.MeshUtilModule.logspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Number"><code>FinEtools.MeshUtilModule.logspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate logarithmic space.</p><p>Generate a logarithmic sequence of <code>N</code> numbers between  <code>start</code> and <code>stop</code> (i. e. sequence  of number with uniform intervals inbetween in the log space).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; logspace(2.0, 3.0, 5)                                                             
5-element Array{Float64,1}:                                                              
  100.0
  177.82794100389228   
  316.2277660168379      
  562.341325190349  
 1000.0    </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L142-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.makecontainer" href="#FinEtools.MeshUtilModule.makecontainer"><code>FinEtools.MeshUtilModule.makecontainer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makecontainer()</code></pre><p>Make hyper face container.</p><p>This is a dictionary of hyper faces, indexed with an anchor node. The anchor node is the smallest node number within the connectivity of the hyper face.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.ontosphere-Union{Tuple{T}, Tuple{Matrix{T}, T}} where T" href="#FinEtools.MeshUtilModule.ontosphere-Union{Tuple{T}, Tuple{Matrix{T}, T}} where T"><code>FinEtools.MeshUtilModule.ontosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ontosphere(xyz::Matrix{T}, radius::T) where {T}</code></pre><p>Project nodes onto a sphere of given radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshUtilModule.jl#L82-L86">source</a></section></article><h3 id="Mesh-import"><a class="docs-heading-anchor" href="#Mesh-import">Mesh import</a><a id="Mesh-import-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}" href="#FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}"><code>FinEtools.MeshImportModule.import_ABAQUS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_ABAQUS(filename)</code></pre><p>Import Abaqus mesh (.inp file).</p><p>Limitations:</p><ol><li>Only the <code>*NODE</code> and <code>*ELEMENT</code>  sections are read</li><li>Only 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 4-node quadrilaterals, 3-node triangles are handled.</li></ol><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot; = finite element nodes.</li><li>&quot;<code>fesets</code>&quot; = array of finite element sets.</li><li>&quot;<code>nsets</code>&quot; = dictionary of &quot;node sets&quot;, the keys are the names of the sets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshImportModule.jl#L214-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_H5MESH-Tuple{Any}" href="#FinEtools.MeshImportModule.import_H5MESH-Tuple{Any}"><code>FinEtools.MeshImportModule.import_H5MESH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_H5MESH(meshfile)</code></pre><p>Import mesh in the H5MESH format (.h5mesh file).</p><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot; = finite element nodes.</li><li>&quot;<code>fesets</code>&quot; = array of finite element sets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshImportModule.jl#L574-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_MESH-Tuple{Any}" href="#FinEtools.MeshImportModule.import_MESH-Tuple{Any}"><code>FinEtools.MeshImportModule.import_MESH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_MESH(filename)</code></pre><p>Import mesh in the MESH format (.mesh, .xyz, .conn triplet of files).</p><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot; = finite element nodes.</li><li>&quot;<code>fesets</code>&quot; = array of finite element sets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshImportModule.jl#L500-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}" href="#FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}"><code>FinEtools.MeshImportModule.import_NASTRAN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_NASTRAN(filename)</code></pre><p>Import tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).</p><p>Limitations:</p><ol><li>only the GRID, CTETRA, and PSOLID sections are read.</li><li>Only 4-node and 10-node tetrahedra  are handled.</li><li>The file should be free-form (data separated by commas). </li></ol><p>Some fixed-format files can also be processed (large-field, but not small-field).</p><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot;: set of finite element nodes, </li><li>&quot;<code>fesets</code>&quot;: array of finite element sets,</li><li>&quot;<code>property_ids</code>&quot;: array of property ids (integers) associated with the finite element sets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshImportModule.jl#L51-L68">source</a></section></article><h3 id="Mesh-export"><a class="docs-heading-anchor" href="#Mesh-export">Mesh export</a><a id="Mesh-export-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-export" title="Permalink"></a></h3><h4 id="VTK"><a class="docs-heading-anchor" href="#VTK">VTK</a><a id="VTK-1"></a><a class="docs-heading-anchor-permalink" href="#VTK" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String, Any, Any, Any}" href="#FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String, Any, Any, Any}"><code>FinEtools.MeshExportModule.VTK.vtkexportmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;
    vectors=nothing, scalars=nothing)</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p>Arguments:</p><ul><li><code>theFile</code> = file name,</li><li><code>Connectivity</code> = array of connectivities, one row per element,</li><li><code>Points</code> = array of node coordinates, one row per node,</li><li><code>Cell_type</code> = type of the cell, refer to the predefined constants P1, L2, ..., H20, ...</li><li><code>scalars</code> = array of tuples, (name, data)</li><li><code>vectors</code> = array of tuples, (name, data)</li></ul><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshExportModule.VTK.vtkexportmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T&lt;:AbstractFESet}</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p>Arguments:</p><ul><li><code>theFile</code> = file name,</li><li><code>fens</code> = finite element node set,</li><li><code>fes</code> = finite element set,</li><li><code>opts</code> = keyword argument list, where<ul><li><code>scalars</code> = array of tuples, (name, data)</li><li><code>vectors</code> = array of tuples, (name, data)</li></ul></li></ul><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L84-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String, Any, Any}" href="#FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String, Any, Any}"><code>FinEtools.MeshExportModule.VTK.vtkexportvectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkexportvectors(theFile::String, Points, vectors)</code></pre><p>Export vector data to a VTK 1.0 file.</p><p>Arguments:</p><ul><li><code>theFile</code> = file name,</li><li><code>Points</code> = array of collection of coordinates (tuples or vectors), </li><li><code>vectors</code> = array of tuples, <code>(name, data)</code>, where <code>name</code> is a string, and <code>data</code> is array of collection of coordinates (tuples or vectors).</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Points = [(1.0, 3.0), (0.0, -1.0)]
vectors = [(&quot;v&quot;, [(-1.0, -2.0), (1.0, 1.0)])]
vtkexportvectors(&quot;theFile.VTK&quot;, Points, vectors)</code></pre><p>will produce file with</p><pre><code class="nohighlight hljs"># vtk DataFile Version 1.0
FinEtools Export
ASCII

DATASET UNSTRUCTURED_GRID
POINTS 2 double
1.0 3.0 0.0
0.0 -1.0 0.0


POINT_DATA 2
VECTORS v double
-1.0 -2.0 0.0
1.0 1.0 0.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The filter &quot;Glyph&quot; must be used within Paraview. Also in the drop-down  menu &quot;Glyph mode&quot; select &quot;all points&quot;.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L294-L332">source</a></section></article><h4 id="Abaqus"><a class="docs-heading-anchor" href="#Abaqus">Abaqus</a><a id="Abaqus-1"></a><a class="docs-heading-anchor-permalink" href="#Abaqus" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{AbaqusExporter}" href="#Base.close-Tuple{AbaqusExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close(self::AbaqusExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1065-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.ASSEMBLY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*ASSEMBLY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer, Any}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer, Any}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,  fixed_value)</code></pre><p>Write out the <code>*BOUNDARY</code> option.</p><ul><li><code>NSET</code> = name of a node set,</li><li><code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node,</li><li><code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L906-L914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at zero for a node set.</p><p>Invoke at Level: Model,  Step</p><ul><li><code>NSET</code>= node set,</li><li><code>dof</code>=Degree of freedom, 1, 2, 3</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L923-L932">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F, AbstractString}} where F" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F, AbstractString}} where F"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  value::F) where {F}</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at nonzero value for a node set.</p><ul><li><code>NSET</code>= node set,</li><li><code>dof</code>=Degree of freedom, 1, 2, 3</li><li><code>typ</code> = DISPLACEMENT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L937-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BOUNDARY(self::AbaqusExporter, meshornset, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}</code></pre><p>Write out the <code>*BOUNDARY</code> option.</p><ul><li><code>meshornset</code> = name of a mesh or a node set,</li><li><code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, as many columns as there are degrees of freedom per node,</li><li><code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed, as many columns as there are degrees of freedom per node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L890-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BOUNDARY(self::AbaqusExporter, mesh, nodes, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}</code></pre><p>Write out the <code>*BOUNDARY</code> option. </p><p>The boundary condition is applied to the nodes specified in  the array <code>nodes</code>, in the mesh (or node set) <code>meshornset</code>.</p><p><code>meshornset</code> = mesh or node set (default is empty) <code>nodes</code> = array of node numbers, the node numbers are attached to the mesh label, <code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, <code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">BOUNDARY(AE, &quot;ASSEM1.INSTNC1&quot;, 1:4, fill(true, 4, 1), reshape([uy(fens.xyz[i, :]...) for i in 1:4], 4, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L840-L858">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.CLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>NSET=Node set dof= 1, 2, 3, magnitude= signed multiplier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L972-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, Integer, Integer, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, Integer, Integer, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.CLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>nodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L990-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.COMMENT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">COMMENT(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>**</code> comment option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L429-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter, Any}" href="#FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter, Any}"><code>FinEtools.MeshExportModule.Abaqus.DENSITY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DENSITY(self::AbaqusExporter, rho)</code></pre><p>Write out the <code>*DENSITY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L691-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractVector{F}}} where F" href="#FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractVector{F}}} where F"><code>FinEtools.MeshExportModule.Abaqus.DLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DLOAD(self::AbaqusExporter, ELSET::AbstractString,
  traction::AbstractVector{F}) where {F}</code></pre><p>Write out the <code>*DLOAD</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L957-L962">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, F, F, F, F, F, F, F, F, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, F, F, F, F, F, F, F, F, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.ELASTIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,
  G12::F, G13::F, G23::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ENGINEERING CONSTANTS</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L650-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, F, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, F, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.ELASTIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ISOTROPIC</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L671-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractString, Integer, AbstractMatrix{T}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractString, Integer, AbstractMatrix{T}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.ELEMENT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,
  start::Integer, conn::AbstractArray{T, 2}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELEMENT</code> option.</p><p><code>TYPE</code>= element type code, <code>ELSET</code>= element set to which the elements belong, <code>start</code>= start the element numbering at this integer, <code>conn</code>= connectivity array for the elements, one row per element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L520-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.ELSET_ELSET</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELSET</code> option.</p><p><code>ELSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L606-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter, AbstractString, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter, AbstractString, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.EL_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)</code></pre><p>Write out the <code>*EL PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1035-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">END_ASSEMBLY(self::AbaqusExporter)</code></pre><p>Write out the <code>*END ASSEMBLY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_INSTANCE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">END_INSTANCE(self::AbaqusExporter)</code></pre><p>Write out the <code>*END INSTANCE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_PART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">END_PART(self::AbaqusExporter)</code></pre><p>Write out the <code>*END PART</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L457-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_STEP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">END_STEP(self::AbaqusExporter)</code></pre><p>Write out the <code>*END STEP</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1056-L1060">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ENERGY_PRINT(self::AbaqusExporter)</code></pre><p>Write out the <code>*ENERGY PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1047-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.EXPANSION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EXPANSION(self::AbaqusExporter, CTE::F) where {F}</code></pre><p>Write out the <code>*EXPANSION</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L681-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.HEADING</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HEADING(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>*HEADING</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L438-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter, AbstractString, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter, AbstractString, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.INSTANCE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)</code></pre><p>Write out the <code>*INSTANCE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.MATERIAL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)</code></pre><p>Write out the <code>*MATERIAL</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L641-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractMatrix{T}}} where T" href="#FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractMatrix{T}}} where T"><code>FinEtools.MeshExportModule.Abaqus.NODE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}</code></pre><p>Write out the <code>*NODE</code> option.</p><p><code>xyz</code>=array of node coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L502-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.NODE_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)</code></pre><p>Write out the <code>*NODE PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1025-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.NSET_NSET</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NSET_NSET(self::AbaqusExporter, NSET::AbstractString,
  n::AbstractVector{T}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*NSET</code> option.</p><p><code>NSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L587-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>FinEtools.MeshExportModule.Abaqus.ORIENTATION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,
  a::AbstractArray{T,1}, b::AbstractArray{T,1})</code></pre><p>Write out the <code>*ORIENTATION</code> option.</p><p>Invoke at level: Part,  Part instance,  Assembly</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L624-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.PART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PART(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*PART</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L448-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter, AbstractString, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter, AbstractString, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,
  OPTIONAL::AbstractString)</code></pre><p>Write out the <code>*SECTION CONTROLS</code> option.</p><p><code>OPTIONAL</code> = string, for instance                      HOURGLASS=ENHANCED</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L701-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString,
  CONTROLS::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L716-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L742-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString, F}} where F" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString, F}} where F"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L764-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter, Integer}" href="#FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter, Integer}"><code>FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)</code></pre><p>Write out the <code>*STEP,FREQUENCY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L829-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter, Integer}" href="#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter, Integer}"><code>FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear buckling analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L818-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">STEP_PERTURBATION_STATIC(self::AbaqusExporter)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L808-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter, AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter, AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)</code></pre><p>Write out the <code>*SURFACE SECTION</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L799-L803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter, AbstractString, AbstractVector{I}, AbstractVector{F}}} where {I, F}" href="#FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter, AbstractString, AbstractVector{I}, AbstractVector{F}}} where {I, F}"><code>FinEtools.MeshExportModule.Abaqus.TEMPERATURE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},
  tlist::AbstractArray{F, 1}) where {I, F}</code></pre><p>Write out the <code>*TEMPERATURE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1008-L1013">source</a></section></article><h4 id="NASTRAN"><a class="docs-heading-anchor" href="#NASTRAN">NASTRAN</a><a id="NASTRAN-1"></a><a class="docs-heading-anchor-permalink" href="#NASTRAN" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{NASTRANExporter}" href="#Base.close-Tuple{NASTRANExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close(self::NASTRANExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1282-L1286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BEGIN_BULK(self::NASTRANExporter)</code></pre><p>Terminate the Case Control section by starting the bulk section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1177-L1181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.CEND</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CEND(self::NASTRANExporter)</code></pre><p>Terminate the Executive Control section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1168-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.CTETRA-Tuple{NASTRANExporter, Int64, Int64, Vector{Int64}}" href="#FinEtools.MeshExportModule.NASTRAN.CTETRA-Tuple{NASTRANExporter, Int64, Int64, Vector{Int64}}"><code>FinEtools.MeshExportModule.NASTRAN.CTETRA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTETRA(self::NASTRANExporter, eid::Int, pid::Int, conn::Vector{Int})</code></pre><p>Write a statement for a single tetrahedron element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1265-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.ENDDATA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ENDDATA(self::NASTRANExporter)</code></pre><p>Terminate the bulk section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1186-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter, Int64, Any}" href="#FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter, Int64, Any}"><code>FinEtools.MeshExportModule.NASTRAN.GRID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GRID(self::NASTRANExporter, n::Int, xyz)</code></pre><p>Write a grid-point statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1195-L1199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T, T, T}} where T" href="#FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T, T, T}} where T"><code>FinEtools.MeshExportModule.NASTRAN.MAT1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MAT1(
    self::NASTRANExporter,
    mid::Int,
    E::T,
    G::T,
    nu::T,
    rho::T,
    A::T,
    TREF::T,
    GE::T,
) where {T}</code></pre><p>Write a statement for an isotropic elastic material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1213-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, T, T}, Tuple{NASTRANExporter, Int64, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T, T}} where T" href="#FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, T, T}, Tuple{NASTRANExporter, Int64, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T}, Tuple{NASTRANExporter, Int64, T, T, T, T, T, T}} where T"><code>FinEtools.MeshExportModule.NASTRAN.MAT1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MAT1(
    self::NASTRANExporter,
    mid::Int,
    E::T,
    nu::T,
    rho::T = 0.0,
    A::T = 0.0,
    TREF::T = 0.0,
    GE::T = 0.0,
) where {T}</code></pre><p>Write a statement for an isotropic elastic material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1240-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter, Int64, Int64}" href="#FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter, Int64, Int64}"><code>FinEtools.MeshExportModule.NASTRAN.PSOLID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PSOLID(self::NASTRANExporter, pid::Int, mid::Int)</code></pre><p>Write solid-property statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1204-L1208">source</a></section></article><h4 id="STL"><a class="docs-heading-anchor" href="#STL">STL</a><a id="STL-1"></a><a class="docs-heading-anchor-permalink" href="#STL" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{STLExporter}" href="#Base.close-Tuple{STLExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close(self::STLExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1356-L1360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.STL.endsolid" href="#FinEtools.MeshExportModule.STL.endsolid"><code>FinEtools.MeshExportModule.STL.endsolid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">endsolid(self::STLExporter, name::AbstractString = &quot;thesolid&quot;)</code></pre><p>Write statement to end the solid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1347-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.STL.facet-Union{Tuple{T}, Tuple{STLExporter, Vector{T}, Vector{T}, Vector{T}}} where T" href="#FinEtools.MeshExportModule.STL.facet-Union{Tuple{T}, Tuple{STLExporter, Vector{T}, Vector{T}, Vector{T}}} where T"><code>FinEtools.MeshExportModule.STL.facet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">facet(self::STLExporter, v1::Vector{T}, v2::Vector{T}, v3::Vector{T}) where {T}</code></pre><p>Write a single facet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1328-L1332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.STL.solid" href="#FinEtools.MeshExportModule.STL.solid"><code>FinEtools.MeshExportModule.STL.solid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solid(self::STLExporter, name::AbstractString = &quot;thesolid&quot;)</code></pre><p>Write a statement to begin the solid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1319-L1323">source</a></section></article><h4 id="CSV"><a class="docs-heading-anchor" href="#CSV">CSV</a><a id="CSV-1"></a><a class="docs-heading-anchor-permalink" href="#CSV" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}" href="#FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}"><code>FinEtools.MeshExportModule.CSV.savecsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">savecsv(name::String; kwargs...)</code></pre><p>Save arrays as a CSV file.</p><p>Example:</p><pre><code class="language-julia hljs">savecsv(&quot;ab&quot;, a = rand(3), b = rand(3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1082-L1091">source</a></section></article><h4 id="H2Lib"><a class="docs-heading-anchor" href="#H2Lib">H2Lib</a><a id="H2Lib-1"></a><a class="docs-heading-anchor-permalink" href="#H2Lib" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.H2Lib.h2libexporttri-Tuple{String, Any, Any}" href="#FinEtools.MeshExportModule.H2Lib.h2libexporttri-Tuple{String, Any, Any}"><code>FinEtools.MeshExportModule.H2Lib.h2libexporttri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2libexporttri(theFile::String, Connectivity, Points)</code></pre><p>Write a file in the H2Lib format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1426-L1430">source</a></section></article><h4 id="VTKWrite"><a class="docs-heading-anchor" href="#VTKWrite">VTKWrite</a><a id="VTKWrite-1"></a><a class="docs-heading-anchor-permalink" href="#VTKWrite" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTKWrite.vtkwrite-Tuple{String, Any, Any, Any}" href="#FinEtools.MeshExportModule.VTKWrite.vtkwrite-Tuple{String, Any, Any, Any}"><code>FinEtools.MeshExportModule.VTKWrite.vtkwrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkwrite(theFile::String, Connectivity, Points, celltype; vectors=nothing, scalars=nothing)</code></pre><p>Export mesh to VTK as an unstructured grid (binary format).</p><p>Arguments:</p><ul><li><code>theFile</code> = file name,</li><li><code>Connectivity</code> = array of connectivities, one row per element,</li><li><code>Points</code> = array of node coordinates, one row per node,</li><li><code>Cell_type</code> = type of the cell, refer to the predefined    constants <code>WriteVTK.P1</code>, <code>WriteVTK.L2</code>, ..., <code>WriteVTK.H20</code>`, ...</li><li><code>scalars</code> = array of tuples, (name, data)</li><li><code>vectors</code> = array of tuples, (name, data)</li></ul><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p><p>Return the <code>vtk</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1694-L1713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTKWrite.vtkwrite-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshExportModule.VTKWrite.vtkwrite-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshExportModule.VTKWrite.vtkwrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkwrite(theFile::String, fens::FENodeSet, fes::T; opts...) where {T&lt;:AbstractFESet}</code></pre><p>Export mesh to VTK as an unstructured grid (binary file).</p><p>Arguments:</p><ul><li><code>theFile</code> = file name,</li><li><code>fens</code> = finite element node set,</li><li><code>fes</code> = finite element set,</li><li><code>opts</code> = keyword argument list, where <code>scalars</code> = array of tuples,    <code>(name, data)</code>, <code>vectors</code> = array of tuples, <code>(name, data)</code></li></ul><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1667-L1683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Tuple{String, Any, Any, Any, Any}" href="#FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Tuple{String, Any, Any, Any, Any}"><code>FinEtools.MeshExportModule.VTKWrite.vtkwritecollection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkwritecollection(theFile::String, Connectivity, Points, celltype, times; vectors=nothing, scalars=nothing)</code></pre><p>Write a collection of VTK files (<code>.pvd</code> file).</p><p><code>times</code>: array of times</p><p>All the other arguments are the same as for <code>vtkwrite</code>. If <code>scalars</code> or <code>vectors</code> are supplied, they correspond to the times in the <code>times</code> array.</p><p>See the <code>vtkwritecollection</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1793-L1804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Union{Tuple{T}, Tuple{String, FENodeSet, T, Any}} where T&lt;:AbstractFESet" href="#FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Union{Tuple{T}, Tuple{String, FENodeSet, T, Any}} where T&lt;:AbstractFESet"><code>FinEtools.MeshExportModule.VTKWrite.vtkwritecollection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vtkwritecollection(theFile::String, fens::FENodeSet, fes::T, times; opts...) where {T&lt;:AbstractFESet}</code></pre><p>Write a collection of VTK files (<code>.pvd</code> file).</p><p><code>times</code>: array of times</p><p>All the other arguments are the same as for <code>vtkwrite</code>. If <code>scalars</code> or <code>vectors</code> are supplied, they correspond to the times in the <code>times</code> array.</p><p>See the <code>vtkwritecollection</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1770-L1781">source</a></section></article><h4 id="H5MESH"><a class="docs-heading-anchor" href="#H5MESH">H5MESH</a><a id="H5MESH-1"></a><a class="docs-heading-anchor-permalink" href="#H5MESH" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.H5MESH.write_H5MESH-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshExportModule.H5MESH.write_H5MESH-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshExportModule.H5MESH.write_H5MESH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_H5MESH(meshfile::String, fens::FENodeSet, fes::T) where {T&lt;:AbstractFESet}</code></pre><p>Write the mesh in the H5MESH format.</p><p>The mesh is stored in a HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MeshExportModule.jl#L1580-L1586">source</a></section></article><h2 id="FEM-machines"><a class="docs-heading-anchor" href="#FEM-machines">FEM machines</a><a id="FEM-machines-1"></a><a class="docs-heading-anchor-permalink" href="#FEM-machines" title="Permalink"></a></h2><h3 id="Base"><a class="docs-heading-anchor" href="#Base">Base</a><a id="Base-1"></a><a class="docs-heading-anchor-permalink" href="#Base" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}}} where GFT" href="#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}}} where GFT"><code>FinEtools.FEMMBaseModule.associategeometry!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">associategeometry!(self::AbstractFEMM, geom::NodalField{GFT}) where {GFT}</code></pre><p>Associate geometry field with the FEMM.</p><p>There may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.</p><p>Geometry field is normally passed into any routine that evaluates some forms (integrals) over the mesh.  Whenever the geometry passed into a routine is not consistent with the one for which <code>associategeometry!()</code> was called before, <code>associategeometry!()</code> needs to be called with the new geometry field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L95-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.bilform_convection-Union{Tuple{DC}, Tuple{QT}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, NodalField{QT}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, QT, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.bilform_convection-Union{Tuple{DC}, Tuple{QT}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, NodalField{QT}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, QT, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.bilform_convection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilform_convection(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    u::NodalField{T},
    Q::NodalField{QT},
    rhof::DC
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, QT, DC&lt;:DataCache}</code></pre><p>Compute the sparse matrix implied by the bilinear form of the &quot;convection&quot; type.</p><p class="math-container">\[\int_{V}  {w} \rho \mathbf{u} \cdot \nabla q \; \mathrm{d} V\]</p><p>Here <span>$w$</span> is the scalar test function, <span>$\mathbf{u}$</span> is the convective velocity, <span>$q$</span> is the scalar trial function, <span>$\rho$</span> is the mass density; <span>$\rho$</span> is computed by <code>rhof</code>, which is a given function(data). Both test and trial functions are assumed to be from the same approximation space. <code>rhof</code> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>, and needs to return a  scalar mass density.</p><p>The integral is with respect to the volume of the domain <span>$V$</span> (i.e. a three dimensional integral).</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global matrix;</li><li><code>geom</code> = geometry field;</li><li><code>u</code> = convective velocity field;</li><li><code>Q</code> = nodal field to define the degree of freedom numbers;</li><li><code>rhof</code>= data cache, which is called to evaluate the coefficient <span>$\rho$</span>, given the location of the integration point, the Jacobian matrix, and the finite element label.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1462-L1497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.bilform_diffusion-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.bilform_diffusion-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.bilform_diffusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilform_diffusion(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    u::NodalField{T},
    cf::DC
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}</code></pre><p>Compute the sparse matrix implied by the bilinear form of the &quot;diffusion&quot; type.</p><p class="math-container">\[\int_{V}  \nabla w \cdot c \cdot \nabla u \; \mathrm{d} V\]</p><p>Here <span>$\nabla w$</span> is the gradient of the scalar test function, <span>$\nabla u$</span> is the gradient of the scalar trial function, <span>$c$</span> is a square symmetric matrix of coefficients or a scalar; <span>$c$</span> is computed by <code>cf</code>, which is a given function (data). Both test and trial functions are assumed to be from the same approximation space. <code>cf</code> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>, and needs to return a symmetric square matrix (to represent general anisotropic diffusion) or a scalar (to represent isotropic diffusion).</p><p>The coefficient matrix <span>$c$</span> can be given in the so-called local material coordinates: coordinates that are attached to a material point and are determined by a local cartesian coordinates system (<code>mcsys</code>).</p><p>The integral is with respect to the volume of the domain <span>$V$</span> (i.e. a three dimensional integral).</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global matrix;</li><li><code>geom</code> = geometry field;</li><li><code>u</code> = nodal field to define the degree of freedom numbers;</li><li><code>cf</code>= data cache, which is called to evaluate the coefficient <span>$c$</span>, given the location of the integration point, the Jacobian matrix, and the finite element label.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1346-L1384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.bilform_div_grad-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.bilform_div_grad-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.bilform_div_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilform_div_grad(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    u::NodalField{T},
    viscf::DC
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}</code></pre><p>Compute the sparse matrix implied by the bilinear form of the &quot;div grad&quot; type.</p><p class="math-container">\[\int_{V}  \mu \nabla \mathbf{w}:  \nabla\mathbf{u}   \; \mathrm{d} V\]</p><p>Here <span>$\mathbf{w}$</span> is the vector test function, <span>$\mathbf{u}$</span> is the velocity, <span>$\mu$</span> is the dynamic viscosity (or kinematic viscosity, depending on the formulation); <span>$\mu$</span> is computed by <code>viscf</code>, which is a given function (data). Both test and trial functions are assumed to be from the same approximation space. <code>viscf</code> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>, and needs to return a  scalar viscosity.</p><p>The integral is with respect to the volume of the domain <span>$V$</span> (i.e. a three dimensional integral).</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global matrix;</li><li><code>geom</code> = geometry field;</li><li><code>u</code> = velocity field;</li><li><code>viscf</code>= data cache, which is called to evaluate the coefficient <span>$\mu$</span>, given the location of the integration point, the Jacobian matrix, and the finite element label.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1549-L1582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.bilform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.bilform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.bilform_dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilform_dot(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    u::NodalField{T},
    cf::DC
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}</code></pre><p>Compute the sparse matrix implied by the bilinear form of the &quot;dot&quot; type.</p><p class="math-container">\[\int_{\Omega}  \mathbf{w} \cdot \mathbf{c} \cdot \mathbf{u} \; \mathrm{d} \Omega\]</p><p>Here <span>$\mathbf{w}$</span> is the test function, <span>$\mathbf{u}$</span> is the trial function, <span>$\mathbf{c}$</span> is a square matrix of coefficients; <span>$\mathbf {c}$</span> is computed by <code>cf</code>, which is a given function (data). Both trial and test functions are assumed to be vectors(even if of length 1). <code>cf</code> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>, and needs to return a square matrix, with dimension equal to the number of degrees of freedom per node in the <code>u</code> field.</p><p>The integral domain <span>$\Omega$</span> can be the volume of the domain <span>$V$</span> (i.e. a three dimensional integral), or a surface <span>$S$</span> (i.e. a two dimensional integral), or a line domain <span>$L$</span> (i.e. a one dimensional integral).</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global object;</li><li><code>geom</code> = geometry field;</li><li><code>u</code> = nodal field to define the degree of freedom numbers;</li><li><code>cf</code>= data cache, which is called to evaluate the coefficient <span>$c$</span>, given the location of the integration point, the Jacobian matrix, and the finite element label.</li><li><code>m</code> = manifold dimension (default is 3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1232-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.bilform_lin_elastic-Union{Tuple{DC}, Tuple{MR}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, Type{MR}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, MR&lt;:AbstractDeforModelRed, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.bilform_lin_elastic-Union{Tuple{DC}, Tuple{MR}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, Type{MR}, DC}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, MR&lt;:AbstractDeforModelRed, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.bilform_lin_elastic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bilform_lin_elastic(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    u::NodalField{T},
    cf::DC
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T, DC&lt;:DataCache}</code></pre><p>Compute the sparse matrix implied by the bilinear form of the &quot;linearized elasticity&quot; type.</p><p class="math-container">\[\int_{V} (B \mathbf{w})^T C  B \mathbf{u}   \; \mathrm{d} V\]</p><p>Here <span>$\mathbf{w}$</span> is the vector test function, <span>$\mathbf{u}$</span> is the displacement (velocity), <span>$C$</span> is the elasticity (viscosity) matrix; <span>$C$</span> is computed by <code>cf</code>, which is a given function(data). Both test and trial functions are assumed to be from the same approximation space. <code>cf</code> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>, and needs to return a matrix of the appropriate size.</p><p>The integral is with respect to the volume of the domain <span>$V$</span> (i.e. a three dimensional integral).</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global matrix;</li><li><code>geom</code> = geometry field;</li><li><code>u</code> = velocity field;</li><li><code>viscf</code>= data cache, which is called to evaluate the coefficient <span>$\mu$</span>, given the location of the integration point, the Jacobian matrix, and the finite element label.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1647-L1680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, Any}} where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, Any}} where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.connectionmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectionmatrix(self::FEMM, nnodes) where {FEMM&lt;:AbstractFEMM}</code></pre><p>Compute the connection matrix.</p><p>The matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L462-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.distribloads-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, ForceIntensity, Any}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T}" href="#FinEtools.FEMMBaseModule.distribloads-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, ForceIntensity, Any}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T}"><code>FinEtools.FEMMBaseModule.distribloads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distribloads(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    P::NodalField{T},
    fi::ForceIntensity,
    m,
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T}</code></pre><p>Compute distributed loads vector.</p><p><strong>Arguments</strong></p><ul><li><code>fi</code>=force intensity object</li><li><code>m</code>= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads <code>m</code> is set to 3, for tractions on the surface it is set to 2, and so on.</li></ul><p>The actual work is done by <code>linform_dot()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1194-L1213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.dualconnectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, FENodeSet}, Tuple{FEMM, FENodeSet, Any}} where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.dualconnectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, FENodeSet}, Tuple{FEMM, FENodeSet, Any}} where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.dualconnectionmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dualconnectionmatrix(
    self::FEMM,
    fens::FENodeSet,
    minnodes = 1,
) where {FEMM&lt;:AbstractFEMM}</code></pre><p>Compute the dual connection matrix.</p><p>The matrix has a nonzero in all the rows and columns which correspond to elements connected by some finite element nodes.</p><ul><li><code>minnodes</code>: minimum number of nodes that the elements needs to share in order to be neighbors (default 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L492-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FEMMBaseModule.elemfieldfromintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elemfieldfromintegpoints(
    self::FEMM,
    geom::NodalField{GFT},
    u::NodalField{UFT},
    dT::NodalField{TFT},
    quantity::Symbol,
    component::AbstractVector{IT};
    context...,
) where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}</code></pre><p>Construct elemental field from integration points.</p><p><strong>Arguments</strong></p><p><code>geom</code>     - reference geometry field <code>u</code>        - displacement field <code>dT</code>       - temperature difference field <code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument            of the material update!() method. <code>component</code>- component of the &#39;quantity&#39; array: see the material update()            method.</p><p><strong>Output</strong></p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L737-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.ev_integrate-Union{Tuple{R}, Tuple{DC}, Tuple{FT}, Tuple{FEMM}, Tuple{FEMM, NodalField{FT}, DC, R, Any}} where {FEMM&lt;:AbstractFEMM, FT&lt;:Number, DC&lt;:DataCache, R}" href="#FinEtools.FEMMBaseModule.ev_integrate-Union{Tuple{R}, Tuple{DC}, Tuple{FT}, Tuple{FEMM}, Tuple{FEMM, NodalField{FT}, DC, R, Any}} where {FEMM&lt;:AbstractFEMM, FT&lt;:Number, DC&lt;:DataCache, R}"><code>FinEtools.FEMMBaseModule.ev_integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ev_integrate(
        self::FEMM,
        geom::NodalField{FT},
        f::DC,
        initial::R,
        m,
) where {FEMM&lt;:AbstractFEMM, FT&lt;:Number, DC&lt;:DataCache, R}</code></pre><p>Compute the integral of a given function over a mesh domain.</p><p class="math-container">\[\int_{\Omega}  {f} \; \mathrm{d} \Omega\]</p><p>Here <span>${f}$</span> is a given function (data).  The data <span>${f}$</span> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>geom</code> = geometry field;</li><li><code>f</code>= data cache, which is called to evaluate the integrand based on the location, the Jacobian matrix, the finite element identifier, and the quadrature point;</li><li><code>initial</code> = initial value of the integral,</li><li><code>m</code>= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads <code>m</code> is set to 3, for tractions on the surface it is set to 2, and so on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1059-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.field_elem_to_nodal!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, EFL, NFL}} where {FT, T&lt;:Number, EFL&lt;:(ElementalField{T}), NFL&lt;:(NodalField{T})}" href="#FinEtools.FEMMBaseModule.field_elem_to_nodal!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, EFL, NFL}} where {FT, T&lt;:Number, EFL&lt;:(ElementalField{T}), NFL&lt;:(NodalField{T})}"><code>FinEtools.FEMMBaseModule.field_elem_to_nodal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_elem_to_nodal!(
    self::AbstractFEMM,
    geom::NodalField{FT},
    ef::EFL,
    nf::NFL;
    kind = :weighted_average,
) where {FT, T&lt;:Number, EFL&lt;:ElementalField{T}, NFL&lt;:NodalField{T}}</code></pre><p>Make a nodal field  from an elemental field over the discrete manifold.</p><p><code>ef</code> = ELEMENTAL field to supply the values <code>nf</code> = NODAL field to receive the values <code>kind</code> = default is <code>:weighted_average</code>; other options: <code>:max</code></p><p>Returns <code>nf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L841-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.field_nodal_to_elem!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, NFL, EFL}} where {FT&lt;:Number, T, EFL&lt;:(ElementalField{T}), NFL&lt;:(NodalField{T})}" href="#FinEtools.FEMMBaseModule.field_nodal_to_elem!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, NFL, EFL}} where {FT&lt;:Number, T, EFL&lt;:(ElementalField{T}), NFL&lt;:(NodalField{T})}"><code>FinEtools.FEMMBaseModule.field_nodal_to_elem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_nodal_to_elem!(
    self::AbstractFEMM,
    geom::NodalField{FT},
    nf::NFL,
    ef::EFL;
    kind = :weighted_average,
) where {FT&lt;:Number, T, EFL&lt;:ElementalField{T}, NFL&lt;:NodalField{T}}</code></pre><p>Make an elemental field  from a nodal field over the discrete manifold.</p><p><code>nf</code> = NODAL field to supply the values <code>ef</code> = ELEMENTAL field to receive the values <code>kind</code> = default is <code>:weighted_average</code>; other options: <code>:max</code></p><p>Returns <code>ef</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L925-L941">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}" href="#FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}"><code>FinEtools.FEMMBaseModule.fieldfromintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldfromintegpoints(
    self::FEMM,
    geom::NodalField{GFT},
    u::NodalField{UFT},
    dT::NodalField{TFT},
    quantity::Symbol,
    component::AbstractVector{IT};
    context...,
) where {FEMM&lt;:AbstractFEMM, GFT&lt;:Number, UFT&lt;:Number, TFT&lt;:Number, IT&lt;:Integer}</code></pre><p>Construct nodal field from integration points.</p><p><strong>Arguments</strong></p><ul><li><code>geom</code>     - reference geometry field</li><li><code>u</code>        - displacement field</li><li><code>dT</code>       - temperature difference field</li><li><code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument          of the material update!() method.</li><li><code>component</code>- component of the &#39;quantity&#39; array: see the material update()          method.</li></ul><p>Keyword arguments</p><ul><li><code>nodevalmethod</code> = <code>:invdistance</code> (the default) or <code>:averaging</code>;</li><li><code>reportat</code> = at which point should the  element quantities be reported?   This argument is interpreted inside the <code>inspectintegpoints()</code> method.</li></ul><p><strong>Output</strong></p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L592-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.finite_elements-Tuple{FEMM} where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.finite_elements-Tuple{FEMM} where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.finite_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_elements(self::FEMM) where {FEMM &lt;: AbstractFEMM}</code></pre><p>Retrieve the finite element set for this FEMM to work on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T}" href="#FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T}"><code>FinEtools.FEMMBaseModule.innerproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">innerproduct(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    afield::NodalField{T},
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysmatAssembler, FT, T}</code></pre><p>Compute the inner-product (Gram) matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1307-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{IT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, AbstractVector{IT}, F, Any}, Tuple{FEMM, NodalField{GFT}, AbstractVector{IT}, F, Any, Any}} where {FEMM&lt;:AbstractFEMM, GFT, IT, F&lt;:Function}" href="#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{IT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, AbstractVector{IT}, F, Any}, Tuple{FEMM, NodalField{GFT}, AbstractVector{IT}, F, Any, Any}} where {FEMM&lt;:AbstractFEMM, GFT, IT, F&lt;:Function}"><code>FinEtools.FEMMBaseModule.inspectintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inspectintegpoints(
    self::FEMM,
    geom::NodalField{GFT},
    felist::AbstractVector{IT},
    inspector::F,
    idat,
    quantity = :Cauchy;
    context...,
) where {FEMM&lt;:AbstractFEMM, GFT, IT, F&lt;:Function}</code></pre><p>Inspect integration points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL&lt;:(ElementalField{T}), F&lt;:Function, R}" href="#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL&lt;:(ElementalField{T}), F&lt;:Function, R}"><code>FinEtools.FEMMBaseModule.integratefieldfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integratefieldfunction(
    self::AbstractFEMM,
    geom::NodalField{GFT},
    afield::FL,
    fh::F;
    initial::R = zero(FT),
    m = -1,
) where {GFT, T, FL&lt;:ElementalField{T}, F&lt;:Function,R}</code></pre><p>Integrate a elemental-field function over the discrete manifold.</p><ul><li><code>afield</code> = ELEMENTAL field to supply the values</li><li><code>fh</code> = function taking position and an array of field values for the element as arguments, returning value of type <code>T</code>. The array of field values has one row and as many columns as there are degrees of freedom per element.</li><li><code>m</code> = dimension of the manifold over which to integrate; <code>m &lt; 0</code> means that the dimension is controlled by the manifold dimension of the elements.</li></ul><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L185-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL&lt;:(NodalField{T}), F&lt;:Function, R}" href="#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL&lt;:(NodalField{T}), F&lt;:Function, R}"><code>FinEtools.FEMMBaseModule.integratefieldfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integratefieldfunction(
    self::AbstractFEMM,
    geom::NodalField{GFT},
    afield::FL,
    fh::F;
    initial::R,
    m = -1,
) where {GFT, T, FL&lt;:NodalField{T}, F&lt;:Function,R}</code></pre><p>Integrate a nodal-field function over the discrete manifold.</p><ul><li><code>afield</code> = NODAL field to supply the values</li><li><code>fh</code> = function taking position and an array of field values for the element as arguments, returning value of type <code>T</code>. The rectangular array of field values has as many rows as there are nodes per element, and as many columns as there are degrees of freedom per node.</li><li><code>m</code> = dimension of the manifold over which to integrate; <code>m &lt; 0</code> means that the dimension is controlled by the manifold dimension of the elements.</li></ul><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L137-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{R}, Tuple{F}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, F}} where {GFT&lt;:Number, F&lt;:Function, R&lt;:Number}" href="#FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{R}, Tuple{F}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, F}} where {GFT&lt;:Number, F&lt;:Function, R&lt;:Number}"><code>FinEtools.FEMMBaseModule.integratefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integratefunction(
    self::AbstractFEMM,
    geom::NodalField{GFT},
    fh::F;
    initial::R = zero(typeof(fh(zeros(ndofs(geom), 1)))),
    m = -1,
) where {GFT&lt;:Number, F&lt;:Function, R&lt;:Number}</code></pre><p>Integrate a function over the discrete manifold.</p><p>Integrate some scalar function over the geometric cells. The function takes a single argument, the position vector.</p><p>When the scalar function returns just +1 (such as <code>(x) -&gt;  1.0</code>), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.</p><p><strong>Example:</strong></p><p>Compute the volume of the mesh and then its center of gravity:</p><pre><code class="nohighlight hljs">V = integratefunction(femm, geom, (x) -&gt;  1.0, 0.0)
Sx = integratefunction(femm, geom, (x) -&gt;  x[1], 0.0)
Sy = integratefunction(femm, geom, (x) -&gt;  x[2], 0.0)
Sz = integratefunction(femm, geom, (x) -&gt;  x[3], 0.0)
CG = vec([Sx Sy Sz]/V)</code></pre><p>Compute a moment of inertia of the mesh relative to the origin:</p><pre><code class="nohighlight hljs">Ixx = integratefunction(femm, geom, (x) -&gt;  x[2]^2 + x[3]^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L230-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.linform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC, Any}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T, DC&lt;:DataCache}" href="#FinEtools.FEMMBaseModule.linform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC, Any}} where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T, DC&lt;:DataCache}"><code>FinEtools.FEMMBaseModule.linform_dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linform_dot(
    self::FEMM,
    assembler::A,
    geom::NodalField{FT},
    P::NodalField{T},
    f::DC,
    m,
) where {FEMM&lt;:AbstractFEMM, A&lt;:AbstractSysvecAssembler, FT&lt;:Number, T, DC&lt;:DataCache}</code></pre><p>Compute the discrete vector implied by the linear form &quot;dot&quot;.</p><p class="math-container">\[\int_{V}  \mathbf{w} \cdot \mathbf{f} \; \mathrm{d} V\]</p><p>Here <span>$\mathbf{w}$</span> is the test function, <span>$\mathbf{f}$</span> is a given function (data). Both are assumed to be vectors,  even if they are of length 1, representing scalars. The data <span>$\mathbf{f}$</span> is represented with <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = finite element machine;</li><li><code>assembler</code> = assembler of the global vector;</li><li><code>geom</code> = geometry field;</li><li><code>P</code> = nodal field to define the degree of freedom numbers;</li><li><code>f</code>= data cache, which is called to evaluate the integrand based on the location, the Jacobian matrix, the finite element identifier, and the quadrature point;</li><li><code>m</code>= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads <code>m</code> is set to 3, for tractions on the surface it is set to 2, and so on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L1109-L1141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT&lt;:Number, T, F&lt;:(ElementalField{T})}" href="#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT&lt;:Number, T, F&lt;:(ElementalField{T})}"><code>FinEtools.FEMMBaseModule.transferfield!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transferfield!(
    ff::F,
    fensf::FENodeSet{FT},
    fesf::AbstractFESet,
    fc::F,
    fensc::FENodeSet{FT},
    fesc::AbstractFESet,
    geometricaltolerance::FT;
    parametrictolerance::FT = 0.01,
) where {FT&lt;:Number, F&lt;:ElementalField{T}, T}</code></pre><p>Transfer an elemental field from a coarse mesh to a finer one.</p><p><strong>Arguments</strong></p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>tolerance</code> = tolerance in physical space for searches of the adjacent nodes</li></ul><p><strong>Output</strong></p><p>Elemental field <code>ff</code> transferred to the fine mesh is output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L391-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT&lt;:Number, T, F&lt;:(NodalField{T})}" href="#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT&lt;:Number, T, F&lt;:(NodalField{T})}"><code>FinEtools.FEMMBaseModule.transferfield!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transferfield!(
    ff::F,
    fensf::FENodeSet{FT},
    fesf::AbstractFESet,
    fc::F,
    fensc::FENodeSet{FT},
    fesc::AbstractFESet,
    geometricaltolerance::FT;
    parametrictolerance::FT = 0.01,
) where {FT&lt;:Number, F&lt;:NodalField{T}, T}</code></pre><p>Transfer a nodal field from a coarse mesh to a finer one.</p><p><strong>Arguments</strong></p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>geometricaltolerance</code> = tolerance in physical space for searches of the adjacent nodes</li><li><code>parametrictolerance</code> = tolerance in parametric space for for check whether node is inside an element</li></ul><p><strong>Output</strong></p><p>Nodal field <code>ff</code> transferred to the fine mesh is output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/FEMMBaseModule.jl#L283-L310">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><h3 id="Base-2"><a class="docs-heading-anchor" href="#Base-2">Base</a><a class="docs-heading-anchor-permalink" href="#Base-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.bisect-NTuple{5, Any}" href="#FinEtools.AlgoBaseModule.bisect-NTuple{5, Any}"><code>FinEtools.AlgoBaseModule.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect(fun, xl, xu, tolx, tolf)</code></pre><p>Implementation of the bisection method.</p><p>Tolerance both on <code>x</code> and on <code>f(x)</code> is used.</p><ul><li><code>fun</code> = function,</li><li><code>xl</code>= lower value of the bracket,</li><li><code>xu</code>= upper Value of the bracket,</li><li><code>tolx</code>= tolerance on the location of the root,</li><li><code>tolf</code>= tolerance on the function value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L214-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.bisect-NTuple{7, Any}" href="#FinEtools.AlgoBaseModule.bisect-NTuple{7, Any}"><code>FinEtools.AlgoBaseModule.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect(fun, xl, xu, fl, fu, tolx, tolf)</code></pre><p>Implementation of the bisection method.</p><p>Tolerance both on <code>x</code> and on <code>f(x)</code> is used.</p><ul><li><code>fun</code> = function,</li><li><code>xl</code>,<code>xu</code>= lower and upper value of the bracket,</li><li><code>fl</code>,<code>fu</code>= function value at the lower and upper limit of the bracket.</li></ul><p>The true values must have opposite signs (that is they must constitute a bracket). Otherwise  this algorithm will fail.</p><ul><li><code>tolx</code>= tolerance on the location of the root,</li><li><code>tolf</code>= tolerance on the function value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{MT}, Tuple{MT, Vector{T}, Vector{T}, Any}} where {MT, T&lt;:Number}" href="#FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{MT}, Tuple{MT, Vector{T}, Vector{T}, Any}} where {MT, T&lt;:Number}"><code>FinEtools.AlgoBaseModule.conjugategradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conjugategradient(A::MT, b::Vector{T}, x0::Vector{T}, maxiter) where {MT, T&lt;:Number}</code></pre><p>Compute one or more iterations of the conjugate gradient process.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}" href="#FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}"><code>FinEtools.AlgoBaseModule.evalconvergencestudy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evalconvergencestudy(modeldatasequence)</code></pre><p>Evaluate a convergence study from a model-data sequence.  </p><ul><li><code>modeldatasequence</code> = array of <code>modeldata</code> dictionaries. At least two must be included.</li></ul><p>Refer to methods <code>fieldnorm</code> and <code>fielddiffnorm</code> for details  on the required keys in the dictionaries.</p><p><strong>Output</strong></p><ul><li><code>elementsizes</code> = element size array, </li><li><code>errornorms</code> = norms of the error, </li><li><code>convergencerate</code> = rate of convergence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L365-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any, Any}" href="#FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any, Any}"><code>FinEtools.AlgoBaseModule.fielddiffnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fielddiffnorm(modeldatacoarse, modeldatafine)</code></pre><p>Compute norm of the difference of the fields.  </p><p><strong>Arguments</strong></p><ul><li><code>modeldatacoarse</code>, <code>modeldatafine</code> = data dictionaries.</li></ul><p>For both the &quot;coarse&quot;- and &quot;fine&quot;-mesh <code>modeldata</code> the data dictionaries need to contain the mandatory keys:</p><ul><li><code>&quot;fens&quot;</code> = finite element node set</li><li><code>&quot;regions&quot;</code> = array of regions</li><li><code>&quot;targetfields&quot;</code> = array of fields, one for each region</li><li><code>&quot;geom&quot;</code> = geometry field</li><li><code>&quot;elementsize&quot;</code> = representative element size,</li><li><code>&quot;geometricaltolerance&quot;</code> = geometrical tolerance (used in field transfer; refer to the documentation of <code>transferfield!</code>)</li><li><code>&quot;parametrictolerance&quot;</code> = parametric tolerance (used in field transfer; refer to the documentation of <code>transferfield!</code>)</li></ul><p><strong>Output</strong></p><ul><li>Norm of the field as floating-point scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L294-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}" href="#FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}"><code>FinEtools.AlgoBaseModule.fieldnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldnorm(modeldata)</code></pre><p>Compute norm of the target field.  </p><p><strong>Argument</strong></p><ul><li><code>modeldata</code> = data dictionary, mandatory keys:<ul><li><code>fens</code> = finite element node set</li><li><code>regions</code> = array of regions</li><li><code>targetfields</code> = array of fields, one for each region</li><li><code>geom</code> = geometry field</li><li><code>elementsize</code> = representative element size,</li></ul></li></ul><p><strong>Output</strong></p><ul><li>Norm of the field as floating-point scalar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L257-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.matrix_blocked" href="#FinEtools.AlgoBaseModule.matrix_blocked"><code>FinEtools.AlgoBaseModule.matrix_blocked</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_blocked(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)</code></pre><p>Partition matrix into blocks.</p><p>The function returns the sparse matrix as a named tuple of its constituent blocks. The matrix is assumed to be composed of four blocks</p><pre><code class="nohighlight hljs">A = [A_ff A_fd
     A_df A_dd]</code></pre><p>The named tuple is the value <code>(ff = A_ff, fd = A_fd, df = A_df, dd = A_dd)</code>. Index into this named tuple to retrieve the parts of the matrix that you want.</p><p>Here <code>f</code> stands for free, and <code>d</code> stands for data (i.e. fixed, prescribed, ...). The size of the <code>ff</code> block is <code>row_nfreedofs, col_nfreedofs</code>. Neither one of the blocks is square, unless <code>row_nfreedofs == col_nfreedofs</code>.</p><p>When <code>row_nfreedofs == col_nfreedofs</code>, only the number of rows needs to be given.</p><p><strong>Example</strong></p><p>Both</p><pre><code class="nohighlight hljs">K_ff, K_fd = matrix_blocked(K, nfreedofs, nfreedofs)[(:ff, :fd)]
K_ff, K_fd = matrix_blocked(K, nfreedofs)[(:ff, :fd)]</code></pre><p>define a square <code>K_ff</code> matrix and, in general a rectangular, matrix <code>K_fd</code>.</p><p>This retrieves all four partitions of the matrix</p><pre><code class="nohighlight hljs">A_ff, A_fd, A_df, A_dd = matrix_blocked(A, nfreedofs)[(:ff, :fd, :df, :dd)]</code></pre><p>This retrieves the complete named tuple, and then the matrices can be referenced with a dot syntax.</p><pre><code class="nohighlight hljs">A_b = matrix_blocked(A, nfreedofs, nfreedofs)
@test size(A_b.ff) == (nfreedofs, nfreedofs)
@test size(A_b.fd) == (nfreedofs, size(A, 1) - nfreedofs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L517-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5, Any}" href="#FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5, Any}"><code>FinEtools.AlgoBaseModule.penaltyebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">penaltyebc!(K, F, dofnums, prescribedvalues, penfact)</code></pre><p>Apply penalty essential boundary conditions.</p><p><strong>Arguments</strong></p><ul><li><code>K</code> = stiffness matrix</li><li><code>F</code> = global load vector </li><li><code>dofnums</code>, <code>prescribedvalues</code> = arrays computed by <code>prescribeddofs()</code></li><li><code>penfact</code> = penalty multiplier, in relative terms: how many times the maximum absolute value of the diagonal elements should the penalty term be?</li></ul><p><strong>Output</strong></p><ul><li>Updated matrix <code>K</code> and vector <code>F</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L487-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qcovariance-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}} where T&lt;:Number" href="#FinEtools.AlgoBaseModule.qcovariance-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}} where T&lt;:Number"><code>FinEtools.AlgoBaseModule.qcovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qcovariance(ps::VecOrMat{T}, xs::VecOrMat{T}, ys::VecOrMat{T}; ws = nothing) where {T&lt;:Number}</code></pre><p>Compute the covariance for two &#39;functions&#39; given by the arrays <code>xs</code> and <code>ys</code>  at the values of the parameter <code>ps</code>. <code>ws</code> is the optional weights vector;   if it is not supplied, uniformly distributed default weights are assumed.  </p><p>Notes: </p><p>– The mean is subtracted from both functions.  – This function is not particularly efficient: it computes the mean of both   functions and it allocates arrays instead of overwriting the contents of the   arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L447-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qtrap-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}} where T&lt;:Number" href="#FinEtools.AlgoBaseModule.qtrap-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}} where T&lt;:Number"><code>FinEtools.AlgoBaseModule.qtrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qtrap(ps::VecOrMat{T}, xs::VecOrMat{T}) where {T&lt;:Number}</code></pre><p>Compute the area under the curve given by a set of parameters along  an interval and the values of the &#39;function&#39; at those parameter values.   The parameter values need not be uniformly distributed.</p><p>Trapezoidal rule is used to evaluate the integral. The &#39;function&#39; is  assumed to vary linearly inbetween the given points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L428-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qvariance-Tuple{Any, Any}" href="#FinEtools.AlgoBaseModule.qvariance-Tuple{Any, Any}"><code>FinEtools.AlgoBaseModule.qvariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qvariance(ps, xs; ws = nothing)</code></pre><p>Compute the variance of a function given by the array <code>xs</code> at  the values of the parameter <code>ps</code>. <code>ws</code> is the optional weights vector   with unit default weights.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L478-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractArray)" href="#FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractArray)"><code>FinEtools.AlgoBaseModule.richextrapol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">richextrapol(solns::T, params::T; lower_conv_rate = 0.001, upper_conv_rate = 10.0) where {T&lt;:AbstractArray{Tn} where {Tn}}</code></pre><p>Richardson extrapolation.</p><p><strong>Arguments</strong></p><ul><li><code>solns</code> =  array of three solution values</li><li><code>params</code> = array of values of three parameters for which the <code>solns</code> have been obtained. </li></ul><p>The assumption is that the error of the solution is expanded in a Taylor series, and only the first term in the Taylor series is kept.     <code>qex - qapprox ~ C param^beta</code> Here <code>qex</code> is the true solution, <code>qapprox</code> is an approximate solution, <code>param</code> is the element size, or the relative element size, in other words the parameter of the extrapolation, and <code>beta</code> is the convergence rate. The constant <code>C</code> is  the third unknown quantity in this expansion. If we obtain three successive  approximations, we can solve for the three unknown quantities, <code>qex</code>, <code>beta</code>,  and <code>C</code>.</p><p>It is assumed that the first solution is obtained for the largest value of the extrapolation parameter, while the last solution in the list is obtained for the smallest value of the extrapolation parameter:      <code>params[1] &gt; params[2] &gt; params[3]</code></p><p><strong>Output</strong></p><ul><li><code>solnestim</code>= estimate of the asymptotic solution from the data points in the <code>solns</code> array</li><li><code>beta</code>= convergence rate</li><li><code>c</code> = constant in the estimate <code>error=c*h^beta</code></li><li><code>maxresidual</code> = maximum residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L42-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractArray)" href="#FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractArray)"><code>FinEtools.AlgoBaseModule.richextrapoluniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">richextrapoluniform(solns::T, params::T) where {T&lt;:AbstractArray{Tn} where {Tn}}</code></pre><p>Richardson extrapolation.</p><p><strong>Argument</strong></p><ul><li><code>solns</code> =  array of solution values</li><li><code>params</code> = array of values of parameters for which the <code>solns</code> have been obtained. This function is applicable only to fixed (uniform) ratio between the mesh sizes, <code>params[1]/params[2) = params[2)/params[3)</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>solnestim</code>= estimate of the asymptotic solution from the data points in the <code>solns</code> array</li><li><code>beta</code>= convergence rate</li><li><code>c</code> = constant in the estimate <code>error=c*h^beta</code></li><li><code>residual</code> = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L130-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.solve_blocked!-Union{Tuple{V}, Tuple{M}, Tuple{AF}, Tuple{AF, M, V}} where {AF&lt;:AbstractField, M&lt;:(AbstractMatrix), V&lt;:(AbstractVector)}" href="#FinEtools.AlgoBaseModule.solve_blocked!-Union{Tuple{V}, Tuple{M}, Tuple{AF}, Tuple{AF, M, V}} where {AF&lt;:AbstractField, M&lt;:(AbstractMatrix), V&lt;:(AbstractVector)}"><code>FinEtools.AlgoBaseModule.solve_blocked!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_blocked!(u::AF, K::M, F::V) where {AF&lt;:AbstractField, M&lt;:AbstractMatrix, V&lt;:AbstractVector}</code></pre><p>Solve a system of linear algebraic equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L641-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.solve_blocked-Union{Tuple{IT}, Tuple{VX}, Tuple{VB}, Tuple{M}, Tuple{M, VB, VX, IT}} where {M&lt;:(AbstractMatrix), VB&lt;:(AbstractVector), VX&lt;:(AbstractVector), IT&lt;:Integer}" href="#FinEtools.AlgoBaseModule.solve_blocked-Union{Tuple{IT}, Tuple{VX}, Tuple{VB}, Tuple{M}, Tuple{M, VB, VX, IT}} where {M&lt;:(AbstractMatrix), VB&lt;:(AbstractVector), VX&lt;:(AbstractVector), IT&lt;:Integer}"><code>FinEtools.AlgoBaseModule.solve_blocked</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_blocked(A::M, b::VB, x::VX, nfreedofs::IT) where {M&lt;:AbstractMatrix, VB&lt;:AbstractVector, VX&lt;:AbstractVector, IT&lt;:Integer}</code></pre><p>Solve a blocked system of linear algebraic equations.</p><p>b<em>f and x</em>d are known, x<em>f and b</em>d need to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L622-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.vector_blocked-Tuple{Any, Any}" href="#FinEtools.AlgoBaseModule.vector_blocked-Tuple{Any, Any}"><code>FinEtools.AlgoBaseModule.vector_blocked</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_blocked(V, row_nfreedofs, which = (:all, ))</code></pre><p>Partition vector into two pieces.</p><p>The vector is composed of two blocks</p><pre><code class="nohighlight hljs">V = [V_f
     V_d]</code></pre><p>which are returned as a named tuple <code>(f = V_f, d = V_d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/AlgoBaseModule.jl#L592-L603">source</a></section></article><h2 id="Material-models"><a class="docs-heading-anchor" href="#Material-models">Material models</a><a id="Material-models-1"></a><a class="docs-heading-anchor-permalink" href="#Material-models" title="Permalink"></a></h2><h3 id="Material-model-abstractions"><a class="docs-heading-anchor" href="#Material-model-abstractions">Material model abstractions</a><a id="Material-model-abstractions-1"></a><a class="docs-heading-anchor-permalink" href="#Material-model-abstractions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatModule.massdensity-Tuple{AbstractMat}" href="#FinEtools.MatModule.massdensity-Tuple{AbstractMat}"><code>FinEtools.MatModule.massdensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">massdensity(self::AbstractMat)</code></pre><p>Return mass density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/fbd86d17fc27bf1f944820723c8e230df0c7345a/src/MatModule.jl#L17-L21">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 15 December 2023 15:22">Friday 15 December 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
