<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · FinEtools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtools.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../howto/howto.html">How to</a></li><li><a class="tocitem" href="../tutorials/tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li><li><a class="tocitem" href="man.html">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="types.html">Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="types.html">Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/man/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="types.html#Types">Types</a></li><ul><li><a href="types.html#Contents">Contents</a></li><li><a href="types.html#Coordinate-systems">Coordinate systems</a></li><li><a href="types.html#Finite-element-sets">Finite element sets</a></li><li><a href="types.html#Finite-element-nodes">Finite element nodes</a></li><li><a href="types.html#Finite-element-node-to-element-map">Finite element node-to-element map</a></li><li><a href="types.html#Fields">Fields</a></li><li><a href="types.html#Integration-rule">Integration rule</a></li><li><a href="types.html#Integration-domain">Integration domain</a></li><li><a href="types.html#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a></li><li><a href="types.html#Mesh-import/export">Mesh import/export</a></li><li><a href="types.html#Vector-cache-utilities">Vector-cache utilities</a></li><li><a href="types.html#Surface-normal-utilities">Surface-normal utilities</a></li><li><a href="types.html#Force-intensity">Force intensity</a></li><li><a href="types.html#FEM-machines">FEM machines</a></li><ul><li><a href="types.html#Base">Base</a></li></ul><li><a href="types.html#Material-models">Material models</a></li><ul><li><a href="types.html#Material-model-abstractions">Material model abstractions</a></li></ul></ul></ul><h2 id="Coordinate-systems"><a class="docs-heading-anchor" href="#Coordinate-systems">Coordinate systems</a><a id="Coordinate-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys" href="#FinEtools.CSysModule.CSys"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSys{F&lt;:Function}</code></pre><p>Type for coordinate system transformations. Used to define material coordinate systems, and output coordinate systems, for instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/CSysModule.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64, Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64, Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(sdim::FInt, mdim::FInt)</code></pre><p>Construct coordinate system for isotropic-material used with isoparametric finite elements.</p><ul><li><code>sdim</code> = number of space dimensions,</li><li><code>mdim</code> = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If  the coordinate system matrix  should be identity, better use the constructor for this specific situation, <code>CSys(dim::FInt)</code>. That will be much more efficient.</p></div></div><p><strong>See also</strong></p><p><code>gen_iso_csmat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/CSysModule.jl#L77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(dim::FInt)</code></pre><p>Construct coordinate system when the rotation matrix is the identity.</p><p><code>dim</code> = is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/CSysModule.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Matrix{Float64}}" href="#FinEtools.CSysModule.CSys-Tuple{Matrix{Float64}}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(csmat::FFltMat)</code></pre><p>Construct coordinate system when the rotation matrix is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/CSysModule.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64, Int64, F}} where F&lt;:Function" href="#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64, Int64, F}} where F&lt;:Function"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(sdim::FInt, mdim::FInt, computecsmat::F) where {F&lt;:Function}</code></pre><p>Construct coordinate system when the function to compute the rotation matrix is given.</p><p>The function signature: <code>update!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code> where</p><ul><li><code>csmatout</code>= output matrix buffer, of size <code>(sdim, mdim)</code></li><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>fe_label</code>= finite element label.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/CSysModule.jl#L29-L43">source</a></section></article><h2 id="Finite-element-sets"><a class="docs-heading-anchor" href="#Finite-element-sets">Finite element sets</a><a id="Finite-element-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet" href="#FinEtools.FESetModule.AbstractFESet"><code>FinEtools.FESetModule.AbstractFESet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set. Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet0Manifold" href="#FinEtools.FESetModule.AbstractFESet0Manifold"><code>FinEtools.FESetModule.AbstractFESet0Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet0Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet1Manifold" href="#FinEtools.FESetModule.AbstractFESet1Manifold"><code>FinEtools.FESetModule.AbstractFESet1Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet1Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet2Manifold" href="#FinEtools.FESetModule.AbstractFESet2Manifold"><code>FinEtools.FESetModule.AbstractFESet2Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet2Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet3Manifold" href="#FinEtools.FESetModule.AbstractFESet3Manifold"><code>FinEtools.FESetModule.AbstractFESet3Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet3Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH20" href="#FinEtools.FESetModule.FESetH20"><code>FinEtools.FESetModule.FESetH20</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH20</code></pre><p>Type for sets of volume-like hexahedral finite elements with 20 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L984-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH27" href="#FinEtools.FESetModule.FESetH27"><code>FinEtools.FESetModule.FESetH27</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH27</code></pre><p>Type for sets of volume-like hexahedral finite elements with 27 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L1171-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH8" href="#FinEtools.FESetModule.FESetH8"><code>FinEtools.FESetModule.FESetH8</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH8</code></pre><p>Type for sets of volume-like hexahedral finite elements with eight nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L909-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetL2" href="#FinEtools.FESetModule.FESetL2"><code>FinEtools.FESetModule.FESetL2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetL2</code></pre><p>Type for sets of curve-like finite elements with two nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L551-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetL3" href="#FinEtools.FESetModule.FESetL3"><code>FinEtools.FESetModule.FESetL3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetL3</code></pre><p>Type for sets of curve-like of finite elements with three nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L583-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetP1" href="#FinEtools.FESetModule.FESetP1"><code>FinEtools.FESetModule.FESetP1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetP1</code></pre><p>Type for sets of point-like of finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L514-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ4" href="#FinEtools.FESetModule.FESetQ4"><code>FinEtools.FESetModule.FESetQ4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ4</code></pre><p>Type for sets of surface-like quadrilateral finite elements with four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L667-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ8" href="#FinEtools.FESetModule.FESetQ8"><code>FinEtools.FESetModule.FESetQ8</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ8</code></pre><p>Type for sets of surface-like quadrilateral finite elements with eight nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L772-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ9" href="#FinEtools.FESetModule.FESetQ9"><code>FinEtools.FESetModule.FESetQ9</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ9</code></pre><p>Type for sets of surface-like quadrilateral finite elements with nine nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L718-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT10" href="#FinEtools.FESetModule.FESetT10"><code>FinEtools.FESetModule.FESetT10</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT10</code></pre><p>Type for sets of volume-like tetrahedral finite elements with 10 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L1349-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT3" href="#FinEtools.FESetModule.FESetT3"><code>FinEtools.FESetModule.FESetT3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT3</code></pre><p>Type for sets of surface-like triangular finite elements with three nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L623-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT4" href="#FinEtools.FESetModule.FESetT4"><code>FinEtools.FESetModule.FESetT4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT4</code></pre><p>Type for sets of volume-like tetrahedral finite elements with four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L1298-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT6" href="#FinEtools.FESetModule.FESetT6"><code>FinEtools.FESetModule.FESetT6</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT6</code></pre><p>Type for sets of surface-like triangular finite elements with six nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FESetModule.jl#L847-L851">source</a></section></article><h2 id="Finite-element-nodes"><a class="docs-heading-anchor" href="#Finite-element-nodes">Finite element nodes</a><a id="Finite-element-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.FENodeSet" href="#FinEtools.FENodeSetModule.FENodeSet"><code>FinEtools.FENodeSetModule.FENodeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite element node set type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FENodeSetModule.jl#L14-L16">source</a></section></article><h2 id="Finite-element-node-to-element-map"><a class="docs-heading-anchor" href="#Finite-element-node-to-element-map">Finite element node-to-element map</a><a id="Finite-element-node-to-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-node-to-element-map" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><p>For each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array <code>map</code>.</p><pre><code class="nohighlight hljs">    Example:</code></pre><pre><code class="nohighlight hljs">fes.conn= [7,6,5;
            4,1,3;
            3,7,5];
The map reads
    map[1] = [2];
    map[2] = [];#  note that node number 2 is not referenced by the connectivity
    map[3] = [2,3];
    map[4] = [2];
    map[5] = [1,3];
    map[6] = [1];
    map[7] = [1,3];</code></pre><p>The individual elements from the connectivity that reference node number 5 are 1 and 3, so that <code>fes.conn(map[5],:)</code>includes all the nodes that are connected to node 5 (including node 5 itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FENodeToFEMapModule.jl#L13-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Matrix{Int64}, Int64}" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Matrix{Int64}, Int64}"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap(conns::FIntMat, nmax::FInt)</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = integer array of the connectivities</li><li><code>nmax</code> = largest possible node number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FENodeToFEMapModule.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT, N}}, 1}, Int64}} where {N, IT&lt;:Integer}" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT, N}}, 1}, Int64}} where {N, IT&lt;:Integer}"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT&lt;:Integer}</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = connectivities as a vector of tuples</li><li><code>nmax</code> = largest possible node number</li></ul><p>Example:</p><pre><code class="nohighlight hljs">m = FENodeToFEMap(fes.conn, count(fens))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FENodeToFEMapModule.jl#L48-L60">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.AbstractField" href="#FinEtools.FieldModule.AbstractField"><code>FinEtools.FieldModule.AbstractField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractField</code></pre><p>Abstract field.</p><p>Expected  attributes:</p><ul><li><code>values::FMat{T}</code>: Array of degree of freedom parameters,  indexed by entity number</li><li><code>dofnums::FIntMat</code>: Array of degree of freedom numbers, indexed by entity number</li><li><code>is_fixed::Matrix{Bool}</code>: Array of Boolean flags, indexed by entity number</li><li><code>fixed_values::FMat{T}</code>: Array of fixed values, indexed by entity number</li><li><code>nfreedofs::FInt</code>: Total number of free degrees of freedom</li></ul><p>See also: <a href="man/@ref"><code>@add_Field_fields()</code></a> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FieldModule.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField" href="#FinEtools.GeneralFieldModule.GeneralField"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralField{T&lt;:Number} &lt;: AbstractField</code></pre><p>General field, meaning the entities can be anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/GeneralFieldModule.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of general field.  The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many rows as there are entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/GeneralFieldModule.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of general field.  The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/GeneralFieldModule.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField" href="#FinEtools.NodalFieldModule.NodalField"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalField{T&lt;:Number} &lt;: AbstractField</code></pre><p>Nodal field, meaning the entities are the finite element nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/NodalFieldModule.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NodalField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of nodal field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/NodalFieldModule.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NodalField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of nodal field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/NodalFieldModule.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField" href="#FinEtools.ElementalFieldModule.ElementalField"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementalField{T&lt;:Number} &lt;: AbstractField</code></pre><p>Elemental field, meaning the entities are finite elements.</p><p>The values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ElementalFieldModule.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementalField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of elemental field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ElementalFieldModule.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ElementalField(data::FMat{T}=[]) where {T&lt;:Number}</p><p>Constructor of elemental field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ElementalFieldModule.jl#L28-L34">source</a></section></article><h2 id="Integration-rule"><a class="docs-heading-anchor" href="#Integration-rule">Integration rule</a><a id="Integration-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-rule" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.AbstractIntegRule" href="#FinEtools.IntegRuleModule.AbstractIntegRule"><code>FinEtools.IntegRuleModule.AbstractIntegRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractIntegRule</code></pre><p>Abstract type for integration rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussRule(dim=1, order=1)</code></pre><p>Gauss rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussRule &lt;: AbstractIntegRule</code></pre><p>The Gauss rul, applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalSimplexRule(dim=1)</code></pre><p>Nodal-quadrature simplex rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L595-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalSimplexRule &lt;: AbstractIntegRule</code></pre><p>The nodal-quadrature simplex rule.</p><p>The rule is applicable for line segments, triangles, tetrahedra.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L576-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalTensorProductRule(dim=1)</code></pre><p>Nodal-quadrature tensor-product rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L641-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalTensorProductRule &lt;: AbstractIntegRule</code></pre><p>The tensor-product nodal-quadrature rule.</p><p>The rule is applicable for line segments, quadrilaterals, hexahedra.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L622-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule" href="#FinEtools.IntegRuleModule.PointRule"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointRule &lt;: AbstractIntegRule</code></pre><p>Point quadrature rule, used for integration on the standard &quot;point&quot; shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule-Tuple{}" href="#FinEtools.IntegRuleModule.PointRule-Tuple{}"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointRule()</code></pre><p>POINT integration rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexRule(dim=1, npts=1)</code></pre><p>Return simplex rule, appropriate for the manifold dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L488-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexRule &lt;: AbstractIntegRule</code></pre><p>Simplex quadrature rule.</p><p>Used for integration on the standard triangle or the standard tetrahedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L475-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TetRule(npts=1)</code></pre><p>Tetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L412-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TetRule &lt;: AbstractIntegRule</code></pre><p>Tetrahedral quadrature rule, used for integration on the standard tetrahedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrapezoidalRule(dim=1)</code></pre><p>Trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L526-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrapezoidalRule &lt;: AbstractIntegRule</code></pre><p>The trapezoidal rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L512-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriRule(npts=1)</code></pre><p>Type for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. <code>npts</code> = number of points (1– one-point rule, 3 – three-point rule, 6 – six  point rule, 9 –nine point rule, 10 – Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13–twelve- and thirteen-point rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriRule &lt;: AbstractIntegRule</code></pre><p>Triangular quadrature rule for integration on the standard triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegRuleModule.jl#L20-L24">source</a></section></article><h2 id="Integration-domain"><a class="docs-heading-anchor" href="#Integration-domain">Integration domain</a><a id="Integration-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-domain" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain" href="#FinEtools.IntegDomainModule.IntegDomain"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegDomain{S&lt;:AbstractFESet, F&lt;:Function}</code></pre><p>Integration domain.</p><ul><li><code>T</code> = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.</li><li><code>F</code> = type of function to return the &quot;other&quot; dimension.</li></ul><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegDomainModule.jl#L29-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Bool, Float64}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Bool, Float64}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(fes::S, integration_rule::AbstractIntegRule, axisymmetric::Bool,
  otherdimension::FFlt) where {S&lt;:AbstractFESet}</code></pre><p>Construct for axially symmetric models. The other dimension is given as a number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegDomainModule.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Bool}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Bool}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(fes::S, integration_rule::AbstractIntegRule,
  axisymmetric::Bool) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), for axially symmetric models. The other dimension is the default unity (1.0).</p><p>This will probably be called when <code>axisymmetric = true</code>, since the default is <code>axisymmetric = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegDomainModule.jl#L80-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Float64}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule, Float64}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(fes::S, integration_rule::AbstractIntegRule,
  otherdimension::FFlt) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), and constant other dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegDomainModule.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S, AbstractIntegRule}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(fes::S, integration_rule::AbstractIntegRule) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), and the other dimension  being the default 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/IntegDomainModule.jl#L52-L57">source</a></section></article><h2 id="Assembly-of-matrices-and-vectors"><a class="docs-heading-anchor" href="#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a><a id="Assembly-of-matrices-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-of-matrices-and-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysmatAssembler" href="#FinEtools.AssemblyModule.AbstractSysmatAssembler"><code>FinEtools.AssemblyModule.AbstractSysmatAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSysmatAssembler</code></pre><p>Abstract type of system-matrix assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.AbstractSysvecAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSysvecAssembler</code></pre><p>Abstract type of system vector assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerReduced" href="#FinEtools.AssemblyModule.SysmatAssemblerReduced"><code>FinEtools.AssemblyModule.SysmatAssemblerReduced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerReduced{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Type for assembling a sparse global matrix from elementwise matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. No need to access them directly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L863-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparse(z= zero(FFlt), nomatrixresult = false)</code></pre><p>Construct blank system matrix assembler. </p><p>The matrix entries are of type <code>T</code>. The assembler either produces a sparse matrix (when <code>nomatrixresult = true</code>), or does not (when <code>nomatrixresult = false</code>). When the assembler does not produce the sparse matrix when <code>makematrix!</code> is called, it still can be constructed from the buffers stored in the assembler.</p><p><strong>Example</strong></p><p>This is how a sparse matrix is assembled from two rectangular dense matrices.</p><pre><code class="nohighlight hljs">    a = SysmatAssemblerSparse(0.0)                                                        
    startassembly!(a, 5, 5, 3, 7, 7)    
    m = [0.24406   0.599773    0.833404  0.0420141                                             
        0.786024  0.00206713  0.995379  0.780298                                              
        0.845816  0.198459    0.355149  0.224996]                                     
    assemble!(a, m, [1 7 5], [5 2 1 4])        
    m = [0.146618  0.53471   0.614342    0.737833                                              
         0.479719  0.41354   0.00760941  0.836455                                              
         0.254868  0.476189  0.460794    0.00919633                                            
         0.159064  0.261821  0.317078    0.77646                                               
         0.643538  0.429817  0.59788     0.958909]                                   
    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        
    A = makematrix!(a) </code></pre><p>When the <code>nomatrixresult</code> is set as true, no matrix is produced.</p><pre><code class="nohighlight hljs">    a = SysmatAssemblerSparse(0.0, true)                                                        
    startassembly!(a, 5, 5, 3, 7, 7)    
    m = [0.24406   0.599773    0.833404  0.0420141                                             
        0.786024  0.00206713  0.995379  0.780298                                              
        0.845816  0.198459    0.355149  0.224996]                                     
    assemble!(a, m, [1 7 5], [5 2 1 4])        
    m = [0.146618  0.53471   0.614342    0.737833                                              
         0.479719  0.41354   0.00760941  0.836455                                              
         0.254868  0.476189  0.460794    0.00919633                                            
         0.159064  0.261821  0.317078    0.77646                                               
         0.643538  0.429817  0.59788     0.958909]                                   
    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        
    A = makematrix!(a) </code></pre><p>Here <code>A</code> is a sparse zero matrix. To construct the correct matrix is still  possible, for instance like this:</p><pre><code class="nohighlight hljs">    a.nomatrixresult = false
    A = makematrix!(a) </code></pre><p>At this point all the buffers of the assembler have been cleared, and  <code>makematrix!(a)</code> is no longer possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L42-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparse{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Type for assembling a sparse global matrix from elementwise matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. No need to access them directly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseDiag" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseDiag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseDiag(zero::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler for square diagonal matrices. The matrix entries are of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L437-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseDiag" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseDiag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseDiag{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric square diagonal</strong> matrix  assembled from symmetric square diagonal matrices.</p><p>Warning: off-diagonal elements of the elementwise matrices will be ignored during assembly!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L418-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseHRZLumpingSymm(zer::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler. The matrix entries are of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L713-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseHRZLumpingSymm{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric lumped square</strong> matrix  assembled from  <strong>symmetric square</strong> matrices. </p><p>Reference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering &amp; Structural Dynamics, volume 4, number 3, 245–249, 1976.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This assembler can compute and assemble diagonalized mass matrices. However, if the meaning of the entries of the mass matrix  differs (translation versus rotation), the mass matrices will not be computed correctly. Put bluntly: it can only be used for homogeneous mass matrices, all translation degrees of freedom, for instance. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L684-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseSymm(zero::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler for symmetric matrices. The matrix entries are of type <code>T</code>.</p><p><strong>Example</strong></p><p>This is how a symmetric sparse matrix is assembled from two square dense matrices.</p><pre><code class="nohighlight hljs">	a = SysmatAssemblerSparseSymm(0.0)                                                        
	startassembly!(a, 5, 5, 3, 7, 7)    
	m = [0.24406   0.599773    0.833404  0.0420141                                             
		0.786024  0.00206713  0.995379  0.780298                                              
		0.845816  0.198459    0.355149  0.224996]                                     
	assemble!(a, m&#39;*m, [5 2 1 4], [5 2 1 4])        
	m = [0.146618  0.53471   0.614342    0.737833                                              
		 0.479719  0.41354   0.00760941  0.836455                                              
		 0.254868  0.476189  0.460794    0.00919633                                            
		 0.159064  0.261821  0.317078    0.77646                                               
		 0.643538  0.429817  0.59788     0.958909]                                   
	assemble!(a, m&#39;*m, [2 3 1 5], [2 3 1 5])                                        
	A = makematrix!(a) </code></pre><p><strong>See also</strong></p><p>SysmatAssemblerSparse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L249-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseSymm{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric square</strong> matrix  assembled from symmetric square matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysvecAssembler(z= zero(FFlt))</code></pre><p>Construct blank system vector assembler. The vector entries are of type <code>T</code> determined by the zero value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L623-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysvecAssembler</code></pre><p>Assembler for the system vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/AssemblyModule.jl#L613-L617">source</a></section></article><h2 id="Mesh-import/export"><a class="docs-heading-anchor" href="#Mesh-import/export">Mesh import/export</a><a id="Mesh-import/export-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import/export" title="Permalink"></a></h2><h2 id="Vector-cache-utilities"><a class="docs-heading-anchor" href="#Vector-cache-utilities">Vector-cache utilities</a><a id="Vector-cache-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-cache-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache" href="#FinEtools.VectorCacheModule.VectorCache"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorCache{T&lt;:Number, F&lt;:Function}</code></pre><p>Type for caching vectors.</p><p><code>T</code> = type of the entries of the vector, <code>F</code> = type of the function to update the entries of the vector.</p><p>Signature of the function to fill the cache with the value of the vector at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and, if convenient, also the finite element label, <code>fe_label</code>. Finally, the value of the vector may also depend on the <code>time</code> (or the load factor):</p><pre><code class="nohighlight hljs">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)</code></pre><p>The cache <code>cacheout</code> is filled with the value  of the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/VectorCacheModule.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F, Float64}} where {T&lt;:Number, F&lt;:Function}" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F, Float64}} where {T&lt;:Number, F&lt;:Function}"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorCache(::Type{T}, nentries::FInt, fillcache!::F, time::FFlt) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct vector cache. The function to fill the vector cache is given.</p><p>This constructor is intended for <em>time-dependent</em> vector caches. This function needs to have a signature of</p><pre><code class="nohighlight hljs">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)
    Calculate the vector and copy it into the cache....
    return forceout
end</code></pre><p>and it needs to  fill in the cache <code>cacheout</code> with the current vector at the location <code>XYZ</code>, using the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>, if appropriate. The time can also be supplied (keyword argument <code>time</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/VectorCacheModule.jl#L77-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F}} where {T&lt;:Number, F&lt;:Function}" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F}} where {T&lt;:Number, F&lt;:Function}"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorCache(::Type{T}, nentries::FInt, fillcache!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct vector cache. The function to fill the vector cache is given.</p><p>This constructor is intended for <em>time-independent</em> vector caches. This function needs to have a signature of</p><pre><code class="nohighlight hljs">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the vector and copy it into the cache....
    return forceout
end</code></pre><p>and it needs to  fill in the cache <code>cacheout</code> with the current vector at the location <code>XYZ</code>, using the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>, if appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/VectorCacheModule.jl#L40-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorCache(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct vector cache. The <em>constant</em> vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/VectorCacheModule.jl#L105-L109">source</a></section></article><h2 id="Surface-normal-utilities"><a class="docs-heading-anchor" href="#Surface-normal-utilities">Surface-normal utilities</a><a id="Surface-normal-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-normal-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal" href="#FinEtools.SurfaceNormalModule.SurfaceNormal"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal{F&lt;:Function}</code></pre><p>Exterior surface normal type.</p><p>Normalized to unit length.</p><p>Signature of the function to compute the value of the unit normal at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="nohighlight hljs">computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>normalout</code> is filled with the value  of the normal vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/SurfaceNormalModule.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(ndimensions::FInt)</code></pre><p>Construct surface normal evaluator when the default calculation of the normal vector based on the columns of the Jacobian matrix should be used. </p><p>The normal vector has <code>ndimensions</code> entries.</p><p>When the columns of the <code>tangents</code> array are parallel (or one of them is a zero vector), the normal cannot be normalized to unit length (it is a zero vector). In that case a zero vector is returned, and a warning is printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/SurfaceNormalModule.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64, F}} where F&lt;:Function" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64, F}} where F&lt;:Function"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(ndimensions::FInt, computenormal!::F) where {F&lt;:Function}</code></pre><p>Construct surface normal evaluator when the function to compute the normal vector is given. This function needs to have a signature of</p><pre><code class="nohighlight hljs">function computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the normal and copy it into the buffer....
    return normalout # return the buffer
end</code></pre><p>and it needs to  fill in the buffer <code>normalout</code> with the current vector at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/SurfaceNormalModule.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct surface normal vector when the <em>constant</em> normal vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/SurfaceNormalModule.jl#L101-L105">source</a></section></article><h2 id="Force-intensity"><a class="docs-heading-anchor" href="#Force-intensity">Force intensity</a><a id="Force-intensity-1"></a><a class="docs-heading-anchor-permalink" href="#Force-intensity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity" href="#FinEtools.ForceIntensityModule.ForceIntensity"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity{T&lt;:Number, F&lt;:Function}</code></pre><p>Distributed force (force intensity) type.</p><p>The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:</p><ul><li>force/length^3 (when applied to a 3-D solid),</li><li>force/length^2 (when applied to a surface),</li><li>force/length^1 (when applied along a curve), or</li><li>force/length^0 (when applied at a point).</li></ul><p>Signature of the function to compute the value of the force  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="nohighlight hljs">getforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>forceout</code> is filled with the value  of the force. The vector <code>forceout</code> is also returned for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ForceIntensityModule.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Tuple{T} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Tuple{T} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(force::T) where {T&lt;:Number}</code></pre><p>Construct force intensity when the force is given as a scalar value.</p><p>The dimension of the force vector in this case is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ForceIntensityModule.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F, Float64}} where {T&lt;:Number, F&lt;:Function}" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F, Float64}} where {T&lt;:Number, F&lt;:Function}"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F, time::FFlt) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given.</p><p>This constructor is intended for time-dependent force intensity caches.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,</li><li><code>ndofn</code> = number of elements of the force vector (the length of the force vector),</li><li><code>computeforce!</code> = callback function,</li><li><code>time</code> = initial time.</li></ul><p>The function <code>computeforce!</code> needs to have a signature of</p><pre><code class="nohighlight hljs">function computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)
	Calculate the force  and copy it into the buffer....
	return forceout
end</code></pre><p>and it needs to  fill in the buffer <code>forceout</code> with the current force at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>. The initial <code>time</code> is given.</p><p>The time needs to be set with <code>settime!</code> before calling <code>updateforce!</code> as follows:</p><pre><code class="nohighlight hljs">XYZ = reshape([0.0, 0.0], 2, 1)
tangents = reshape([0.0, 1.0], 2, 1)
fe_label = 0
setvector!(v, XYZ, tangents, fe_label; time::FFlt = 0.0) = begin
    return (time &lt; 5.0 ?  v .= [10.0] : v .= [0.0])
end
vector = [10.0]
fi = ForceIntensity(FFlt, length(vector), setvector!, 0.0)
v = updateforce!(fi, XYZ, tangents, fe_label)
@test v == [10.0]
settime!(fi, 6.0)
v = updateforce!(fi, XYZ, tangents, fe_label)
@test v == [0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ForceIntensityModule.jl#L72-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F}} where {T&lt;:Number, F&lt;:Function}" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Int64, F}} where {T&lt;:Number, F&lt;:Function}"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given.</p><p>This constructor is intended for <em>time-independent</em> vector caches.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,</li><li><code>ndofn</code> = number of elements of the force vector (the length of the force vector),</li><li><code>computeforce!</code> = callback function.</li></ul><p>The function <code>computeforce!</code> needs to have a signature of</p><pre><code class="nohighlight hljs">function computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the force  and copy it into the buffer....
    return forceout
end</code></pre><p>and it needs to  fill in the buffer <code>forceout</code> with the current force at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ForceIntensityModule.jl#L40-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(force::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct force intensity when the constant <code>force</code> vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/ForceIntensityModule.jl#L125-L129">source</a></section></article><h2 id="FEM-machines"><a class="docs-heading-anchor" href="#FEM-machines">FEM machines</a><a id="FEM-machines-1"></a><a class="docs-heading-anchor-permalink" href="#FEM-machines" title="Permalink"></a></h2><h3 id="Base"><a class="docs-heading-anchor" href="#Base">Base</a><a id="Base-1"></a><a class="docs-heading-anchor-permalink" href="#Base" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.AbstractFEMM" href="#FinEtools.FEMMBaseModule.AbstractFEMM"><code>FinEtools.FEMMBaseModule.AbstractFEMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFEMM</code></pre><p>Abstract type for all finite element model machines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FEMMBaseModule.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase" href="#FinEtools.FEMMBaseModule.FEMMBase"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FEMMBase{S&lt;:AbstractFESet, F&lt;:Function} &lt;: AbstractFEMM</code></pre><p>Class for base finite element modeling machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FEMMBaseModule.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S, F}}, Tuple{F}, Tuple{S}} where {S&lt;:AbstractFESet, F&lt;:Function}" href="#FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S, F}}, Tuple{F}, Tuple{S}} where {S&lt;:AbstractFESet, F&lt;:Function}"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FEMMBase(integdomain::IntegDomain{S, F}) where {S&lt;:AbstractFESet, F&lt;:Function}</code></pre><p>Construct with the default orientation matrix (identity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/FEMMBaseModule.jl#L64-L68">source</a></section></article><h2 id="Material-models"><a class="docs-heading-anchor" href="#Material-models">Material models</a><a id="Material-models-1"></a><a class="docs-heading-anchor-permalink" href="#Material-models" title="Permalink"></a></h2><h3 id="Material-model-abstractions"><a class="docs-heading-anchor" href="#Material-model-abstractions">Material model abstractions</a><a id="Material-model-abstractions-1"></a><a class="docs-heading-anchor-permalink" href="#Material-model-abstractions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatModule.AbstractMat" href="#FinEtools.MatModule.AbstractMat"><code>FinEtools.MatModule.AbstractMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMat</code></pre><p>Abstract type of material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/15390b2cc1bffd8e24af167c6d585b8e055317ee/src/MatModule.jl#L13-L17">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 11 March 2023 01:33">Saturday 11 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
