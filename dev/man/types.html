<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · FinEtools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtools.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../howto/howto.html">How to</a></li><li><a class="tocitem" href="../tutorials/tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../concepts/concepts.html">Concepts</a></li><li><a class="tocitem" href="man.html">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="types.html">Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="types.html">Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/main/docs/src/man/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="types.html#Types">Types</a></li><li class="no-marker"><ul><li><a href="types.html#Contents">Contents</a></li><li><a href="types.html#Coordinate-systems">Coordinate systems</a></li><li><a href="types.html#Data-cache">Data cache</a></li><li><a href="types.html#Surface-normal-utilities">Surface-normal utilities</a></li><li><a href="types.html#Force-intensity">Force intensity</a></li><li><a href="types.html#Finite-element-sets">Finite element sets</a></li><li><a href="types.html#Finite-element-nodes">Finite element nodes</a></li><li><a href="types.html#Finite-element-node-to-element-map">Finite element node-to-element map</a></li><li><a href="types.html#Fields">Fields</a></li><li><a href="types.html#Integration-rule">Integration rule</a></li><li><a href="types.html#Integration-domain">Integration domain</a></li><li><a href="types.html#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a></li><li><a href="types.html#Mesh-import/export">Mesh import/export</a></li><li><a href="types.html#FEM-machines">FEM machines</a></li><li class="no-marker"><ul><li><a href="types.html#Base">Base</a></li></ul></li><li><a href="types.html#Material-models">Material models</a></li><li class="no-marker"><ul><li><a href="types.html#Material-model-abstractions">Material model abstractions</a></li></ul></li></ul></li></ul><h2 id="Coordinate-systems"><a class="docs-heading-anchor" href="#Coordinate-systems">Coordinate systems</a><a id="Coordinate-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys" href="#FinEtools.CSysModule.CSys"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSys{T&lt;:Number, F&lt;:Function}</code></pre><p>Type for coordinate system transformations. Used to define material coordinate systems, and output coordinate systems, for instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{IT} where IT" href="#FinEtools.CSysModule.CSys-Tuple{IT} where IT"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(dim::IT) where {IT}</code></pre><p>Construct coordinate system when the rotation matrix is the identity.</p><p><code>dim</code> = is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{T}, Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2, T, F}} where {IT1, IT2, T&lt;:Number, F&lt;:Function}" href="#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{T}, Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2, T, F}} where {IT1, IT2, T&lt;:Number, F&lt;:Function}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(sdim::IT1, mdim::IT2, z::T, computecsmat::F) where {IT1, IT2, T &lt;: Number, F &lt;: Function}</code></pre><p>Construct coordinate system when the function to compute the rotation matrix of type <code>T</code> is given.</p><ul><li><code>z</code> = zero value,</li><li>The <code>computecsmat</code> function signature:   <code>update!(csmatout::Matrix{T}, XYZ::VecOrMat{T}, tangents::Matrix{T},       feid::IT, qpid::IT) where {T, IT}</code>   where<ul><li><code>csmatout</code>= output matrix buffer, of size <code>(sdim, mdim)</code>;</li><li><code>XYZ</code>= location  in physical coordinates;</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element;</li><li><code>feid</code>= finite element identifier;</li><li><code>qpid</code>= quadrature point identifier.</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># Cylindrical coordinate system: NO ALLOCATIONS WHATSOEVER!
@views function compute!(csmatout, XYZ, tangents, feid, qpid)
    center = (0.0, 0.0, 0.0)
    xyz = (XYZ[1], XYZ[2], XYZ[3])
    csmatout[:, 1] .= xyz .- center
    csmatout[3, 1] = 0.0
    csmatout[:, 1] ./= norm(csmatout[:, 1])
    csmatout[:, 3] .= (0.0, 0.0, 1.0)
    cross3!(csmatout[:, 2], csmatout[:, 3], csmatout[:, 1])
    csmatout[:, 2] ./=  norm(csmatout[:, 2])
    return csmatout
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L69-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{F}, Tuple{IT1, IT2, F}} where {F&lt;:Function, IT1, IT2}" href="#FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{F}, Tuple{IT1, IT2, F}} where {F&lt;:Function, IT1, IT2}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(sdim::IT1, mdim::IT2, computecsmat::F) where {F &lt;: Function, IT1, IT2}</code></pre><p>Construct coordinate system when the function to compute the rotation matrix is given.</p><p>The function signature:</p><pre><code class="nohighlight hljs">update!(csmatout::Matrix{T}, XYZ::VecOrMat{T}, tangents::Matrix{T},
    feid::IT, qpid::IT) where {T, IT}</code></pre><p>where</p><ul><li><code>csmatout</code>= output matrix buffer, of size <code>(sdim, mdim)</code></li><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>feid</code>= finite element identifier;</li><li><code>qpid</code>= quadrature point identifier.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># Cylindrical coordinate system: NO ALLOCATIONS WHATSOEVER!
@views function compute!(csmatout, XYZ, tangents, feid, qpid)
    center = (0.0, 0.0, 0.0)
    xyz = (XYZ[1], XYZ[2], XYZ[3])
    csmatout[:, 1] .= xyz .- center
    csmatout[3, 1] = 0.0
    csmatout[:, 1] ./= norm(csmatout[:, 1])
    csmatout[:, 3] .= (0.0, 0.0, 1.0)
    cross3!(csmatout[:, 2], csmatout[:, 3], csmatout[:, 1])
    csmatout[:, 2] ./=  norm(csmatout[:, 2])
    return csmatout
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L28-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2}} where {IT1&lt;:Integer, IT2&lt;:Integer}" href="#FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2}} where {IT1&lt;:Integer, IT2&lt;:Integer}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(sdim::IT1, mdim::IT2) where {IT1&lt;:Integer, IT2&lt;:Integer}</code></pre><p>Construct coordinate system for isotropic-material used with isoparametric finite elements.</p><ul><li><code>sdim</code> = number of space dimensions,</li><li><code>mdim</code> = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If  the coordinate system matrix should be identity, better use the constructor for this specific situation, <code>CSys(dim)</code>. That will be much more efficient.</p></div></div><p><strong>See also</strong></p><p><code>gen_iso_csmat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L173-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{Matrix{T}}, Tuple{T}} where T" href="#FinEtools.CSysModule.CSys-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(csmat::Matrix{T}) where {T}</code></pre><p>Construct coordinate system when the rotation matrix is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{T}, Tuple{IT}, Tuple{IT, T}} where {IT&lt;:Integer, T}" href="#FinEtools.CSysModule.CSys-Union{Tuple{T}, Tuple{IT}, Tuple{IT, T}} where {IT&lt;:Integer, T}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSys(dim, z::T) where {T}</code></pre><p>Construct coordinate system when the rotation matrix of element type <code>T</code> is the identity.</p><p><code>dim</code> = is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/CSysModule.jl#L136-L143">source</a></section></article><h2 id="Data-cache"><a class="docs-heading-anchor" href="#Data-cache">Data cache</a><a id="Data-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Data-cache" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.DataCacheModule.DataCache" href="#FinEtools.DataCacheModule.DataCache"><code>FinEtools.DataCacheModule.DataCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataCache{D, F&lt;:Function}</code></pre><p>Type for caching data, such as vectors, matrices, and numbers.</p><p><code>D</code> = type of the data, for instance <code>Matrix{Float64}</code> or <code>Float32</code>. <code>F</code> = type of the function to update the entries of the array.</p><p>Signature of the function to fill the cache with the value of the array is as follows:</p><pre><code class="nohighlight hljs">function fillcache!(cacheout::D,
    XYZ::VecOrMat{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {D, T, IT}
    ... # modify the value of cacheout
    return cacheout
end</code></pre><p>It may use the location <code>XYZ</code>, it may use the columns of the Jacobian matrix of the element, <code>tangents</code>, it may also choose the value given the finite element identifier (i.e. serial number), <code>feid</code>, and the identifier (i.e. serial number) of the quadrature point, <code>qpid</code>. All of these values are supplied by the code requesting the value of the cache. It must return the modified argument <code>cacheout</code>.</p><p>When the cache is accessed, the callback <code>fillcache!</code> is called, and the output <code>cacheout</code> is filled with the value of the cached data.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">function fillcache!(cacheout::Array{CT, N},
        XYZ::VecOrMat{T}, tangents::Matrix{T},
        feid::IT, qpid::IT) where {CT, N, T, IT}
    cacheout .= LinearAlgebra.I(3)
    return cacheout
end
c = DataCache(zeros(Float32, 3, 3), fillcache!)
function f(c)
    XYZ, tangents, feid, qpid = (reshape([0.0, 0.0], 1, 2), [1.0 0.0; 0.0 1.0], 1, 1)
    data = c(XYZ, tangents, feid, qpid)
end
@test f(c) == LinearAlgebra.I(3)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The point of the data cache is that there will be no copying of data. The cache data field is filled in and returned, but no data needs to be copied. The bad news is, the cache is not thread safe. Reading is okay, but writing can lead to data races.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/DataCacheModule.jl#L12-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.DataCacheModule.DataCache-Tuple{D} where D" href="#FinEtools.DataCacheModule.DataCache-Tuple{D} where D"><code>FinEtools.DataCacheModule.DataCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataCache(data::Array{CT, N}) where {CT&lt;:Number, N}</code></pre><p>Construct data cache. The <em>constant</em> data is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/DataCacheModule.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.DataCacheModule.DataCache-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.DataCacheModule.DataCache-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, Matrix{T}, IT, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.DataCacheModule.DataCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(c::DataCache)(XYZ::VecOrMat{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Update the cache and retrieve the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/DataCacheModule.jl#L92-L96">source</a></section></article><h2 id="Surface-normal-utilities"><a class="docs-heading-anchor" href="#Surface-normal-utilities">Surface-normal utilities</a><a id="Surface-normal-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-normal-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal" href="#FinEtools.SurfaceNormalModule.SurfaceNormal"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal{F&lt;:Function}</code></pre><p>Exterior surface normal type.</p><p>The normal vector is assumed to be normalized to unit length.</p><p>Signature of the function to compute the value of the unit normal at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>,  the finite element label, <code>feid</code>, and the identifier of the quadrature point, <code>qpid</code>:</p><pre><code class="nohighlight hljs">function computenormal!(normalout::Vector{CT}, XYZ::Matrix{T},
        tangents::Matrix{T}, feid::IT, qpid::IT) where {CT, T, IT}
        # Calculate the normal  and copy it into the buffer....
        return normalout
    end</code></pre><p>The buffer <code>normalout</code> needs to be filled with the value  of the normal vector.</p><p>Refer to <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a> for details on the caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/SurfaceNormalModule.jl#L15-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Any}" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Any}"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(ndimensions::FInt)</code></pre><p>Construct surface normal evaluator when the default calculation of the normal vector based on the columns of the Jacobian matrix should be used. </p><p>The normal vector has <code>ndimensions</code> entries.</p><p>When the columns of the <code>tangents</code> array are parallel (or one of them is a zero vector), the normal cannot be normalized to unit length (it is a zero vector). In that case a zero vector is returned, and a warning is printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/SurfaceNormalModule.jl#L84-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Any, F}} where F&lt;:Function" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Any, F}} where F&lt;:Function"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(ndimensions, computenormal!::F) where {F&lt;:Function}</code></pre><p>Construct surface normal evaluator when the function to compute the normal vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/SurfaceNormalModule.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{T}, Tuple{Any, T, F}} where {T&lt;:Number, F&lt;:Function}" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{T}, Tuple{Any, T, F}} where {T&lt;:Number, F&lt;:Function}"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(ndimensions, z::T, computenormal!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct surface normal evaluator when the function to compute the normal vector is given.</p><p><strong>Arguments</strong></p><ul><li><p><code>T</code> = the type of the elements of the normal vector,</p></li><li><p><code>ndofn</code> = number of components of the normal vector,</p></li><li><p><code>computenormal!</code> = callback function. The function <code>computenormal!</code> needs to have a signature of</p><p><code>function computenormal!(normalout::Vector{CT}, XYZ::Matrix{T},       tangents::Matrix{T}, feid::IT, qpid::IT) where {CT, T, IT}       # Calculate the normal  and copy it into the buffer....       return normalout   end</code></p><p>and it needs to  fill in the buffer <code>normalout</code> with the current normal at   the location <code>XYZ</code>, using, if appropriate, the information supplied in the   Jacobian matrix <code>tangents</code>, the identifier of the finite element, <code>feid</code>,   and the quadrature point id, <code>qpid</code>. Refer to <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/SurfaceNormalModule.jl#L55-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurfaceNormal(vector::Vector{T}) where {T&lt;:Number}</code></pre><p>Construct surface normal vector when the <em>constant</em> normal vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/SurfaceNormalModule.jl#L125-L129">source</a></section></article><h2 id="Force-intensity"><a class="docs-heading-anchor" href="#Force-intensity">Force intensity</a><a id="Force-intensity-1"></a><a class="docs-heading-anchor-permalink" href="#Force-intensity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity" href="#FinEtools.ForceIntensityModule.ForceIntensity"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity{T&lt;:Number, F&lt;:Function}</code></pre><p>Distributed force (force intensity) type.</p><p>The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:</p><ul><li>force/length^3 (when applied to a 3-D solid),</li><li>force/length^2 (when applied to a surface),</li><li>force/length^1 (when applied along a curve), or</li><li>force/length^0 (when applied at a point).</li></ul><p>Signature of the function to compute the value of the force  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, the finite element identifier, <code>feid</code>:</p><pre><code class="nohighlight hljs">getforce!(forceout::Vector{CT}, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT) where {CT, T, IT}</code></pre><p>A <a href="types.html#FinEtools.DataCacheModule.DataCache"><code>DataCache</code></a> is used to store the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ForceIntensityModule.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Tuple{CT} where CT&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Tuple{CT} where CT&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(force::T) where {T&lt;:Number}</code></pre><p>Construct force intensity when the force is given as a scalar value.</p><p>The dimension of the force vector in this case is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ForceIntensityModule.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{CT}, Tuple{Type{CT}, Any, F}} where {CT&lt;:Number, F&lt;:Function}" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{CT}, Tuple{Type{CT}, Any, F}} where {CT&lt;:Number, F&lt;:Function}"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(
    ::Type{T},
    ndofn,
    computeforce!::F,
) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,</li><li><code>ndofn</code> = number of elements of the force vector (the length of the force vector),</li><li><code>computeforce!</code> = callback function. The function <code>computeforce!</code> needs to have a signature of   <code>function computeforce!(forceout::Vector{CT}, XYZ::Matrix{T},       tangents::Matrix{T}, feid::IT) ) where {CT, T&lt;:Number, IT&lt;:Integer}       # Calculate the force  and copy it into the buffer....       return forceout   end</code>   and it needs to  fill in the buffer <code>forceout</code> with the current force at the   location <code>XYZ</code>, using, if appropriate, the information supplied in the Jacobian   matrix <code>tangents</code>, the identifier of the finite element, <code>feid</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ForceIntensityModule.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Vector{CT}}, Tuple{CT}} where CT&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Vector{CT}}, Tuple{CT}} where CT&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ForceIntensity(force::Vector{T}) where {T&lt;:Number}</code></pre><p>Construct force intensity when the constant <code>force</code> vector is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ForceIntensityModule.jl#L71-L75">source</a></section></article><h2 id="Finite-element-sets"><a class="docs-heading-anchor" href="#Finite-element-sets">Finite element sets</a><a id="Finite-element-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet" href="#FinEtools.FESetModule.AbstractFESet"><code>FinEtools.FESetModule.AbstractFESet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set. Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet0Manifold" href="#FinEtools.FESetModule.AbstractFESet0Manifold"><code>FinEtools.FESetModule.AbstractFESet0Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet0Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet1Manifold" href="#FinEtools.FESetModule.AbstractFESet1Manifold"><code>FinEtools.FESetModule.AbstractFESet1Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet1Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet2Manifold" href="#FinEtools.FESetModule.AbstractFESet2Manifold"><code>FinEtools.FESetModule.AbstractFESet2Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet2Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet3Manifold" href="#FinEtools.FESetModule.AbstractFESet3Manifold"><code>FinEtools.FESetModule.AbstractFESet3Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFESet3Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH20" href="#FinEtools.FESetModule.FESetH20"><code>FinEtools.FESetModule.FESetH20</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH20</code></pre><p>Type for sets of volume-like hexahedral finite elements with 20 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L1023-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH27" href="#FinEtools.FESetModule.FESetH27"><code>FinEtools.FESetModule.FESetH27</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH27</code></pre><p>Type for sets of volume-like hexahedral finite elements with 27 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L1210-L1214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetH8" href="#FinEtools.FESetModule.FESetH8"><code>FinEtools.FESetModule.FESetH8</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetH8</code></pre><p>Type for sets of volume-like hexahedral finite elements with eight nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L948-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetL2" href="#FinEtools.FESetModule.FESetL2"><code>FinEtools.FESetModule.FESetL2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetL2</code></pre><p>Type for sets of curve-like finite elements with two nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L585-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetL3" href="#FinEtools.FESetModule.FESetL3"><code>FinEtools.FESetModule.FESetL3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetL3</code></pre><p>Type for sets of curve-like of finite elements with three nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L618-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetP1" href="#FinEtools.FESetModule.FESetP1"><code>FinEtools.FESetModule.FESetP1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetP1</code></pre><p>Type for sets of point-like of finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L549-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ4" href="#FinEtools.FESetModule.FESetQ4"><code>FinEtools.FESetModule.FESetQ4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ4</code></pre><p>Type for sets of surface-like quadrilateral finite elements with four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L706-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ8" href="#FinEtools.FESetModule.FESetQ8"><code>FinEtools.FESetModule.FESetQ8</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ8</code></pre><p>Type for sets of surface-like quadrilateral finite elements with eight nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L811-L815">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ9" href="#FinEtools.FESetModule.FESetQ9"><code>FinEtools.FESetModule.FESetQ9</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetQ9</code></pre><p>Type for sets of surface-like quadrilateral finite elements with nine nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L757-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT10" href="#FinEtools.FESetModule.FESetT10"><code>FinEtools.FESetModule.FESetT10</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT10</code></pre><p>Type for sets of volume-like tetrahedral finite elements with 10 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L1388-L1392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT3" href="#FinEtools.FESetModule.FESetT3"><code>FinEtools.FESetModule.FESetT3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT3</code></pre><p>Type for sets of surface-like triangular finite elements with three nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L658-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT4" href="#FinEtools.FESetModule.FESetT4"><code>FinEtools.FESetModule.FESetT4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT4</code></pre><p>Type for sets of volume-like tetrahedral finite elements with four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L1337-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.FESetT6" href="#FinEtools.FESetModule.FESetT6"><code>FinEtools.FESetModule.FESetT6</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FESetT6</code></pre><p>Type for sets of surface-like triangular finite elements with six nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FESetModule.jl#L886-L890">source</a></section></article><h2 id="Finite-element-nodes"><a class="docs-heading-anchor" href="#Finite-element-nodes">Finite element nodes</a><a id="Finite-element-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.FENodeSet" href="#FinEtools.FENodeSetModule.FENodeSet"><code>FinEtools.FENodeSetModule.FENodeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FENodeSet{T}</code></pre><p>Finite element node set type.</p><p>The only field is <code>xyz</code>, as the array of node locations. Indexed with the node number. The location of node <code>j</code> is given by <code>xyz[j,:]</code>. Clearly, the nodes needs to be numbered between <code>1</code> and <code>size(xyz, 1)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The constructor makes a <em>copy</em> of the input <code>xyz</code> array for safety.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FENodeSetModule.jl#L13-L25">source</a></section></article><h2 id="Finite-element-node-to-element-map"><a class="docs-heading-anchor" href="#Finite-element-node-to-element-map">Finite element node-to-element map</a><a id="Finite-element-node-to-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-node-to-element-map" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><p>For each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array <code>map</code>.</p><pre><code class="nohighlight hljs">    Example:</code></pre><pre><code class="nohighlight hljs">fes.conn= [7,6,5;
            4,1,3;
            3,7,5];
The map reads
    map[1] = [2];
    map[2] = [];#  note that node number 2 is not referenced by the connectivity
    map[3] = [2,3];
    map[4] = [2];
    map[5] = [1,3];
    map[6] = [1];
    map[7] = [1,3];</code></pre><p>The individual elements from the connectivity that reference node number 5 are 1 and 3, so that <code>fes.conn(map[5],:)</code>includes all the nodes that are connected to node 5 (including node 5 itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FENodeToFEMapModule.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{Matrix{IT}, IT}} where IT&lt;:Integer" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{Matrix{IT}, IT}} where IT&lt;:Integer"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap(conns::FIntMat, nmax::FInt)</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = integer array of the connectivities</li><li><code>nmax</code> = largest possible node number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FENodeToFEMapModule.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT, N}}, 1}, IT}} where {N, IT&lt;:Integer}" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT, N}}, 1}, IT}} where {N, IT&lt;:Integer}"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT&lt;:Integer}</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = connectivities as a vector of tuples</li><li><code>nmax</code> = largest possible node number</li></ul><p>Example:</p><pre><code class="nohighlight hljs">m = FENodeToFEMap(fes.conn, count(fens))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FENodeToFEMapModule.jl#L42-L54">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.AbstractField" href="#FinEtools.FieldModule.AbstractField"><code>FinEtools.FieldModule.AbstractField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractField</code></pre><p>Abstract field.</p><p>Expected  attributes:</p><ul><li><code>values::Array{T,2}</code>: Array of degree of freedom parameters,  indexed by entity number</li><li><code>dofnums::Array{IT,2}</code>: Array of degree of freedom numbers, indexed by entity number</li><li><code>is_fixed::Matrix{Bool}</code>: Array of Boolean flags, indexed by entity number</li><li><code>_nfreedofs::IT</code>: Total number of free degrees of freedom</li></ul><p>See also: <a href="man/@ref"><code>@add_Field_fields()</code></a> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FieldModule.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField" href="#FinEtools.GeneralFieldModule.GeneralField"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralField{T&lt;:Number, IT&lt;:Integer} &lt;: AbstractField</code></pre><p>General field, meaning the entities can be anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/GeneralFieldModule.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralField(data::Matrix{T}, zi::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Constructor of general field.  The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.</p><p>The integer type for the storage of the degree of freedom numbers is set as that of the argument <code>zi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/GeneralFieldModule.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneralField(data::Vector{T}) where {T&lt;:Number}</code></pre><p>Constructor of general field.  The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many rows as there are entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/GeneralFieldModule.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField" href="#FinEtools.NodalFieldModule.NodalField"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalField{T&lt;:Number, IT&lt;:Integer} &lt;: AbstractField</code></pre><p>Nodal field, meaning the entities are the finite element nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/NodalFieldModule.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NodalField(data::Matrix{T}, zi::IT) where {T&lt;:Number, IT&lt;:Integer}</code></pre><p>Constructor of nodal field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.</p><p>The integer type for the storage of the degree of freedom numbers is set as that of the argument <code>zi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/NodalFieldModule.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NodalField(data::Vector{T}) where {T&lt;:Number}</code></pre><p>Constructor of nodal field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/NodalFieldModule.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField" href="#FinEtools.ElementalFieldModule.ElementalField"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementalField{T&lt;:Number, IT&lt;:Integer} &lt;: AbstractField</code></pre><p>Elemental field, meaning the entities are finite elements.</p><p>The values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ElementalFieldModule.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T&lt;:Number, IT&lt;:Integer}"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ElementalField(data::Matrix{T}, zi::IT) where {T&lt;:Number, IT&lt;:Integer}</p><p>Constructor of elemental field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.</p><p>The integer type for the storage of the degree of freedom numbers is set as that of the argument <code>zi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ElementalFieldModule.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementalField(data::Vector{T}) where {T&lt;:Number}</code></pre><p>Constructor of elemental field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/ElementalFieldModule.jl#L48-L54">source</a></section></article><h2 id="Integration-rule"><a class="docs-heading-anchor" href="#Integration-rule">Integration rule</a><a id="Integration-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-rule" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.AbstractIntegRule" href="#FinEtools.IntegRuleModule.AbstractIntegRule"><code>FinEtools.IntegRuleModule.AbstractIntegRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractIntegRule</code></pre><p>Abstract type for integration rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussRule(dim=1, order=1)</code></pre><p>Gauss rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussRule &lt;: AbstractIntegRule</code></pre><p>The Gauss rule, applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalSimplexRule(dim=1)</code></pre><p>Nodal-quadrature simplex rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L588-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalSimplexRule &lt;: AbstractIntegRule</code></pre><p>The nodal-quadrature simplex rule.</p><p>The rule is applicable for line segments, triangles, tetrahedra.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L569-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalTensorProductRule(dim=1)</code></pre><p>Nodal-quadrature tensor-product rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L634-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodalTensorProductRule &lt;: AbstractIntegRule</code></pre><p>The tensor-product nodal-quadrature rule.</p><p>The rule is applicable for line segments, quadrilaterals, hexahedra.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L615-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule" href="#FinEtools.IntegRuleModule.PointRule"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointRule &lt;: AbstractIntegRule</code></pre><p>Point quadrature rule, used for integration on the standard &quot;point&quot; shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L449-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule-Tuple{}" href="#FinEtools.IntegRuleModule.PointRule-Tuple{}"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointRule()</code></pre><p>POINT integration rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexRule(dim=1, npts=1)</code></pre><p>Return simplex rule, appropriate for the manifold dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L482-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexRule &lt;: AbstractIntegRule</code></pre><p>Simplex quadrature rule.</p><p>Used for integration on the standard triangle or the standard tetrahedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L469-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TetRule(npts=1)</code></pre><p>Tetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L407-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TetRule &lt;: AbstractIntegRule</code></pre><p>Tetrahedral quadrature rule, used for integration on the standard tetrahedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L396-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrapezoidalRule(dim=1)</code></pre><p>Trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L519-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrapezoidalRule &lt;: AbstractIntegRule</code></pre><p>The trapezoidal rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L505-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriRule(npts=1)</code></pre><p>Type for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. <code>npts</code> = number of points (1– one-point rule, 3 – three-point rule, 6 – six  point rule, 9 –nine point rule, 10 – Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13–twelve- and thirteen-point rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriRule &lt;: AbstractIntegRule</code></pre><p>Triangular quadrature rule for integration on the standard triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegRuleModule.jl#L17-L21">source</a></section></article><h2 id="Integration-domain"><a class="docs-heading-anchor" href="#Integration-domain">Integration domain</a><a id="Integration-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-domain" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain" href="#FinEtools.IntegDomainModule.IntegDomain"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegDomain{S&lt;:AbstractFESet, F&lt;:Function}</code></pre><p>Integration domain.</p><ul><li><code>T</code> = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.</li><li><code>F</code> = type of function to return the &quot;other&quot; dimension.</li></ul><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegDomainModule.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(
    fes::S,
    integration_rule::IR,
    axisymmetric::Bool,
) where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}</code></pre><p>Construct with the default orientation matrix (identity), for axially symmetric models. The other dimension is the default unity (1.0).</p><p>This will probably be called when <code>axisymmetric = true</code>, since the default is <code>axisymmetric = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegDomainModule.jl#L84-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(fes::S, integration_rule::IR) where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule}</code></pre><p>Construct with the default orientation matrix (identity), and the other dimension  being the default 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegDomainModule.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool, T}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool, T}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(
    fes::S,
    integration_rule::IR,
    axisymmetric::Bool,
    otherdimension::T,
) where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}</code></pre><p>Construct for axially symmetric models. The other dimension is given as a number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegDomainModule.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, T}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, T}} where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntegDomain(
    fes::S,
    integration_rule::IR,
    otherdimension::T,
) where {S&lt;:AbstractFESet, IR&lt;:AbstractIntegRule, T&lt;:Number}</code></pre><p>Construct with the default orientation matrix (identity), and constant other dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/IntegDomainModule.jl#L63-L72">source</a></section></article><h2 id="Assembly-of-matrices-and-vectors"><a class="docs-heading-anchor" href="#Assembly-of-matrices-and-vectors">Assembly of matrices and vectors</a><a id="Assembly-of-matrices-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-of-matrices-and-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysmatAssembler" href="#FinEtools.AssemblyModule.AbstractSysmatAssembler"><code>FinEtools.AssemblyModule.AbstractSysmatAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSysmatAssembler</code></pre><p>Abstract type of system-matrix assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.AbstractSysvecAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSysvecAssembler</code></pre><p>Abstract type of system vector assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L801-L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerFFBlock" href="#FinEtools.AssemblyModule.SysmatAssemblerFFBlock"><code>FinEtools.AssemblyModule.SysmatAssemblerFFBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerFFBlock{A&lt;:AbstractSysmatAssembler, IT} &lt;: AbstractSysmatAssembler</code></pre><p>Type for extracting a free-free matrix, delegating the actual assembly to a different assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L1143-L1148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerFFBlock-Union{Tuple{IT}, Tuple{IT, Any}} where IT&lt;:Integer" href="#FinEtools.AssemblyModule.SysmatAssemblerFFBlock-Union{Tuple{IT}, Tuple{IT, Any}} where IT&lt;:Integer"><code>FinEtools.AssemblyModule.SysmatAssemblerFFBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerFFBlock(row_nfreedofs::IT, col_nfreedofs = row_nfreedofs) where {IT&lt;:Integer}</code></pre><p>Constructor, where the wrapped assembler is for general sparse matrices.</p><p>Supply the number of free degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L1158-L1164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparse{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Type for assembling a sparse global matrix from elementwise matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. The type is manipulated by the functions <code>startassembly!</code>, <code>assemble!</code>, and <code>makematrix!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{T}, Tuple{T, Any}} where T" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{T}, Tuple{T, Any}} where T"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparse(z = zero(T), nomatrixresult = false) where {T}</code></pre><p>Construct a sparse system matrix assembler.</p><p>The matrix entries are of type <code>T</code>. The assembler either produces a sparse matrix (when <code>nomatrixresult = true</code>), or does not (when <code>nomatrixresult = false</code>). When the assembler does not produce the sparse matrix when <code>makematrix!</code> is called, it still can be constructed from the buffers stored in the assembler, until they are cleared when the assembler is destroyed.</p><p><strong>Example</strong></p><p>This is how a sparse matrix is assembled from two rectangular dense matrices.</p><pre><code class="nohighlight hljs">    a = SysmatAssemblerSparse(0.0)
    startassembly!(a, 5, 5, 3, 7, 7)
    m = [0.24406   0.599773    0.833404  0.0420141
        0.786024  0.00206713  0.995379  0.780298
        0.845816  0.198459    0.355149  0.224996]
    assemble!(a, m, [1 7 5], [5 2 1 4])
    m = [0.146618  0.53471   0.614342    0.737833
         0.479719  0.41354   0.00760941  0.836455
         0.254868  0.476189  0.460794    0.00919633
         0.159064  0.261821  0.317078    0.77646
         0.643538  0.429817  0.59788     0.958909]
    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])
    A = makematrix!(a)</code></pre><p>Here <code>A</code> is a sparse matrix of the size 7x7.</p><p>When the <code>nomatrixresult</code> is set as true, no matrix is produced.</p><pre><code class="nohighlight hljs">    a = SysmatAssemblerSparse(0.0, true)
    startassembly!(a, 5, 5, 3, 7, 7)
    m = [0.24406   0.599773    0.833404  0.0420141
        0.786024  0.00206713  0.995379  0.780298
        0.845816  0.198459    0.355149  0.224996]
    assemble!(a, m, [1 7 5], [5 2 1 4])
    m = [0.146618  0.53471   0.614342    0.737833
         0.479719  0.41354   0.00760941  0.836455
         0.254868  0.476189  0.460794    0.00919633
         0.159064  0.261821  0.317078    0.77646
         0.643538  0.429817  0.59788     0.958909]
    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])
    A = makematrix!(a)</code></pre><p>Here <code>A</code> is a named tuple of four sparse zero matrices. To construct the correct matrix is still possible, for instance like this:</p><pre><code class="nohighlight hljs">    a.nomatrixresult = false
    A = makematrix!(a)</code></pre><p>At this point all the buffers of the assembler have potentially been cleared, and <code>makematrix!(a)</code> is no longer possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L101-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseDiag" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseDiag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseDiag{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric square diagonal</strong> matrix  assembled from symmetric square diagonal matrices.</p><p>Warning: off-diagonal elements of the elementwise matrices will be ignored during assembly!</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. The type is manipulated by the functions <code>startassembly!</code>, <code>assemble!</code>, and <code>makematrix!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L584-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseDiag-Union{Tuple{T}, Tuple{T, Any}} where T" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag-Union{Tuple{T}, Tuple{T, Any}} where T"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseDiag(z::T, nomatrixresult = false) where {T}</code></pre><p>Construct blank system matrix assembler for square diagonal matrices. The matrix entries are of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L623-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseHRZLumpingSymm{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric lumped square</strong> matrix  assembled from  <strong>symmetric square</strong> matrices.</p><p>Reference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering &amp; Structural Dynamics, volume 4, number 3, 245–249, 1976.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. The type is manipulated by the functions <code>startassembly!</code>, <code>assemble!</code>, and <code>makematrix!</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This assembler can compute and assemble diagonalized mass matrices. However, if the meaning of the entries of the mass matrix  differs (translation versus rotation), the mass matrices will not be computed correctly. Put bluntly: it can only be used for homogeneous mass matrices, all translation degrees of freedom, for instance.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L919-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{T}, Tuple{T, Any}} where T" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{T}, Tuple{T, Any}} where T"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseHRZLumpingSymm(z::T, nomatrixresult = false) where {T}</code></pre><p>Construct blank system matrix assembler. The matrix entries are of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L967-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseSymm{IT, MBT, IBT} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric square</strong> matrix  assembled from symmetric square matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All fields of the datatype are private. The type is manipulated by the functions <code>startassembly!</code>, <code>assemble!</code>, and <code>makematrix!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L331-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{T}, Tuple{T, Any}} where T" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{T}, Tuple{T, Any}} where T"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysmatAssemblerSparseSymm(z::T, nomatrixresult = false) where {T}</code></pre><p>Construct blank system matrix assembler for symmetric matrices. The matrix entries are of type <code>T</code>.</p><p><strong>Example</strong></p><p>This is how a symmetric sparse matrix is assembled from two square dense matrices.</p><pre><code class="nohighlight hljs">    a = SysmatAssemblerSparseSymm(0.0)
    startassembly!(a, 5, 5, 3, 7, 7)
    m = [0.24406   0.599773    0.833404  0.0420141
        0.786024  0.00206713  0.995379  0.780298
        0.845816  0.198459    0.355149  0.224996]
    assemble!(a, m&#39;*m, [5 2 1 4], [5 2 1 4])
    m = [0.146618  0.53471   0.614342    0.737833
         0.479719  0.41354   0.00760941  0.836455
         0.254868  0.476189  0.460794    0.00919633
         0.159064  0.261821  0.317078    0.77646
         0.643538  0.429817  0.59788     0.958909]
    assemble!(a, m&#39;*m, [2 3 1 5], [2 3 1 5])
    A = makematrix!(a)</code></pre><p><strong>See also</strong></p><p>SysmatAssemblerSparse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L366-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysvecAssembler</code></pre><p>Assembler for the system vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L848-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler-Tuple{T} where T" href="#FinEtools.AssemblyModule.SysvecAssembler-Tuple{T} where T"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysvecAssembler(z::T) where {T}</code></pre><p>Construct blank system vector assembler. The vector entries are of type <code>T</code> determined by the zero value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L858-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssemblerFBlock" href="#FinEtools.AssemblyModule.SysvecAssemblerFBlock"><code>FinEtools.AssemblyModule.SysvecAssemblerFBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SysvecAssemblerFBlock</code></pre><p>Assembler for the system vector, which extracts the free vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L1233-L1237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssemblerFBlock-Tuple{IT} where IT" href="#FinEtools.AssemblyModule.SysvecAssemblerFBlock-Tuple{IT} where IT"><code>FinEtools.AssemblyModule.SysvecAssemblerFBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SysvecAssemblerFBlock(row_nfreedofs::IT) where {IT}</code></pre><p>Constructor of the free block assembler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/AssemblyModule.jl#L1246-L1250">source</a></section></article><h2 id="Mesh-import/export"><a class="docs-heading-anchor" href="#Mesh-import/export">Mesh import/export</a><a id="Mesh-import/export-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import/export" title="Permalink"></a></h2><h2 id="FEM-machines"><a class="docs-heading-anchor" href="#FEM-machines">FEM machines</a><a id="FEM-machines-1"></a><a class="docs-heading-anchor-permalink" href="#FEM-machines" title="Permalink"></a></h2><h3 id="Base"><a class="docs-heading-anchor" href="#Base">Base</a><a id="Base-1"></a><a class="docs-heading-anchor-permalink" href="#Base" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.AbstractFEMM" href="#FinEtools.FEMMBaseModule.AbstractFEMM"><code>FinEtools.FEMMBaseModule.AbstractFEMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFEMM</code></pre><p>Abstract type for all finite element model machines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FEMMBaseModule.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase" href="#FinEtools.FEMMBaseModule.FEMMBase"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FEMMBase{ID&lt;:IntegDomain, CS&lt;:CSys} &lt;: AbstractFEMM</code></pre><p>Type for base finite element modeling machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FEMMBaseModule.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase-Tuple{ID} where ID&lt;:IntegDomain" href="#FinEtools.FEMMBaseModule.FEMMBase-Tuple{ID} where ID&lt;:IntegDomain"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FEMMBase(integdomain::ID) where {ID&lt;:IntegDomain}</code></pre><p>Construct with the default orientation matrix (identity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/FEMMBaseModule.jl#L77-L81">source</a></section></article><h2 id="Material-models"><a class="docs-heading-anchor" href="#Material-models">Material models</a><a id="Material-models-1"></a><a class="docs-heading-anchor-permalink" href="#Material-models" title="Permalink"></a></h2><h3 id="Material-model-abstractions"><a class="docs-heading-anchor" href="#Material-model-abstractions">Material model abstractions</a><a id="Material-model-abstractions-1"></a><a class="docs-heading-anchor-permalink" href="#Material-model-abstractions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatModule.AbstractMat" href="#FinEtools.MatModule.AbstractMat"><code>FinEtools.MatModule.AbstractMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMat</code></pre><p>Abstract type of material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d12618c891349305e151b2be7de3308bbd5237a1/src/MatModule.jl#L10-L14">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 21 March 2024 21:11">Thursday 21 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
