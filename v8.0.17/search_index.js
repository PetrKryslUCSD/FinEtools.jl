var documenterSearchIndex = {"docs":
[{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]\nDepth = 3","category":"page"},{"location":"man/types.html#Coordinate-systems","page":"Types","title":"Coordinate systems","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.CSysModule.CSys","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys{T<:Number, F<:Function}\n\nType for coordinate system transformations. Used to define material coordinate systems, and output coordinate systems, for instance.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Tuple{IT} where IT","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(dim::IT) where {IT}\n\nConstruct coordinate system when the rotation matrix is the identity.\n\ndim = is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{T}, Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2, T, F}} where {IT1, IT2, T<:Number, F<:Function}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::IT1, mdim::IT2, z::T, computecsmat::F) where {IT1, IT2, T <: Number, F <: Function}\n\nConstruct coordinate system when the function to compute the rotation matrix of type T is given.\n\nz = zero value,\nThe computecsmat function signature:   update!(csmatout::Matrix{T}, XYZ::VecOrMat{T}, tangents::Matrix{T},       feid::IT, qpid::IT) where {T, IT}   where\ncsmatout= output matrix buffer, of size (sdim, mdim);\nXYZ= location  in physical coordinates;\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element;\nfeid= finite element identifier;\nqpid= quadrature point identifier.\n\nExample\n\n# Cylindrical coordinate system: NO ALLOCATIONS WHATSOEVER!\n@views function compute!(csmatout, XYZ, tangents, feid, qpid)\n    center = (0.0, 0.0, 0.0)\n    xyz = (XYZ[1], XYZ[2], XYZ[3])\n    csmatout[:, 1] .= xyz .- center\n    csmatout[3, 1] = 0.0\n    csmatout[:, 1] ./= norm(csmatout[:, 1])\n    csmatout[:, 3] .= (0.0, 0.0, 1.0)\n    cross3!(csmatout[:, 2], csmatout[:, 3], csmatout[:, 1])\n    csmatout[:, 2] ./=  norm(csmatout[:, 2])\n    return csmatout\nend\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{F}, Tuple{IT1, IT2, F}} where {F<:Function, IT1, IT2}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::IT1, mdim::IT2, computecsmat::F) where {F <: Function, IT1, IT2}\n\nConstruct coordinate system when the function to compute the rotation matrix is given.\n\nThe function signature:\n\nupdate!(csmatout::Matrix{T}, XYZ::VecOrMat{T}, tangents::Matrix{T},\n    feid::IT, qpid::IT) where {T, IT}\n\nwhere\n\ncsmatout= output matrix buffer, of size (sdim, mdim)\nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element,\nfeid= finite element identifier;\nqpid= quadrature point identifier.\n\nExample\n\n# Cylindrical coordinate system: NO ALLOCATIONS WHATSOEVER!\n@views function compute!(csmatout, XYZ, tangents, feid, qpid)\n    center = (0.0, 0.0, 0.0)\n    xyz = (XYZ[1], XYZ[2], XYZ[3])\n    csmatout[:, 1] .= xyz .- center\n    csmatout[3, 1] = 0.0\n    csmatout[:, 1] ./= norm(csmatout[:, 1])\n    csmatout[:, 3] .= (0.0, 0.0, 1.0)\n    cross3!(csmatout[:, 2], csmatout[:, 3], csmatout[:, 1])\n    csmatout[:, 2] ./=  norm(csmatout[:, 2])\n    return csmatout\nend\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{IT2}, Tuple{IT1}, Tuple{IT1, IT2}} where {IT1<:Integer, IT2<:Integer}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(sdim::IT1, mdim::IT2) where {IT1<:Integer, IT2<:Integer}\n\nConstruct coordinate system for isotropic-material used with isoparametric finite elements.\n\nsdim = number of space dimensions,\nmdim = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.\n\nnote: Note\nIf  the coordinate system matrix should be identity, better use the constructor for this specific situation, CSys(dim). That will be much more efficient.\n\nSee also\n\ngen_iso_csmat\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(csmat::Matrix{T}) where {T}\n\nConstruct coordinate system when the rotation matrix is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.CSysModule.CSys-Union{Tuple{T}, Tuple{IT}, Tuple{IT, T}} where {IT<:Integer, T}","page":"Types","title":"FinEtools.CSysModule.CSys","text":"CSys(dim, z::T) where {T}\n\nConstruct coordinate system when the rotation matrix of element type T is the identity.\n\ndim = is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Data-cache","page":"Types","title":"Data cache","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.DataCacheModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.DataCacheModule.DataCache","page":"Types","title":"FinEtools.DataCacheModule.DataCache","text":"DataCache{D, F<:Function}\n\nType for caching data, such as vectors, matrices, and numbers.\n\nD = type of the data, for instance Matrix{Float64} or Float32. F = type of the function to update the entries of the array.\n\nSignature of the function to fill the cache with the value of the array is as follows:\n\nfunction fillcache!(cacheout::D,\n    XYZ::VecOrMat{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {D, T, IT}\n    ... # modify the value of cacheout\n    return cacheout\nend\n\nIt may use the location XYZ, it may use the columns of the Jacobian matrix of the element, tangents, it may also choose the value of the finite element identifier (i.e. serial number), feid, and the identifier (i.e. serial number) of the quadrature point, qpid. All of these values are supplied by the code requesting the value of the cache. It must return the modified argument cacheout.\n\nWhen the cache is accessed, the callback fillcache! is called, and the output cacheout is filled with the value of the cached data.\n\nExample\n\nfunction fillcache!(cacheout::Array{CT, N},\n        XYZ::VecOrMat{T}, tangents::Matrix{T},\n        feid::IT, qpid::IT) where {CT, N, T, IT}\n    cacheout .= LinearAlgebra.I(3)\n    return cacheout\nend\nc = DataCache(zeros(Float32, 3, 3), fillcache!)\nfunction f(c)\n    XYZ, tangents, feid, qpid = (reshape([0.0, 0.0], 1, 2), [1.0 0.0; 0.0 1.0], 1, 1)\n    data = c(XYZ, tangents, feid, qpid)\nend\n@test f(c) == LinearAlgebra.I(3)\n\nnote: Note\nThe point of the data cache is that there will be no copying of data. The cache data field is filled in and returned, but no data needs to be copied. The bad news is, the cache is not thread safe. Reading is okay, but writing can lead to data races.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.DataCacheModule.DataCache-Tuple{D} where D","page":"Types","title":"FinEtools.DataCacheModule.DataCache","text":"DataCache(data::Array{CT, N}) where {CT<:Number, N}\n\nConstruct data cache. The constant data is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.DataCacheModule.DataCache-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, Matrix{T}, IT, IT}} where {T<:Number, IT<:Integer}","page":"Types","title":"FinEtools.DataCacheModule.DataCache","text":"(c::DataCache)(XYZ::VecOrMat{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T<:Number, IT<:Integer}\n\nUpdate the cache and retrieve the array.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Surface-normal-utilities","page":"Types","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal{F<:Function}\n\nExterior surface normal type.\n\nThe normal vector is assumed to be normalized to unit length.\n\nSignature of the function to compute the value of the unit normal at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents,  the finite element label, feid, and the identifier of the quadrature point, qpid:\n\nfunction computenormal!(normalout::Vector{CT}, XYZ::Matrix{T},\n        tangents::Matrix{T}, feid::IT, qpid::IT) where {CT, T, IT}\n        # Calculate the normal  and copy it into the buffer....\n        return normalout\n    end\n\nThe buffer normalout needs to be filled with the value  of the normal vector.\n\nRefer to DataCache for details on the caching.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Any}","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions::FInt)\n\nConstruct surface normal evaluator when the default calculation of the normal vector based on the columns of the Jacobian matrix should be used. \n\nThe normal vector has ndimensions entries.\n\nWhen the columns of the tangents array are parallel (or one of them is a zero vector), the normal cannot be normalized to unit length (it is a zero vector). In that case a zero vector is returned, and a warning is printed.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Any, F}} where F<:Function","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions, computenormal!::F) where {F<:Function}\n\nConstruct surface normal evaluator when the function to compute the normal vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{T}, Tuple{Any, T, F}} where {T<:Number, F<:Function}","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(ndimensions, z::T, computenormal!::F) where {T<:Number, F<:Function}\n\nConstruct surface normal evaluator when the function to compute the normal vector is given.\n\nArguments\n\nT = the type of the elements of the normal vector,\nndofn = number of components of the normal vector,\ncomputenormal! = callback function. The function computenormal! needs to have a signature of\nfunction computenormal!(normalout::Vector{CT}, XYZ::Matrix{T},       tangents::Matrix{T}, feid::IT, qpid::IT) where {CT, T, IT}       # Calculate the normal  and copy it into the buffer....       return normalout   end\nand it needs to  fill in the buffer normalout with the current normal at   the location XYZ, using, if appropriate, the information supplied in the   Jacobian matrix tangents, the identifier of the finite element, feid,   and the quadrature point id, qpid. Refer to DataCache.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.SurfaceNormalModule.SurfaceNormal","text":"SurfaceNormal(vector::Vector{T}) where {T<:Number}\n\nConstruct surface normal vector when the constant normal vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Force-intensity","page":"Types","title":"Force intensity","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity{T<:Number, F<:Function}\n\nDistributed force (force intensity) type.\n\nThe force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:\n\nforce/length^3 (when applied to a 3-D solid),\nforce/length^2 (when applied to a surface),\nforce/length^1 (when applied along a curve), or\nforce/length^0 (when applied at a point).\n\nSignature of the function to compute the value of the force  at any given point XYZ, using the columns of the Jacobian matrix of the element, tangents, the finite element identifier, feid:\n\ngetforce!(forceout::Vector{CT}, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT) where {CT, T, IT}\n\nA DataCache is used to store the data.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Tuple{CT} where CT<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::T) where {T<:Number}\n\nConstruct force intensity when the force is given as a scalar value.\n\nThe dimension of the force vector in this case is 1.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{CT}, Tuple{Type{CT}, Any, F}} where {CT<:Number, F<:Function}","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(\n    ::Type{T},\n    ndofn,\n    computeforce!::F,\n) where {T<:Number, F<:Function}\n\nConstruct force intensity when the function to compute the intensity vector is given.\n\nArguments\n\nT = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,\nndofn = number of elements of the force vector (the length of the force vector),\ncomputeforce! = callback function. The function computeforce! needs to have a signature of   function computeforce!(forceout::Vector{CT}, XYZ::Matrix{T},       tangents::Matrix{T}, feid::IT) ) where {CT, T<:Number, IT<:Integer}       # Calculate the force  and copy it into the buffer forceout....       return forceout   end   and it needs to fill in the buffer forceout with the current force at the   location XYZ, using, if appropriate, the information supplied in the Jacobian   matrix tangents, and the identifier of the finite element, feid.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Vector{CT}}, Tuple{CT}} where CT<:Number","page":"Types","title":"FinEtools.ForceIntensityModule.ForceIntensity","text":"ForceIntensity(force::Vector{T}) where {T<:Number}\n\nConstruct force intensity when the constant force vector is given.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Finite-element-sets","page":"Types","title":"Finite element sets","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet","page":"Types","title":"FinEtools.FESetModule.AbstractFESet","text":"AbstractFESet{NODESPERELEM}\n\nAbstract type of a finite element set. Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet0Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet0Manifold","text":"AbstractFESet0Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet1Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet1Manifold","text":"AbstractFESet1Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet2Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet2Manifold","text":"AbstractFESet2Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.AbstractFESet3Manifold","page":"Types","title":"FinEtools.FESetModule.AbstractFESet3Manifold","text":"AbstractFESet3Manifold{NODESPERELEM} <: FESet{NODESPERELEM}\n\nAbstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH20","page":"Types","title":"FinEtools.FESetModule.FESetH20","text":"FESetH20\n\nType for sets of volume-like hexahedral finite elements with 20 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH27","page":"Types","title":"FinEtools.FESetModule.FESetH27","text":"FESetH27\n\nType for sets of volume-like hexahedral finite elements with 27 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetH8","page":"Types","title":"FinEtools.FESetModule.FESetH8","text":"FESetH8\n\nType for sets of volume-like hexahedral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL2","page":"Types","title":"FinEtools.FESetModule.FESetL2","text":"FESetL2\n\nType for sets of curve-like finite elements with two nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetL3","page":"Types","title":"FinEtools.FESetModule.FESetL3","text":"FESetL3\n\nType for sets of curve-like of finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetP1","page":"Types","title":"FinEtools.FESetModule.FESetP1","text":"FESetP1\n\nType for sets of point-like of finite elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ4","page":"Types","title":"FinEtools.FESetModule.FESetQ4","text":"FESetQ4\n\nType for sets of surface-like quadrilateral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ8","page":"Types","title":"FinEtools.FESetModule.FESetQ8","text":"FESetQ8\n\nType for sets of surface-like quadrilateral finite elements with eight nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetQ9","page":"Types","title":"FinEtools.FESetModule.FESetQ9","text":"FESetQ9\n\nType for sets of surface-like quadrilateral finite elements with nine nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT10","page":"Types","title":"FinEtools.FESetModule.FESetT10","text":"FESetT10\n\nType for sets of volume-like tetrahedral finite elements with 10 nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT3","page":"Types","title":"FinEtools.FESetModule.FESetT3","text":"FESetT3\n\nType for sets of surface-like triangular finite elements with three nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT4","page":"Types","title":"FinEtools.FESetModule.FESetT4","text":"FESetT4\n\nType for sets of volume-like tetrahedral finite elements with four nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FESetModule.FESetT6","page":"Types","title":"FinEtools.FESetModule.FESetT6","text":"FESetT6\n\nType for sets of surface-like triangular finite elements with six nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-nodes","page":"Types","title":"Finite element nodes","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeSetModule.FENodeSet","page":"Types","title":"FinEtools.FENodeSetModule.FENodeSet","text":"mutable struct FENodeSet{T}\n\nFinite element node set type.\n\nThe only field is xyz, as the array of node locations. Indexed with the node number. The location of node j is given by xyz[j,:]. Clearly, the nodes needs to be numbered between 1 and size(xyz, 1).\n\nnote: Note\nThe constructor makes a copy of the input xyz array for safety.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Finite-element-node-to-element-map","page":"Types","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap\n\nMap from finite element nodes to the finite elements connecting them.\n\nFor each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array map.\n\n    Example:\n\nfes.conn= [7,6,5;\n            4,1,3;\n            3,7,5];\nThe map reads\n    map[1] = [2];\n    map[2] = [];#  note that node number 2 is not referenced by the connectivity\n    map[3] = [2,3];\n    map[4] = [2];\n    map[5] = [1,3];\n    map[6] = [1];\n    map[7] = [1,3];\n\nThe individual elements from the connectivity that reference node number 5 are 1 and 3, so that fes.conn(map[5],:)includes all the nodes that are connected to node 5 (including node 5 itself).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{FE}, Tuple{FE, IT}} where {FE<:AbstractFESet, IT<:Integer}","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(fes::FE, nmax::IT) where {FE<:AbstractFESet,IT<:Integer}\n\nMap from finite element nodes to the finite elements connecting them.\n\nConvenience constructor.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT, N}}, 1}, IT}} where {N, IT<:Integer}","page":"Types","title":"FinEtools.FENodeToFEMapModule.FENodeToFEMap","text":"FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT<:Integer}\n\nMap from finite element nodes to the finite elements connecting them.\n\nconns = connectivities as a vector of tuples\nnmax = largest possible node number\n\nExample:\n\nm = FENodeToFEMap(fes.conn, count(fens))\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Fields","page":"Types","title":"Fields","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FieldModule.AbstractField","page":"Types","title":"FinEtools.FieldModule.AbstractField","text":"AbstractField\n\nAbstract field.\n\nExpected  attributes:\n\nvalues::Array{T,2}: Array of degree of freedom parameters,  indexed by entity number\ndofnums::Array{IT,2}: Array of degree of freedom numbers, indexed by entity number\nis_fixed::Matrix{Bool}: Array of Boolean flags, indexed by entity number\n_nfreedofs::IT: Total number of free degrees of freedom\n\nSee also: @add_Field_fields() .\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField{T<:Number, IT<:Integer} <: AbstractField\n\nGeneral field, meaning the entities can be anything.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T<:Number, IT<:Integer}","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::Matrix{T}, zi::IT) where {T<:Number, IT<:Integer}\n\nConstructor of general field.  The values of the field are given by the array on input, data. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.\n\nThe integer type for the storage of the degree of freedom numbers is set as that of the argument zi.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.GeneralFieldModule.GeneralField","text":"GeneralField(data::Vector{T}) where {T<:Number}\n\nConstructor of general field.  The values of the field are given by the vector on input, data. This vector needs to have as many rows as there are entities.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField{T<:Number, IT<:Integer} <: AbstractField\n\nNodal field, meaning the entities are the finite element nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T<:Number, IT<:Integer}","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::Matrix{T}, zi::IT) where {T<:Number, IT<:Integer}\n\nConstructor of nodal field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.\n\nThe integer type for the storage of the degree of freedom numbers is set as that of the argument zi.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.NodalFieldModule.NodalField","text":"NodalField(data::Vector{T}) where {T<:Number}\n\nConstructor of nodal field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per node.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField{T<:Number, IT<:Integer} <: AbstractField\n\nElemental field, meaning the entities are finite elements.\n\nThe values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT}} where {T<:Number, IT<:Integer}","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::Matrix{T}, zi::IT) where {T<:Number, IT<:Integer}\n\nConstructor of elemental field. The values of the field are given by the array on input, data. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.\n\nThe integer type for the storage of the degree of freedom numbers is set as that of the argument zi.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Types","title":"FinEtools.ElementalFieldModule.ElementalField","text":"ElementalField(data::Vector{T}) where {T<:Number}\n\nConstructor of elemental field. The values of the field are given by the vector on input, data. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Integration-rule","page":"Types","title":"Integration rule","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegRuleModule.AbstractIntegRule","page":"Types","title":"FinEtools.IntegRuleModule.AbstractIntegRule","text":"AbstractIntegRule\n\nAbstract type for integration rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule(dim=1, order=1)\n\nGauss rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.GaussRule-2","page":"Types","title":"FinEtools.IntegRuleModule.GaussRule","text":"GaussRule <: AbstractIntegRule\n\nThe Gauss rule, applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule(dim=1)\n\nNodal-quadrature simplex rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalSimplexRule-2","page":"Types","title":"FinEtools.IntegRuleModule.NodalSimplexRule","text":"NodalSimplexRule <: AbstractIntegRule\n\nThe nodal-quadrature simplex rule.\n\nThe rule is applicable for line segments, triangles, tetrahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule(dim=1)\n\nNodal-quadrature tensor-product rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.NodalTensorProductRule-2","page":"Types","title":"FinEtools.IntegRuleModule.NodalTensorProductRule","text":"NodalTensorProductRule <: AbstractIntegRule\n\nThe tensor-product nodal-quadrature rule.\n\nThe rule is applicable for line segments, quadrilaterals, hexahedra.\n\nnote: Note\n\n\nThe quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule <: AbstractIntegRule\n\nPoint quadrature rule, used for integration on the standard \"point\" shape.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.PointRule-Tuple{}","page":"Types","title":"FinEtools.IntegRuleModule.PointRule","text":"PointRule()\n\nPOINT integration rule.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule(dim=1, npts=1)\n\nReturn simplex rule, appropriate for the manifold dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.SimplexRule-2","page":"Types","title":"FinEtools.IntegRuleModule.SimplexRule","text":"SimplexRule <: AbstractIntegRule\n\nSimplex quadrature rule.\n\nUsed for integration on the standard triangle or the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule(npts=1)\n\nTetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TetRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TetRule","text":"TetRule <: AbstractIntegRule\n\nTetrahedral quadrature rule, used for integration on the standard tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule(dim=1)\n\nTrapezoidal rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TrapezoidalRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TrapezoidalRule","text":"TrapezoidalRule <: AbstractIntegRule\n\nThe trapezoidal rule.\n\nThe rule is applicable for a tensor product of  intervals -1 <=x<= +1.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule(npts=1)\n\nType for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. npts = number of points (1– one-point rule, 3 – three-point rule, 6 – six  point rule, 9 –nine point rule, 10 – Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13–twelve- and thirteen-point rule.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegRuleModule.TriRule-2","page":"Types","title":"FinEtools.IntegRuleModule.TriRule","text":"TriRule <: AbstractIntegRule\n\nTriangular quadrature rule for integration on the standard triangle.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Integration-domain","page":"Types","title":"Integration domain","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain{S<:AbstractFESet, F<:Function}\n\nIntegration domain.\n\nT = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.\nF = type of function to return the \"other\" dimension.\n\nAn integration domain consists of the finite elements that approximate the geometry, the function to supply the \"missing\" (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool}} where {S<:AbstractFESet, IR<:AbstractIntegRule}","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(\n    fes::S,\n    integration_rule::IR,\n    axisymmetric::Bool,\n) where {S<:AbstractFESet, IR<:AbstractIntegRule}\n\nConstruct with the default orientation matrix (identity), for axially symmetric models. The other dimension is the default unity (1.0).\n\nThis will probably be called when axisymmetric = true, since the default is axisymmetric = false.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{IR}, Tuple{S}, Tuple{S, IR}} where {S<:AbstractFESet, IR<:AbstractIntegRule}","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(fes::S, integration_rule::IR) where {S<:AbstractFESet, IR<:AbstractIntegRule}\n\nConstruct with the default orientation matrix (identity), and the other dimension  being the default 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, Bool, T}} where {S<:AbstractFESet, IR<:AbstractIntegRule, T<:Number}","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(\n    fes::S,\n    integration_rule::IR,\n    axisymmetric::Bool,\n    otherdimension::T,\n) where {S<:AbstractFESet, IR<:AbstractIntegRule, T<:Number}\n\nConstruct for axially symmetric models. The other dimension is given as a number.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{T}, Tuple{IR}, Tuple{S}, Tuple{S, IR, T}} where {S<:AbstractFESet, IR<:AbstractIntegRule, T<:Number}","page":"Types","title":"FinEtools.IntegDomainModule.IntegDomain","text":"IntegDomain(\n    fes::S,\n    integration_rule::IR,\n    otherdimension::T,\n) where {S<:AbstractFESet, IR<:AbstractIntegRule, T<:Number}\n\nConstruct with the default orientation matrix (identity), and constant other dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Assembly-of-matrices-and-vectors","page":"Types","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysmatAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysmatAssembler","text":"AbstractSysmatAssembler\n\nAbstract type of system-matrix assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.AbstractSysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.AbstractSysvecAssembler","text":"AbstractSysvecAssembler\n\nAbstract type of system vector assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerFFBlock","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerFFBlock","text":"SysmatAssemblerFFBlock{A<:AbstractSysmatAssembler, IT} <: AbstractSysmatAssembler\n\nType for extracting a free-free matrix, delegating the actual assembly to a different assembler.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerFFBlock-Union{Tuple{IT}, Tuple{IT, Any}} where IT<:Integer","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerFFBlock","text":"SysmatAssemblerFFBlock(row_nfreedofs::IT, col_nfreedofs = row_nfreedofs) where {IT<:Integer}\n\nConstructor, where the wrapped assembler is for general sparse matrices.\n\nSupply the number of free degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse{IT, MBT, IBT} <: AbstractSysmatAssembler\n\nType for assembling a sparse global matrix from elementwise matrices.\n\nnote: Note\nAll fields of the datatype are private. The type is manipulated by the functions startassembly!, assemble!, and makematrix!.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparse","text":"SysmatAssemblerSparse(z = zero(T), nomatrixresult = false) where {T}\n\nConstruct a sparse system matrix assembler.\n\nThe matrix entries are of type T. The assembler either produces a sparse matrix (when nomatrixresult = true), or does not (when nomatrixresult = false). When the assembler does not produce the sparse matrix when makematrix! is called, it still can be constructed from the buffers stored in the assembler, until they are cleared when the assembler is destroyed.\n\nExample\n\nThis is how a sparse matrix is assembled from two rectangular dense matrices.\n\n    a = SysmatAssemblerSparse(0.0)\n    startassembly!(a, 5, 5, 3, 7, 7)\n    m = [0.24406   0.599773    0.833404  0.0420141\n        0.786024  0.00206713  0.995379  0.780298\n        0.845816  0.198459    0.355149  0.224996]\n    assemble!(a, m, [1 7 5], [5 2 1 4])\n    m = [0.146618  0.53471   0.614342    0.737833\n         0.479719  0.41354   0.00760941  0.836455\n         0.254868  0.476189  0.460794    0.00919633\n         0.159064  0.261821  0.317078    0.77646\n         0.643538  0.429817  0.59788     0.958909]\n    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])\n    A = makematrix!(a)\n\nHere A is a sparse matrix of the size 7x7.\n\nWhen the nomatrixresult is set as true, no matrix is produced.\n\n    a = SysmatAssemblerSparse(0.0, true)\n    startassembly!(a, 5, 5, 3, 7, 7)\n    m = [0.24406   0.599773    0.833404  0.0420141\n        0.786024  0.00206713  0.995379  0.780298\n        0.845816  0.198459    0.355149  0.224996]\n    assemble!(a, m, [1 7 5], [5 2 1 4])\n    m = [0.146618  0.53471   0.614342    0.737833\n         0.479719  0.41354   0.00760941  0.836455\n         0.254868  0.476189  0.460794    0.00919633\n         0.159064  0.261821  0.317078    0.77646\n         0.643538  0.429817  0.59788     0.958909]\n    assemble!(a, m, [2 3 1 7 5], [6 7 3 4])\n    A = makematrix!(a)\n\nHere A is a named tuple of four sparse zero matrices. To construct the correct matrix is still possible, for instance like this:\n\n    a.nomatrixresult = false\n    A = makematrix!(a)\n\nAt this point all the buffers of the assembler have potentially been cleared, and makematrix!(a) is no longer possible.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseDiag","text":"SysmatAssemblerSparseDiag{T<:Number} <: AbstractSysmatAssembler\n\nAssembler for a symmetric square diagonal matrix  assembled from symmetric square diagonal matrices.\n\nWarning: off-diagonal elements of the elementwise matrices will be ignored during assembly!\n\nnote: Note\nAll fields of the datatype are private. The type is manipulated by the functions startassembly!, assemble!, and makematrix!.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseDiag-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseDiag","text":"SysmatAssemblerSparseDiag(z::T, nomatrixresult = false) where {T}\n\nConstruct blank system matrix assembler for square diagonal matrices. The matrix entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm{IT, MBT, IBT} <: AbstractSysmatAssembler\n\nAssembler for a symmetric lumped square matrix  assembled from  symmetric square matrices.\n\nReference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering & Structural Dynamics, volume 4, number 3, 245–249, 1976.\n\nnote: Note\nAll fields of the datatype are private. The type is manipulated by the functions startassembly!, assemble!, and makematrix!.\n\nnote: Note\nThis assembler can compute and assemble diagonalized mass matrices. However, if the meaning of the entries of the mass matrix  differs (translation versus rotation), the mass matrices will not be computed correctly. Put bluntly: it can only be used for homogeneous mass matrices, all translation degrees of freedom, for instance.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm","text":"SysmatAssemblerSparseHRZLumpingSymm(z::T, nomatrixresult = false) where {T}\n\nConstruct blank system matrix assembler. The matrix entries are of type T.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm{IT, MBT, IBT} <: AbstractSysmatAssembler\n\nAssembler for a symmetric square matrix  assembled from symmetric square matrices.\n\nnote: Note\nAll fields of the datatype are private. The type is manipulated by the functions startassembly!, assemble!, and makematrix!.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Types","title":"FinEtools.AssemblyModule.SysmatAssemblerSparseSymm","text":"SysmatAssemblerSparseSymm(z::T, nomatrixresult = false) where {T}\n\nConstruct blank system matrix assembler for symmetric matrices. The matrix entries are of type T.\n\nExample\n\nThis is how a symmetric sparse matrix is assembled from two square dense matrices.\n\n    a = SysmatAssemblerSparseSymm(0.0)\n    startassembly!(a, 5, 5, 3, 7, 7)\n    m = [0.24406   0.599773    0.833404  0.0420141\n        0.786024  0.00206713  0.995379  0.780298\n        0.845816  0.198459    0.355149  0.224996]\n    assemble!(a, m'*m, [5 2 1 4], [5 2 1 4])\n    m = [0.146618  0.53471   0.614342    0.737833\n         0.479719  0.41354   0.00760941  0.836455\n         0.254868  0.476189  0.460794    0.00919633\n         0.159064  0.261821  0.317078    0.77646\n         0.643538  0.429817  0.59788     0.958909]\n    assemble!(a, m'*m, [2 3 1 5], [2 3 1 5])\n    A = makematrix!(a)\n\nSee also\n\nSysmatAssemblerSparse\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler\n\nAssembler for the system vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssembler-Tuple{T} where T","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssembler","text":"SysvecAssembler(z::T) where {T}\n\nConstruct blank system vector assembler. The vector entries are of type T determined by the zero value.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssemblerFBlock","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssemblerFBlock","text":"SysvecAssemblerFBlock\n\nAssembler for the system vector, which extracts the free vector.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.AssemblyModule.SysvecAssemblerFBlock-Tuple{IT} where IT","page":"Types","title":"FinEtools.AssemblyModule.SysvecAssemblerFBlock","text":"SysvecAssemblerFBlock(row_nfreedofs::IT) where {IT}\n\nConstructor of the free block assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Mesh-import/export","page":"Types","title":"Mesh import/export","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MeshImportModule, FinEtools.MeshExportModule]\nPrivate = true\nOrder = [:type]\nDepth = 3","category":"page"},{"location":"man/types.html#FEM-machines","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Base","page":"Types","title":"Base","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.FEMMBaseModule.AbstractFEMM","page":"Types","title":"FinEtools.FEMMBaseModule.AbstractFEMM","text":"AbstractFEMM\n\nAbstract type for all finite element model machines.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase{ID<:IntegDomain, CS<:CSys} <: AbstractFEMM\n\nType for base finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtools.FEMMBaseModule.FEMMBase-Tuple{ID} where ID<:IntegDomain","page":"Types","title":"FinEtools.FEMMBaseModule.FEMMBase","text":"FEMMBase(integdomain::ID) where {ID<:IntegDomain}\n\nConstruct with the default orientation matrix (identity).\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Material-models","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#Material-model-abstractions","page":"Types","title":"Material model abstractions","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtools.MatModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtools.MatModule.AbstractMat","page":"Types","title":"FinEtools.MatModule.AbstractMat","text":"AbstractMat\n\nAbstract type of material.\n\n\n\n\n\n","category":"type"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Table of contents","category":"page"},{"location":"concepts/concepts.html#Guide","page":"Concepts","title":"Guide","text":"","category":"section"},{"location":"concepts/concepts.html#Break-down-into-modules","page":"Concepts","title":"Break down into modules","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The FinEtools package consists of many modules which fall into several  categories. The top-level module, FinEtools, includes all other modules and exports functions to constitute the public interface. The user is free to generate their own public interface, however. More details are provided in the section Make up your own public interface.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Top-level:     FinEtools is the  top-level module.  For interactive use   it is enough to do using FinEtools, however in some  cases functions from   modules need to be  brought into the scope individually (most importantly,   the algorithm modules). This is the ONLY  module that EXPORTS  functions,   none of the other modules exports a single function. The entire  public   (i. e. exported) interface of the FinEtools package is specified  in the   file FinEtools.jl (i. e. in the FinEtools module). The user is free to   specify his or her own set of exported functions from the FinEtools package   to create an ad hoc public interface.\nUtilities: Refer to the modules FTypesModule (definition of basic   numerical types), PhysicalUnitModule (for use with numbers specified   using physical units), AssemblyModule (assembly of elementwise matrices   and vectors),   CSysModule (coordinate system module),   MatrixUtilityModule (utilities for operations on elementwise matrices),   BoxModule  (support for working with bounding boxes),   ForceIntensityModule (force-intensity module), RotationUtilModule   (support for spatial rotations).\nMesh  entities:  FENodeSetModule, FESetModule (node set and finite element set  types). \nMesh Generation:   MeshLineModule,  MeshQuadrilateralModule,   MeshTriangleModule,   MeshTetrahedronModule, MeshHexahedronModule,   VoxelBoxModule. \nMesh manipulation:  MeshSelectionModule (searching of nodes  and   elements),  MeshModificationModule (mesh boundary, merging  of meshes and   nodes, smoothing, partitioning),  MeshUtilModule   (utilities), FENodeToFEMapModule (search structure from nodes to   elements).\nMesh import/export:  MeshImportModule,  MeshExportModule.\nFields:   FieldModule,    GeneralFieldModule, ElementalFieldModule,   NodalFieldModule (modules for representing quantities on the mesh).\nIntegration: Support for  integration over solids, surfaces, curves, and   points: IntegRuleModule,   IntegDomainModule.   The package defines some common bilinear and linear forms to aid in constructing weighted residual methods.\nGeneral algorithms: AlgoBaseModule (algorithms), FEMMBaseModule   (FEM machine for general tasks).","category":"page"},{"location":"concepts/concepts.html#Arithmetic-types","page":"Concepts","title":"Arithmetic types","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The FinEtools package tries to make typing arguments easier. The arithmetic types used throughout are FInt for integer data, FFlt for floating-point data, and Complex{FFlt} for applications that work with complex linear algebra quantities.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The module FTypesModule defines these types, and also defines abbreviations for vectors and matrices with entries of these types.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Some algorithms expect input in the form of a data dictionary, FDataDict, and also produce output in this form.","category":"page"},{"location":"concepts/concepts.html#Physical-units","page":"Concepts","title":"Physical units","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The PhysicalUnitModule provides a simple function, phun, which can help with providing input numbers with the correct conversion between physical units. For instance, it is possible to specify the input data as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"E = 200*phun(\"GPa\");# Young's modulus\nnu = 0.3;# Poisson ratio\nrho = 8000*phun(\"KG*M^-3\");# mass density\nL = 10.0*phun(\"M\"); # side of the square plate\nt = 0.05*phun(\"M\"); # thickness of the square plate","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"A few common sets of units are included, :US, :IMPERIAL, :CGS, :SIMM (millimeter-based SI units), and :SI (meter-based SI units). The resulting  values assigned to the variables are floating-point numbers, for instance","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"julia> E = 200*phun(\"GPa\")\n2.0e11","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Numbers output by the simulation can also be converted  to appropriate units for printing as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"julia> E/phun(\"MPa\")\n200000.0","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"It is also possible to use a macro to define physical units:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"E = 200*u\"GPa\";# Young's modulus\nnu = 0.3;# Poisson ratio\nrho = 8000*u\"KG*M^-3\";# mass density\nL = 10.0*u\"M\"; # side of the square plate\nt = 0.05*u\"M\"; # thickness of the square plate\nt / u\"mm\"","category":"page"},{"location":"concepts/concepts.html#Mesh-entities","page":"Concepts","title":"Mesh entities","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The mesh consists of one set of finite element nodes  and one or more sets of finite elements.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"One of the  organizing principles of the  finite element collection  is that  finite elements can appear as representations of the interior  of the domain, but in a different model as parts of the boundary.  Thus  for instance  4-node  quadrilaterals  are finite elements that represent cross-sections of  axially symmetric models or surfaces  of membranes,  but they are also the boundaries of hexahedral  models.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"A mesh  is generated by one of the functions specialized to a particular finite element type. Thus there are  mesh generation functions for lines, triangles, quadrilaterals, tetrahedra, and hexahedra.","category":"page"},{"location":"concepts/concepts.html#Mesh-generation","page":"Concepts","title":"Mesh generation","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As an example,  the following code generates a hexahedral mesh of simple rectangular block.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The finite element node set and the finite element set  are returned. More complicated meshes can be constructed from such mesh parts. There are  functions for  merging  nodes  and even multiple meshes together.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The code snippet below  constructs the mesh of an  L-shaped  domain  from  the meshes of three rectangles.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"W = 100. # width of the leg\nL = 200. # length of the leg\nnL = 15 # number of elements along the length of the leg\nnW = 10 # number of elements along the width\ntolerance = W / nW / 1.0e5 # tolerance for merging nodes\nMeshes = Array{Tuple{FENodeSet,FESet},1}()\npush!(Meshes, Q4quadrilateral([0.0 0.0; W W], nW, nW))\npush!(Meshes, Q4quadrilateral([-L 0.0; 0.0 W], nL, nW))\npush!(Meshes, Q4quadrilateral([0.0 -L; W 0.0], nW, nL))\nfens, outputfes = mergenmeshes(Meshes, tolerance);\nfes = cat(outputfes[1], cat(outputfes[2], outputfes[3]))","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As an example of the  merging  of nodes to create  the final mesh, consider the creation of  a closed hollow tube.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens, fes  = H8block(h, l, 2.0 * pi, nh, nl, nc) # generate a block\n# Shape into a cylinder\nR = zeros(3, 3)\nfor i = 1:count(fens)\n    x, y, z = fens.xyz[i,:];\n    rotmat3!(R, [0, z, 0])\n    Q = [cos(psi * pi / 180) sin(psi * pi / 180) 0;\n        -sin(psi * pi / 180) cos(psi * pi / 180) 0;\n        0 0 1]\n    fens.xyz[i,:] = reshape([x + Rmed - h / 2, y - l / 2, 0], 1, 3) * Q * R;\nend\n# Merge the nodes where the tube  closes up\ncandidates = selectnode(fens, box = boundingbox([Rmed - h -Inf 0.0; Rmed + h +Inf 0.0]), inflate = tolerance)\nfens, fes = mergenodes(fens, fes,  tolerance, candidates);","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The final mesh used for a simulation  consists of a single  node set and one or more finite element sets. The  finite elements may be  divided into separate sets  to  accommodate different material properties, different orientations of the material  coordinate systems, or different formulations  of the discrete model. The  assignment  of the finite elements to sets  may be based on geometrical proximity, topological connections, or some other characteristic. See the  \"mesh selection\" discussion for details.","category":"page"},{"location":"concepts/concepts.html#Structured-mesh-generation","page":"Concepts","title":"Structured mesh generation","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The simplest possible meshes can be generated in the form of one-dimensional, two-dimensional, and three-dimensional blocks. The spacing of the nodes can be either uniform (for instance Q8block), or the spacing can be given with an arbitrary distribution (for instance Q4blockx). Meshes of tetrahedra can be generated in various orientations of the \"diagonals\".","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"More complex meshes can be generated for certain element types: for instance an annulus (Q4annulus), quarter of a plate with a hole (Q4elliphole), quarter of a sphere (H8spheren), layered plate (H8layeredplatex).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Hexahedral meshes can also be created by extrusion of  quadrilateral meshes (H8extrudeQ4).","category":"page"},{"location":"concepts/concepts.html#Shaping","page":"Concepts","title":"Shaping","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Simple meshes  such as blocks can be deformed into geometrically complex shapes, for instance  by tapering  or other relocation of the nodes. For instance, we can generate a block  and then bend it  into one quarter  of  an annulus as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nfor i=1:count(fens)\n    r=rin+fens.xyz[i,1]; a=fens.xyz[i,2];\n    fens.xyz[i,:]=[r*cos(a) r*sin(a)];\nend","category":"page"},{"location":"concepts/concepts.html#Merging","page":"Concepts","title":"Merging","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Multiple mesh regions  can be generated and then merged together into a single mesh. Refer to the MeshModificationModule. Meshes can be also mirrored.","category":"page"},{"location":"concepts/concepts.html#Boundary-extraction","page":"Concepts","title":"Boundary extraction","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Mesh  composed of  any element type can be passed to the function  meshboundary, and  the boundary of the mesh is extracted. As an example, the code","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens,fes = Q4block(rex-rin,pi/2,5,20);\nbdryfes = meshboundary(fes);","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"generates a mesh of quadrilaterals in the set fes,  and bdryfes = meshboundary(fes) finds the boundary elements of the type L2 (line elements with two nodes) and stores them in the  finite element set bdryfes.","category":"page"},{"location":"concepts/concepts.html#Conversion-between-element-types","page":"Concepts","title":"Conversion  between element types","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For any element shape  (line, triangle,  quadrilateral, hexahedron, tetrahedron) there is  the linear version and the quadratic version. Conversion routines are provided so that, for example, mesh can be generated as eight-node  hexahedra  and then converted  to twenty-node hexahedra as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens, fes = H8toH20(fens, fes)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Other conversion routines can convert triangles to quadrilaterals, tetrahedra to hexahedra, and so on.","category":"page"},{"location":"concepts/concepts.html#Refinement","page":"Concepts","title":"Refinement","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Meshes composed of some  element types can be uniformly refined. For instance, quadrilateral meshes can be refined by bisection with Q4refine.","category":"page"},{"location":"concepts/concepts.html#Selection-of-mesh-entities","page":"Concepts","title":"Selection of mesh entities","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"There are many instances of problem definitions where it is important to partition meshes into subsets. As an example,  consider a tube consisting of inner ABS core and  outer fiber-reinforced  laminate  layer. The mesh may consist  of hexahedra.  This mesh would then need to be partitioned into two subsets, because the materials and the  material orientation data  are different between the two regions.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As another example, consider a simple beam  of rectangular cross-section, clamped  at one end,  and  loaded with shear tractions at the  free end. The  entire boundary of the beam needs to be separated  into three subsets:  the first subset,  for the traction-free boundary, is ignored. The second subset, for the clamped cross-section, is extracted  and  its nodes  are used  to  formulate the essential boundary condition. The third subset is extracted and used to define an FEM machine to compute the load vector due to the shear traction.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"There are  several  ways  in which mesh entities (nodes and finite elements) can be selected. The simplest uses element labels: some mesh-generation routines label the generated elements. For example,","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens,fes = H8layeredplatex(xs, ys, ts, nts)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"generates a plate-like mesh where the layers are labeled. It is therefore possible to select  the bottom-most layer as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"rls = selectelem(fens, fes, label = 1)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where rls is a list of integer indexes into the  set fes, so that we can extract a subset corresponding to this layer as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"botskin = subset(fes, rls)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Geometrical techniques for selecting finite elements  or nodes can be based on","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"the location within or overlap  with boxes;\ndistance from  a given point;\ndistance from a given plane;\nconnectedness (selection by flooding).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Additionally, surface-like  finite elements (quadrilaterals and triangles embedded in three dimensions), or lines embedded in two dimensions, can be selected based upon the orientation of their normal (facing  criterion).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As an example, consider a straight duct with anechoic termination. A triangle mesh is generated as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fens,fes  =  T3block(Lx,Ly,n,2);","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"and its boundary is extracted as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"bfes  =  meshboundary(fes)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The finite elements from the  piece of the boundary on the left parallel to the Y axis can be extracted as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"L0 = selectelem(fens,bfes,facing = true, direction = [-1.0 0.0])","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where the numbers of the finite elements  whose normals point in the general direction of the vector [-1.0 0.0] are returned in the integer array L0.","category":"page"},{"location":"concepts/concepts.html#Fields","page":"Concepts","title":"Fields","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The structure to maintain the numbering  and values of the degrees of freedom in the mesh  is the field. Consider for instance the temperature field: we write","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"T(x) = sum_i N_i(x) T_i","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The understanding is that T_i are the degrees of freedom, and the basis functions N_i(x) are defined implicitly by the finite element mesh. (More about basis functions below.) Each element has its own set of functions, which when multiplied by the degree of freedom values describe the temperature over each individual finite element. The basis functions are implicitly associated with the nodes of the finite elements. The degrees of freedom are also (explicitly) associated with the nodes. The field may also be generalized a bit by extending the above sum simply to entities of the mesh, not only the nodes, but perhaps also the elements.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The role of the field is then to maintain the correspondence between the entities and the numbers and values of the degrees of freedom.","category":"page"},{"location":"concepts/concepts.html#Abstract-Field","page":"Concepts","title":"Abstract  Field","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The assumption is that a field has one set of degrees of freedom per node or per element. For simplicity we will refer to the nodes and elements as entities. It assumes that concrete  subtypes of the abstract field  have the following data, one row per entity:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"values::FMat{T}: Array of the values of the degrees of freedom, one row  for each entity. All the arrays below have the same dimensions as this one.\ndofnums::FIntMat: Array  of the numbers of the free degrees of freedom. First the free degrees of freedom are numbered, then the fixed (prescribed) degrees of freedom.\nis_fixed::Matrix{Bool}: Array of  Boolean flags,  true for fixed  (prescribed) degrees of freedom, false otherwise.\nfixed_values::FMat{T}: Array  of the same size and type  as  values. Its entries are only relevant  for the fixed (prescribed)  degrees of freedom.\nnalldofs::FInt:  the total number of all degrees of freedom.\nnfreedofs::FInt:  the total number of free degrees of freedom.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The methods defined for the abstract field  include:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Return the number of degrees of freedom and the number of entities.\nGather and scatter the system vector.\nGather elementwise  vectors or matrices of values, the degree of freedom numbers, or the fixed values of the degrees of freedom.\nSet  or clear essential boundary conditions.\nCopy a field. Clear the entries of the field.","category":"page"},{"location":"concepts/concepts.html#Nodal-Field","page":"Concepts","title":"Nodal Field","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"In this case  the  abstract field is subtyped to a concrete field where the entities are nodes.","category":"page"},{"location":"concepts/concepts.html#Elemental-Field","page":"Concepts","title":"Elemental Field","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are the elements.","category":"page"},{"location":"concepts/concepts.html#General-Field","page":"Concepts","title":"General Field","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"In this case  the  abstract field  is subtyped to a concrete field where the entities are  use-case  specific.","category":"page"},{"location":"concepts/concepts.html#Numbering-of-the-degrees-of-freedom","page":"Concepts","title":"Numbering of the degrees of freedom","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The simplest method is at the moment implemented: number all free degrees of freedom, row-by-row and column-by-column, starting from 1 up to nfreedofs(f), for the field f.  Then number the prescribed degrees of freedom are numbered, up to nalldofs(f).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"There is also a method to supply the numbering of the nodes, perhaps  resulting from the Reverse Cuthill-McKee permutation. This may be useful when using LU or LDLT factorization as the fill-in may be minimized.","category":"page"},{"location":"concepts/concepts.html#Finite-element","page":"Concepts","title":"Finite element","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The  finite element set is one of the basic entities in FinEtools. It is a homogeneous collection of  finite elements defined by the connectivity (collection of node numbers, listing the nodes connected by the element in  a specific order). The finite element set  provides  specialized methods  to compute the values of basis functions and the values of  the gradients of the basis functions  with respect to the parametric coordinates.","category":"page"},{"location":"concepts/concepts.html#Element-types","page":"Concepts","title":"Element types","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The finite element sets are instances of concrete types. Each particular shape and order of element has its own type. There are types for  linear  and quadratic quadrilaterals, for instance, FESetQ4 and FESetQ8. Each element set provides access to the number of nodes  connected by the element (nodesperelem),  the connectivity as the two dimensional array    conn,  and the  integer label vector label.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The concrete finite element set types are subtypes of the abstract type for elements of different manifold dimension (3, 2, 1, and 0), for instance for the quadrilaterals that would be AbstractFESet2Manifold. These types are in turn  subtypes of the abstract finite element set type AbstractFESet.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The concrete finite element set type provides specialized methods to compute the values of the basis functions, bfun, and methods to compute  the gradients of the basis functions with respect to the parametric coordinates, bfundpar. FinEtools at the moment supports only the so-called nodal basis functions: each basis function is associated with a node. And that is  true both globally (in the sense that each basis function is globally supported),  and locally over each finite element, and all such functions are  1 at its own node, and zero at all the other nodes.","category":"page"},{"location":"concepts/concepts.html#Finite-element-set-functions","page":"Concepts","title":"Finite element set functions","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Methods defined for  the abstract type:\nnodesperelem: Get the number of nodes  connected  by  the finite element.\ncount:  Get the number of individual connectivities in the FE set.\nsetlabel!: Set the label of the entire finite elements set.\nconnasarray: Retrieve  connectivity  as an integer array.\nfromarray!: Set  connectivity from an integer array.\nsubset: Extract a subset of the finite elements from the given finite element set.\ncat: Concatenate the connectivities of two FE sets.\nupdateconn!: Update the connectivity after the IDs of nodes changed.\nmap2parametric: Map a spatial location to parametric coordinates.\nMethods dispatched based on the manifold type:\nmanifdim: Return the manifold dimension.\nJacobian: Evaluate the  Jacobian.\ngradN!: Compute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\nMethods dispatched on the concrete type:\nboundaryconn: Get boundary connectivity.\nboundaryfe: Return the constructor of the type of the boundary finite element.\nbfun: Compute the values of the basis functions at a given parametric coordinate.\nbfundpar: Compute the values of the basis function gradients at a given parametric coordinate.\ninparametric: Are given parametric coordinates inside the element parametric domain?\ncentroidparametric: Return the parametric coordinates  of the centroid of the element.","category":"page"},{"location":"concepts/concepts.html#Integration","page":"Concepts","title":"Integration","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"There are two kinds of integrals in the weighted-residual finite element method: integrals over the interior  of the domain,  and integrals over the boundary of the domain.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Consequently, in a typical simulation one would need  two meshes: one for the interior  of the domain,  and one for the boundary. Obviously, the mesh for the boundary will be derived from the mesh  constructed for the interior.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Often only a part  of the entire boundary   is   used:  on some parts of the boundary  the  boundary condition is implied as homogeneous (i. e. zero). For instance, a traction-free boundary. Therefore the necessary integrals are typically evaluated over a subset of the entire boundary.","category":"page"},{"location":"concepts/concepts.html#Manifold-dimension","page":"Concepts","title":"Manifold dimension","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Finite elements  have  a certain manifold dimension.  Tetrahedra  and hexahedra are three-manifolds, triangles and quadrilaterals are two-manifolds, triangles and quadrilaterals are two-manifolds, lines are one-manifolds, and points are zero-manifolds.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Elements are equipped with an \"other\" dimension attribute which boosts the manifold dimension to produce the required dimension for  the integration. For instance,  a line element can be equipped with an \"other\" dimension to represent a cross-section so that a volume integral can be evaluated over a line element. Or, a line element can be given an \"other\" dimension as a thickness to result in a physical dimension needed to evaluate a surface integral.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The \"other\"  dimension  has the following meaning  for finite elements of different manifold dimensions:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Manifold dimension Volume integral Surface integral\n3 NA NA\n2 Thickness NA\n1 Cross-section Thickness\n0 Volume Cross-section","category":"page"},{"location":"concepts/concepts.html#Integration-over-the-interior","page":"Concepts","title":"Integration  over the interior","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The integrals are always  volume integrals. This means that for elements which are of  lower manifold dimension than three the \"other\"  dimension needs to compensate.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For  three-manifold finite elements (tetrahedra and hexahedra) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a volume-like element.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For  finite elements of manifold dimension  less than tthree, the  \"other\" dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Manifold dimension Axially symmetric Plane 2D\n2 2pi r Thickness\n1 2pi rtimes  Thickness Cross-section\n0 2pi rtimes Cross-section Volume","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_Omega f dV approx sum_q f(xi_q) J(xi_q) W_q","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Here f  is the integrand, f(xi_q)  is the  value of the integrand  at the quadrature point, J(xi_q)  is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension, and therefore it is the  volume Jacobian. (For the interior integrals the Jacobian  is computed by the Jacobianvolume method.)","category":"page"},{"location":"concepts/concepts.html#Integration-over-the-boundary","page":"Concepts","title":"Integration  over the boundary","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The integrals are always  surface integrals. This means that for elements which are of  lower manifold dimension than two the \"other\"  dimension needs to compensate.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For  two-manifold finite elements (triangles and quadrilaterals) the \"other\" dimension is always 1.0. This really means there is no \"other\" dimension to a surface-like element.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For  finite elements of manifold dimension  less than two, the  \"other\" dimension varies according to the model (axially symmetric versus simple  plane 2D) as shown  in the table below.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Manifold dimension Axially symmetric Plane 2D\n1 2pi r Thickness\n0 2pi rtimes   Thickness Cross-section","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The integral  is approximated with numerical quadrature as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_partial Omega f dS approx sum_q f(xi_q) J(xi_q) W_q  ","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Here f  is the integrand, f(xi_q) is the  value of the integrand  at the quadrature point, J(xi_q) is the  value of the Jacobian  at the quadrature point. Importantly, the Jacobian incorporates the \"other\" dimension, and therefore it is the  surface Jacobian. (For the boundary integrals the Jacobian  is computed by the Jacobiansurface method.)","category":"page"},{"location":"concepts/concepts.html#Example:-axially-symmetric-model,-line-element-L2","page":"Concepts","title":"Example: axially symmetric model, line element L2","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The surface Jacobian in this case  is  equal to the curve Jacobian times 2*pi*r.","category":"page"},{"location":"concepts/concepts.html#Integration-Domain","page":"Concepts","title":"Integration Domain","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As explained above, integrating over the interior or the boundary may mean different things based on the features of the solution domain: axially symmetric?, plane strain or plane stress?, and so forth.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The  module IntegDomainModule supports  the processing of  the geometry necessary for the evaluation of the various integrals. The module data structure  groups together  a finite element set with an appropriate integration rule, information about the model (axially symmetric or not), and a callback to evaluate  the \"other\" dimension.","category":"page"},{"location":"concepts/concepts.html#Other-dimension","page":"Concepts","title":"Other dimension","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The  discussion of the surface and volume integrals introduces the notion  of the  \"other\"  dimension. In order to evaluate Jacobians of various space dimensions  the  Geometry Data module takes into account  whether or not the model is axially symmetric, and evaluates the \"other\" dimension based upon this information.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"A finite element set is equipped with  a way of  calculating  the \"other\" dimension.  For instance, the line element with two nodes, L2, can be given  the \"other\" dimension  as a  \"thickness\"  so that  surface integrals  can be evaluated over the line element. However, if this line element  is used in an axially symmetric model, the same  \"other\" dimension  of \"thickness\"  will result in the integral  along the length of this line element  being a volume integral.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Thus, the way in which the \"other\"  dimension gets used by the integration domain methods depends on the model. As an example, consider  the  method","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"function Jacobianvolume(self::IntegDomain{T}, J::FFltMat, loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {T<:AbstractFESet2Manifold, CC<:AbstractArray{FInt}}\n    Jac = Jacobiansurface(self, J, loc, conn, N)::FFlt\n    if self.axisymmetric\n        return Jac*2*pi*loc[1];\n    else\n        return Jac*self.otherdimension(loc, conn,  N)\n    end\nend","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"which  evaluates the volume Jacobian  for an element  of manifold dimension  2  (surface). Note that  first  the surface Jacobian  is calculated, which is then boosted to a volume Jacobian in two different ways, depending on whether  the model is axially symmetric or not. For the axially symmetric case  the \"other\"  dimension is implied,","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The callback function computes the \"other\" dimension from  two kinds of  information: (a) the physical location  of the quadrature point,  and (b) the interpolation data for the element  (connectivity and the values of the basis functions at the quadrature point).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The approach ad (a) is suitable  when the \"other\" dimension is given as a function of the physical coordinates. The  simplest case is obviously  a uniform distribution of the \"other\" dimension. When  no  callback is explicitly provided,  the  \"other\"  dimension  callback is  automatically generated as the trivial","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"function otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt where {CC<:AbstractArray{FInt}}\n    return 1.0\nend","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"which simply returns 1.0 as the default value.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The approach ad (b) is appropriate when the \"other\" dimension  is given by values given at the nodes of the  mesh. Than the connectivity  and  the array of the values of the basis functions  can be used to interpolate the \"other\"  dimension  to the quadrature point.","category":"page"},{"location":"concepts/concepts.html#Evaluation-of-integration-data","page":"Concepts","title":"Evaluation of integration data","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Importantly, the  Integration Domain (IntegDomain) method integrationdata evaluates quantities  needed for numerical integration: locations and weights of quadrature points, and the values of basis functions and of the basis function gradients with respect to the parametric coordinates at the quadrature points.","category":"page"},{"location":"concepts/concepts.html#FEM-machines","page":"Concepts","title":"FEM machines","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The construction of the matrices and vectors of the discrete form of the weighted residual equation is performed in FEM  machines. (FEM = Finite Element Method.)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"As an example consider the weighted-residual form of the heat balance equation","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_V  vartheta c_Vfracpartial Tpartial t  mathrmd V\n            +int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V\n            -int_V  vartheta Q  mathrmd V  \n            +int_S_2 varthetaoverlineq_n mathrmd S+ int_S_3 varthetah\n            (T-T_a)   mathrmd S = 0","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where vartheta(x) =0  for  x inS_1 .","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The  test function is  taken to be  one  finite element basis function at a time, vartheta = N_j, and the trial function is","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"T = sum_i= 1 ^N N_i T_i ","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Here by N_j we mean the basis function constructed on the mesh and associated with the node where the degree of freedom j is situated. ","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Now the test function and the trial function is substituted  into the  weighted residual equation.  ","category":"page"},{"location":"concepts/concepts.html#Example:-internal-heat-generation-rate-term","page":"Concepts","title":"Example:  internal heat generation rate term","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For instance,  for the term","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_V  vartheta Q  mathrmd V","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"we obtain","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_V N_j Q  mathrmd V","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"This integral evaluates to a number, the heat load  applied to the degree of freedom j. When these numbers are evaluated for all  the free degrees of freedom,  they constitute the entries of the global heat load vector.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Evaluating integrals of this form is so common that there is a module FEMMBaseModule with the method distribloads that computes and assembles the global vector. For instance to evaluate this heat load vector  on the mesh composed of three-node triangles, for a uniform heat generation rate Q, we can write","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"fi = ForceIntensity(FFlt[Q]);\nF1 = distribloads(FEMMBase(IntegDomain(fes, TriRule(1))), geom, tempr, fi, 3);","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"IntegDomain(fes, TriRule(1)) constructs integration domain for the  finite elements fes using a triangular  integration rule with a single point. FEMMBase is the base  FEM  machine,  and all it needs at this point is the integration domain. The method  distribloads is defined for the  base FEM machine, the geometry field geom, the numbering of the degrees of freedom is taken from the field tempr, the internal heat generation rate is defined as the force intensity fi, and the integrals  are volume integrals  (3).","category":"page"},{"location":"concepts/concepts.html#Example:-conductivity-term","page":"Concepts","title":"Example: conductivity term","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The conductivity term from the weighted residual equation","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"int_V(mathrmgradvartheta) kappa (mathrmgradT\n            )^T mathrmd V","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"is rewritten with the test and trial functions as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"sum_i=1^N int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The sum over the degree of freedom number i should be split: some of the  coefficients T_i are for free degrees of freedom (1 le i le  N_mathrmf, with N_mathrmf being the total number of free degrees of freedom), while some are  fixed (prescribed) for nodes  which are located on the essential boundary condition surface S_1  (N_mathrmf  i le N).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Thus the term splits into two  pieces,","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"sum_i=1^N_mathrmf int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where the  individual integrals are entries of the conductivity matrix, and","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"sum_i=N_mathrmf+1^N int_V(mathrmgradN_j) kappa (mathrmgradN_i\n            )^T mathrmd V  T_i","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"which  will represent heat loads  due to nonzero  prescribed boundary condition.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The FEM machine  for the heat conduction problem can be created as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"material = MatHeatDiff(thermal_conductivity)\nfemm = FEMMHeatDiff(IntegDomain(fes, TriRule(1)), material)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where we first create a material to  provide access to the thermal conductivity matrix kappa, and then  we create  the FEM  machine  from the integration domain  for a mesh  consisting of three node triangles, using one-point integration rule, and the material. This  FEM machine  can then be passed to a method, for instance the calculate the global conductivity matrix K","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"K = conductivity(femm, geom, Temp)","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom. Note that the global conductivity matrix is square, and of size N_mathrmftimesN_mathrmf. In other words, it is only for the degrees of freedom that are free (actual unknowns).","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The heat load term  due to the  nonzero essential boundary conditions  is evaluated with the method nzebcloadsconductivity","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"F2 = nzebcloadsconductivity(femm, geom, Temp);","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"where the geometry comes from the geometry field geom, and the temperature field Temp provides the  numbering of the degrees of freedom and the values of the prescribed (fixed) degrees of freedom. The result is a contribution to the global heat load vector. ","category":"page"},{"location":"concepts/concepts.html#Base-FEM-machine","page":"Concepts","title":"Base FEM machine","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The following  operations are provided  by the base FEM machine:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Integrate  a function expressed in terms of a field. This is typically used to evaluate RMS discretization errors.\nIntegrate a function of the position. Perhaps the evaluation of the moments of inertia,  or the calculation of the volume.\nTransfer field between meshes of different resolutions.\nCalculate  the distributed-load system vector.\nConstruct a field  from integration-point quantities. This is typically used in the postprocessing phase, for instance to construct continuous distribution of stresses in the structure.","category":"page"},{"location":"concepts/concepts.html#Material-and-Material-Orientation","page":"Concepts","title":"Material and Material Orientation","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The material response  is described in  material-point-attached coordinate system. These coordinate systems  are Cartesian, and the material coordinate system is typically chosen to make  the response particularly simple.  So for orthotropic or transversely isotropic materials the axes would be aligned with the axes of orthotropy.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The type CSys (module CSysModule) is the updater of the material coordinate system matrix. The object is equipped with a callback to store the current orientation matrix. For instance: the coordinate system for an orthotropic material wound around a cylinder could be described in the coordinate system CSys(3, 3, updatecs!), where the callback updatecs! is defined as","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"function updatecs!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)\n    csmatout[:, 2] = [0.0 0.0 1.0]\n    csmatout[:, 3] = XYZ\n    csmatout[3, 3] = 0.0\n    csmatout[:, 3] = csmatout[:, 3]/norm(csmatout[:, 3])\n    csmatout[:, 1] = cross(csmatout[:, 2], csmatout[:, 3])\nend","category":"page"},{"location":"concepts/concepts.html#Algorithms","page":"Concepts","title":"Algorithms","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Algorithms typically (not always) accept a single argument, modeldata, a dictionary of data, keyed by Strings. Algorithms  also return modeldata,  typically  including additional key/value pairs that represent the data computed by the algorithm.","category":"page"},{"location":"concepts/concepts.html#Base-algorithms","page":"Concepts","title":"Base algorithms","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"These are not specific to the particular physics at hand. Examples of  algorithms are  Richardson extrapolation,  calculation of the norm of the field, or calculation of the norm  of the difference of two fields. These algorithms are the exceptions, they do not return modeldata but rather return directly computed values.","category":"page"},{"location":"concepts/concepts.html#Model-data","page":"Concepts","title":"Model data","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.","category":"page"},{"location":"concepts/concepts.html#Queries-of-quadrature-point-data","page":"Concepts","title":"Queries of quadrature-point data","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"A number of quantities exist at integration (quadrature) points. For instance for heat conduction this data may refer to the temperature gradients and heat flux vectors. In stress analysis, such data would typically be stress invariants  or stress components.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"How this data is calculated at the quadrature point obviously varies depending on the element type. Not only on the element order, but the element formulation may invoke rules other than those of simple gradient-taking: take as an example mean-strain  elements, which define strains by using averaging rules over the entire element, so not looking at a single integration point only.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"For this purpose, FinEtools has ways of defining implementations of the function inspectintegpoints to take into account the particular features of the various finite element formulations. Each FEMM typically defines its own specialized method. ","category":"page"},{"location":"concepts/concepts.html#Postprocessing","page":"Concepts","title":"Postprocessing","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"One way in which quadrature-point data is postprocessed into graphical means is by constructing node-based fields. For instance, extrapolating quadrature-point data to the nodes is commonly done in finite element programs. This procedure is typically referred to as \"averaging at the nodes\". The name implies that not only the quadrature-point data is extrapolated to the nodes of the element, but since each element incident on a node may have predicted (extrapolated) a different value of a quantity (for example stress), these different values need to be somehow reconciled, and averaging, perhaps weighted averaging, is the usual procedure.","category":"page"},{"location":"concepts/concepts.html#Compute-continuous-stress-fields","page":"Concepts","title":"Compute continuous stress fields","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Individual FEMMs may have different ways of extrapolating to the nodes. These are implemented in various methods of the function fieldfromintegpoints. The resulting field represents quadrature-point data as a nodal field, where the degrees of freedom are extrapolated values to the nodes.","category":"page"},{"location":"concepts/concepts.html#Compute-elementwise-stress-fields","page":"Concepts","title":"Compute elementwise stress fields","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Most finite element postprocessing softwares find it difficult to present results which are discontinuous at inter-element boundaries. Usually the only way in which data based on individual elements with no continuity across element boundaries is presented is by taking an average over the entire element and represent the values as uniform across each element. Various methods of the function elemfieldfromintegpoints produce elemental fields of this nature.","category":"page"},{"location":"concepts/concepts.html#Import/export","page":"Concepts","title":"Import/export","text":"","category":"section"},{"location":"concepts/concepts.html#Importing","page":"Concepts","title":"Importing","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"At the moment importing is mostly limited to the mesh data (properties, boundary conditions, analysis of data, etc. are typically not imported). The following formats of finite element input files can be handled:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"NASTRAN (.nas files).\nAbaqus (.inp files).","category":"page"},{"location":"concepts/concepts.html#Exporting","page":"Concepts","title":"Exporting","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"VTK (.vtk so-called legacy files). Export of geometry and fields (nodal and elemental) is supported.\nAbaqus (.inp files). Mesh data and selected property, boundary condition, and procedure commands can be handled.\nNASTRAN (.nas files). Very basic mesh and select other attributes are handled.\nSTL file export of surface data.\nH2Lib triangular-surface export (.tri files).\nCSV file export of numerical data is supported.","category":"page"},{"location":"concepts/concepts.html#Tutorials-and-Examples","page":"Concepts","title":"Tutorials and Examples","text":"","category":"section"},{"location":"concepts/concepts.html#Tutorials","page":"Concepts","title":"Tutorials","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The FinEtools tutorials are written up in the repositories for the applications, heat diffusion, linear and nonlinear deformation and so on.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The tutorials are in the form of Julia files with markdown. These are converted to markdown files using the Literate workflow.","category":"page"},{"location":"concepts/concepts.html#Examples","page":"Concepts","title":"Examples","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The examples of the use of the FinEtools package are separated in their own separate repositories, for instance  FinEtoolsHeatDiff, FinEtoolsAcoustics, and so on. For a complete information refer to the list of the repositories.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The examples are in the form of  Julia files with multiple functions, where each function defines one or more related examples. Take for instance the example file Fahy_examples.jl. This incantation will run all the examples from the example file:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"include(\"Fahy_examples.jl\"); Fahy_examples.allrun()","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"This will run just a single example from this file:","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"include(\"Fahy_examples.jl\"); Fahy_examples.fahy_H8_example()","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The example file Fahy_examples.jl consists of a module (whose name matches the name of the file), and  the module defines multiple functions,  one for each example, and one to run all examples, allrun.","category":"page"},{"location":"concepts/concepts.html#Tests","page":"Concepts","title":"Tests","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Check out the numerous tests in the test folder. There are hundreds of tests which exercise the various functions of the library. These examples may help you understand how to extract the desired outcome.","category":"page"},{"location":"concepts/concepts.html#Make-up-your-own-public-interface","page":"Concepts","title":"Make up your own public interface","text":"","category":"section"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Here we assume that the FinEtools package is installed. We also assume the user works in his or her own folder, which for simplicity we assume is a package folder in the same tree as the package folder for FinEtools.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The user may have his or her additions to the FinEtools library, for instance a new material implementation, or a new FEMM (finite element model machine). Additionally, the user writes some code to solve particular problems.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"In order to facilitate interactive work at the command line(REPL), it is convenient to have one or two modules so that using them allows for the user's code to resolve function names from the FinEtools package and from the user's own code.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Here are two ways in which this can be accomplished.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"The user exports his or her own additions from the module add2FinEtools (the name of this module is not obligatory, it can be anything). In addition, the public interface to the FinEtools package needs to be brought in separately.\nusing FinEtools  using add2FinEtools\nThe user may change entirely the public interface to the FinEtools package by selectively including parts of the FinEtools.jl file and the code to export his or her own functionality in a single module, let us say myFinEtools (this name is arbitrary), so that when the user invokes\nusing myFinEtools\nall the functionality that the USER considers to be public is made available by exports.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Method 1 has the advantage that the interface definition of the FinEtools package itself does not change, which means that package code does not need to be touched. It also has a disadvantage that the interface to FinEtools does not change which means that if there is a conflict with one of the exported functions from FinEtools, it needs to be resolved by fiddling with other packages.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"Method 2 has the advantage that when there is a conflict between one of the exported FinEtools functions and some other function, be it from another package or the user's own, the conflict can be resolved by changing the public interface to FinEtools by the USER (as opposed to  by the DEVELOPER). Also, in this method the USER has the power to define the public interface to the FinEtools package, and if the user decides that nothing should be exported for implicit resolution of functions, that is easily accomplished.","category":"page"},{"location":"concepts/concepts.html","page":"Concepts","title":"Concepts","text":"These two methods have been described by examples in the FinEtoolsUseCase package. Refer to the Readme  file and to the method descriptions  in the  method 1 and 2 folders.","category":"page"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Table of contents","category":"page"},{"location":"tutorials/tutorials.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"[Needs to be written]","category":"page"},{"location":"howto/howto.html","page":"How to","title":"How to","text":"Table of contents","category":"page"},{"location":"howto/howto.html#How-to","page":"How to","title":"How to","text":"","category":"section"},{"location":"howto/howto.html","page":"How to","title":"How to","text":"[Needs to be written]","category":"page"},{"location":"index.html#FinEtools-(Finite-Element-tools)-Documentation","page":"Home","title":"FinEtools (Finite Element tools) Documentation","text":"","category":"section"},{"location":"index.html#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FinEtools is a package for basic operations on finite element meshes: Construction, modification, selection, and evaluation of quantities defined on a mesh. Utilities are provided for maintaining mesh-based data (fields), for defining normals and loads, for working with physical units and coordinate systems, and for integrating over finite element meshes. ","category":"page"},{"location":"index.html#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":" Learning Working\nPractical Tutorials How to\nTheoretical Concepts Reference","category":"page"},{"location":"man/man.html","page":"Reference","title":"Reference","text":"Table of contents","category":"page"},{"location":"man/man.html#Reference-Manual","page":"Reference","title":"Reference Manual","text":"","category":"section"},{"location":"man/man.html","page":"Reference","title":"Reference","text":"Functions\nTypes","category":"page"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#Contents","page":"Functions","title":"Contents","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]\nDepth = 3","category":"page"},{"location":"man/functions.html#Physical-units","page":"Functions","title":"Physical units","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.PhysicalUnitModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.PhysicalUnitModule.phun-Tuple{String}","page":"Functions","title":"FinEtools.PhysicalUnitModule.phun","text":"phun(str::String; system_of_units = :SI, base_time_units = :SEC)\n\nEvaluate an expression in physical units.\n\nInputs: –system_of_units\n\nif system_of_units  ==  :US\n   basic assumed units are American Engineering:\n   LENGTH = FT, TIME = SEC, MASS = SLUG TEMPERATURE = RAN FORCE = LB\nelseif system_of_units  ==  :CGS\n   basic assumed units are Centimeter,Gram,Second:\n   LENGTH = CM, TIME = SEC, MASS = GM TEMPERATURE = K FORCE = DYNE\nelseif system_of_units  ==  :IMPERIAL\n   basic assumed units are Imperial:\n   LENGTH = FT, TIME = SEC, MASS = SLUG TEMPERATURE = RAN FORCE = LB\notherwise,\n   basic assumed units are :SIM (equivalent to :SI, default):\n   LENGTH = M , TIME = SEC, MASS = KG   TEMPERATURE = K   FORCE = N\n\n–base_time_units defaults to :SEC\n\nExample\n\npu = ustring -> phun(ustring; system_of_units = :SIMM)\nE1s = 130.0*pu(\"GPa\")\n\nyields 1.3e+5 (in mega Pascal) whereas\n\n130.0*phun(\"GPa\"; system_of_units = :SI)\n\nyields 1.3e+11 (in Pascal)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Bounding-box-functions","page":"Functions","title":"Bounding box functions","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.BoxModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.boundingbox","text":"boundingbox(x::AbstractArray)\n\nCompute the bounding box of the points in x.\n\nx = holds points, one per row.\n\nReturns box = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.boxesoverlap-Tuple{AbstractVector, AbstractVector}","page":"Functions","title":"FinEtools.BoxModule.boxesoverlap","text":"boxesoverlap(box1::AbstractVector, box2::AbstractVector)\n\nDo the given boxes overlap?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.inbox-Tuple{AbstractVector, AbstractVector}","page":"Functions","title":"FinEtools.BoxModule.inbox","text":"inbox(box::AbstractVector, x::AbstractVector)\n\nIs the given location inside the box?\n\nbox = vector entries arranged as minx,maxx,miny,maxy,minz,maxz.\n\nNote: point on the boundary of the box is counted as being inside.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.inflatebox!-Union{Tuple{T}, Tuple{AbstractVector, T}} where T","page":"Functions","title":"FinEtools.BoxModule.inflatebox!","text":"inflatebox!(box::AbstractVector, inflatevalue::T) where {T}\n\nInflate the box by the value supplied.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.initbox!-Tuple{AbstractVector, AbstractVector}","page":"Functions","title":"FinEtools.BoxModule.initbox!","text":"initbox!(box::AbstractVector, x::AbstractVector)\n\nInitialize a bounding box with a single point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.intersectboxes-Tuple{AbstractVector, AbstractVector}","page":"Functions","title":"FinEtools.BoxModule.intersectboxes","text":"intersectboxes(box1::AbstractVector, box2::AbstractVector)\n\nCompute the intersection of two boxes.\n\nThe function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.BoxModule.updatebox!-Tuple{AbstractVector, AbstractArray}","page":"Functions","title":"FinEtools.BoxModule.updatebox!","text":"updatebox!(box::AbstractVector, x::AbstractArray)\n\nUpdate a box with another location, or create a new box.\n\nIf the  box does not have  the correct dimensions,  it is correctly sized.\n\nbox = bounding box     for 1-D box=[minx,maxx], or     for 2-D box=[minx,maxx,miny,maxy], or     for 3-D box=[minx,maxx,miny,maxy,minz,maxz]     The box is expanded to include the     supplied location x.   The variable x  can hold multiple points in rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Coordinate-systems","page":"Functions","title":"Coordinate systems","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.CSysModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.CSysModule.csmat-Tuple{CSys}","page":"Functions","title":"FinEtools.CSysModule.csmat","text":"csmat(self::CSys)\n\nReturn coordinate system rotation matrix.\n\nNo allocation is involved.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.CSysModule.gen_iso_csmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}","page":"Functions","title":"FinEtools.CSysModule.gen_iso_csmat!","text":"gen_iso_csmat!(csmatout::Matrix{T}, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T, IT}\n\nCompute the coordinate system  for an isotropic material using information available  by looking at the coordinate curves of isoparametric finite elements.\n\nXYZ= location  in physical coordinates,\ntangents= tangent vector matrix, tangents to the parametric coordinate curves  in the element,\nfeid= finite element identifier;\nqpid = quadrature point identifier.\n\nThe basic assumption here is that the material is isotropic, and therefore the choice of the material directions does not really matter as long as they correspond to the dimensionality of the element. For instance a one-dimensional element (L2 as an example) may be embedded in a three-dimensional space.\n\nThis function assumes that it is being called for an mdim-dimensional manifold element, which is embedded in a sdim-dimensional Euclidean space. If mdim == sdim, the coordinate system matrix is the identity; otherwise the local coordinate directions are aligned with the linear subspace defined by the tangent vectors.\n\nwarning: Warning\nThis cannot be reliably used to produce consistent stresses because each quadrature point gets a local coordinate system which depends on the orientation of the element, in general different from the neighboring elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.CSysModule.updatecsmat!-Union{Tuple{IT2}, Tuple{IT1}, Tuple{T}, Tuple{CSys, Matrix{T}, Matrix{T}, IT1, IT2}} where {T, IT1, IT2}","page":"Functions","title":"FinEtools.CSysModule.updatecsmat!","text":"updatecsmat!(self::CSys,\n    XYZ::Matrix{T},\n    tangents::Matrix{T},\n    feid::IT1,\n    qpid::IT2) where {T, IT1, IT2}\n\nUpdate the coordinate system orientation matrix.\n\nThe  coordinate system matrix is updated based upon the location XYZ of the evaluation point, and possibly on the Jacobian matrix tangents within the element in which the coordinate system matrix is evaluated,  or perhaps on the identifier feid of the finite element and/or the quadrature point identifier.\n\nAfter this function returns, the coordinate system matrix can be read in the buffer as self.csmat.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Matrix-utilities","page":"Functions","title":"Matrix utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatrixUtilityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_b1tdb2!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_b1tdb2!","text":"add_b1tdb2!(\n    Ke::Matrix{T},\n    B1::Matrix{T},\n    B2::Matrix{T},\n    Jac_w::T,\n    D::Matrix{T},\n    DB2::Matrix{T},\n) where {T}\n\nAdd the product  (B1'*(D*(Jac_w))*B2), to the matrix Ke.\n\nThe matrix Ke is assumed to be suitably initialized: the results of this computation are added. The matrix Ke may be rectangular.\n\nThe matrix D may be rectangular.\n\nThe matrix Ke is modified.  The matrices B1, B2, and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btdb_ut_only!","text":"add_btdb_ut_only!(Ke::Matrix{T}, B::Matrix{T}, Jac_w::T, D::Matrix{T}, DB::Matrix{T}) where {T}\n\nAdd the product  (B'*(D*(Jac*w[j]))*B), to the matrix Ke.\n\nOnly upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrices B and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_btsigma!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, T, Vector{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_btsigma!","text":"add_btsigma!(Fe::Vector{T}, B::Matrix{T}, coefficient::T, sigma::Vector{T}) where {T}\n\nAdd the product  B'*(sigma*coefficient), to the elementwise vector Fe.\n\nThe vector Fe is assumed to be suitably initialized.\n\nThe vector Fe is modified.  The vector sigma is not modified inside this function. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Matrix{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_gkgt_ut_only!","text":"add_gkgt_ut_only!(\n    Ke::Matrix{T},\n    gradN::Matrix{T},\n    Jac_w::T,\n    kappa_bar::Matrix{T},\n    kappa_bargradNT::Matrix{T},\n) where {T}\n\nAdd the product gradN*kappa_bar*gradNT*(Jac*w[j]) to the matrix Ke.\n\nOnly upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nUpon return,  the matrix Ke is updated.  The scratch buffer kappa_bargradNT is overwritten during each call of this function. The matrices gradN and kappa_bar are not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Union{Tuple{T}, Tuple{MT}, Tuple{Matrix{MT}, Matrix{T}, Any}} where {MT, T}","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_mggt_ut_only!","text":"add_mggt_ut_only!(Ke::Matrix{T}, gradN::Matrix{T}, mult) where {T}\n\nAdd the product gradN*mult*gradNT to the matrix Ke.\n\nThe argument mult is a scalar. Only upper triangle is computed; the lower triangle is not touched. (Use complete_lt! to complete the lower triangle, if needed.)\n\nThe matrix Ke is assumed to be suitably initialized.\n\nThe matrix Ke is modified.  The matrix gradN is not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_n1n2t!-Union{Tuple{T}, Tuple{Matrix{T}, VecOrMat{T}, VecOrMat{T}, T}} where T<:Number","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_n1n2t!","text":"add_n1n2t!(Ke::Matrix{T}, N1::Matrix{T}, N2::Matrix{T}, Jac_w_coeff::T) where {T<:Number}\n\nAdd the product  N1*(N2'*(coeff*(Jac*w(j))), to the matrix Ke.\n\nThe matrix Ke is assumed to be suitably initialized. The matrices N1 and N2 have a single column each.\n\nThe matrix Ke is modified.  The matrix N1 and N2 are  not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T}} where T<:Number","page":"Functions","title":"FinEtools.MatrixUtilityModule.add_nnt_ut_only!","text":"add_nnt_ut_only!(Ke::Matrix{T}, N::Matrix{T}, Jac_w_coeff::T) where {T<:Number}\n\nAdd the product  Nn*(Nn'*(coeff*(Jac*w(j))), to the matrix Ke.\n\nOnly the upper triangle is computed; the lower triangle is not touched.\n\nThe matrix Ke is assumed to be suitably initialized. The  matrix Nn has a single column.\n\nThe matrix Ke is modified.  The matrix Nn is not modified inside this function.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.adjugate3!","text":"adjugate3!(B, A)\n\nCompute the adjugate matrix of 3x3 matrix A.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.complete_lt!-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.complete_lt!","text":"complete_lt!(Ke::Matrix{T}) where {T}\n\nComplete the lower triangle of the elementwise matrix Ke.\n\nThe matrix Ke is modified  inside this function. The upper-triangle  entries  are copied  across the diagonal to the lower triangle.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.detC-Union{Tuple{T}, Tuple{Val{3}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.detC","text":"detC(::Val{3}, C::Matrix{T})\n\nCompute determinant of 3X3 C.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.export_sparse-Tuple{Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.export_sparse","text":"export_sparse(filnam, M)\n\nExport sparse matrix to a text file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.import_sparse-Tuple{Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.import_sparse","text":"import_sparse(filnam)\n\nImport sparse matrix from a text file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.jac!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.jac!","text":"jac!(J::Matrix{T}, ecoords::Matrix{T}, gradNparams::Matrix{T}) where {T}\n\nCompute the Jacobian matrix at the quadrature point.\n\nArguments: J = Jacobian matrix, overwritten  inside the function ecoords = matrix of the node coordinates for the element. gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.loc!-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.loc!","text":"loc!(loc::Matrix{T}, ecoords::Matrix{T}, N::Matrix{T}) where {T}\n\nCompute the location of the quadrature point.\n\nArguments: loc = matrix of coordinates, overwritten  inside the function ecoords = matrix of the node coordinates for the element. N = matrix of basis function values\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.locjac!-Union{Tuple{T}, NTuple{5, Matrix{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.locjac!","text":"locjac!(\n    loc::Matrix{T},\n    J::Matrix{T},\n    ecoords::Matrix{T},\n    N::Matrix{T},\n    gradNparams::Matrix{T},\n) where {T}\n\nCompute location and Jacobian matrix at the quadrature point.\n\nArguments: loc = matrix of coordinates, overwritten  inside the function J = Jacobian matrix, overwritten  inside the function ecoords = matrix of the node coordinates for the element. N = matrix of basis function values gradNparams = matrix of basis function gradients\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.matrix_blocked_dd","page":"Functions","title":"FinEtools.MatrixUtilityModule.matrix_blocked_dd","text":"matrix_blocked_dd(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)\n\nExtract the \"data-data\" partition of a matrix.\n\nThe matrix is assumed to be composed of four blocks\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...). The size of the ff block is row_nfreedofs, col_nfreedofs. Neither one of the blocks is square, unless row_nfreedofs == col_nfreedofs.\n\nWhen row_nfreedofs == col_nfreedofs, only the number of rows needs to be given.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.matrix_blocked_df","page":"Functions","title":"FinEtools.MatrixUtilityModule.matrix_blocked_df","text":"matrix_blocked_df(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)\n\nExtract the \"data-free\" partition of a matrix.\n\nThe matrix is assumed to be composed of four blocks\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...). The size of the ff block is row_nfreedofs, col_nfreedofs. Neither one of the blocks is square, unless row_nfreedofs == col_nfreedofs.\n\nWhen row_nfreedofs == col_nfreedofs, only the number of rows needs to be given.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.matrix_blocked_fd","page":"Functions","title":"FinEtools.MatrixUtilityModule.matrix_blocked_fd","text":"matrix_blocked_fd(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)\n\nExtract the \"free-data\" partition of a matrix.\n\nThe matrix is assumed to be composed of four blocks\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...). The size of the ff block is row_nfreedofs, col_nfreedofs. Neither one of the blocks is square, unless row_nfreedofs == col_nfreedofs.\n\nWhen row_nfreedofs == col_nfreedofs, only the number of rows needs to be given.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.matrix_blocked_ff","page":"Functions","title":"FinEtools.MatrixUtilityModule.matrix_blocked_ff","text":"matrix_blocked_ff(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)\n\nExtract the \"free-free\" partition of a matrix.\n\nThe matrix is assumed to be composed of four blocks\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...). The size of the ff block is row_nfreedofs, col_nfreedofs. Neither one of the blocks is square, unless row_nfreedofs == col_nfreedofs.\n\nWhen row_nfreedofs == col_nfreedofs, only the number of rows needs to be given.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(C, A, B)\n\nCompute the matrix C = A * B\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\nNote: See the thread https://discourse.julialang.org/t/ann-loopvectorization/32843/36\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3}, Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = A * B\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Vector{T}, Any, Vector{T}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAB!","text":"mulCAB!(C::Vector{T}, A, B::Vector{T})  where {T}\n\nCompute the product C = A * B, where C and B are \"vectors\".\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCABt!","text":"mulCABt!(C, A, B)\n\nCompute the matrix C = A * B'\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3}, Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCABt!","text":"mulCABt!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = A * Transpose(B)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAtB!","text":"mulCAtB!(C, A, B)\n\nCompute the matrix C = A' * B\n\nThe use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3}, Any, Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.mulCAtB!","text":"mulCAtB!(::Val{3}, C, A, B)\n\nCompute the product of 3X3 matrices C = Transpose(A) * B\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.setvectorentries!","page":"Functions","title":"FinEtools.MatrixUtilityModule.setvectorentries!","text":"setvectorentries!(a, v = zero(eltype(a)))\n\nSet entries of a long vector to a given constant.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.symmetrize!","text":"symmetrize!(a)\n\nMake the matrix on input symmetric.\n\nThe operation is in-place.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.vector_blocked_d-Tuple{Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.vector_blocked_d","text":"vector_blocked_d(V, nfreedofs)\n\nExtract the \"data\" part of a vector.\n\nThe vector is composed of two blocks\n\nV = [V_f\n     V_d]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.vector_blocked_f-Tuple{Any, Any}","page":"Functions","title":"FinEtools.MatrixUtilityModule.vector_blocked_f","text":"vector_blocked_f(V, nfreedofs)\n\nExtract the \"free\" part of a vector.\n\nThe vector is composed of two blocks\n\nV = [V_f\n     V_d]\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MatrixUtilityModule.zeros_via_calloc-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer}}} where T","page":"Functions","title":"FinEtools.MatrixUtilityModule.zeros_via_calloc","text":"zeros_via_calloc(::Type{T}, dims::Integer...) where {T}\n\nAllocate large array of numbers using calloc.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Data-cache","page":"Functions","title":"Data cache","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.DataCacheModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.size-Tuple{DataCache}","page":"Functions","title":"Base.size","text":"size(self::DataCache)\n\nSize of the data cache value.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Surface-normal-utilities","page":"Functions","title":"Surface-normal utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.SurfaceNormalModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.SurfaceNormalModule.updatenormal!-Union{Tuple{IT}, Tuple{T}, Tuple{SurfaceNormal, Matrix{T}, Matrix{T}, IT, IT}} where {T, IT}","page":"Functions","title":"FinEtools.SurfaceNormalModule.updatenormal!","text":"updatenormal!(self::SurfaceNormal, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T, IT}\n\nUpdate the surface normal vector.\n\nReturns the normal vector (stored in the cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Force-intensity","page":"Functions","title":"Force intensity","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.ForceIntensityModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.ForceIntensityModule.updateforce!-Union{Tuple{IT}, Tuple{T}, Tuple{ForceIntensity, Matrix{T}, Matrix{T}, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.ForceIntensityModule.updateforce!","text":"updateforce!(self::ForceIntensity, XYZ::Matrix{T}, tangents::Matrix{T}, feid::IT, qpid::IT) where {T<:Number, IT<:Integer}\n\nUpdate the force intensity vector.\n\nReturns a vector (stored in the cache self.cache).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Rotation-utilities","page":"Functions","title":"Rotation utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.RotationUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.RotationUtilModule.cross2-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Functions","title":"FinEtools.RotationUtilModule.cross2","text":"cross2(theta::AbstractVector{T1}, v::AbstractVector{T2}) where {T1, T2}\n\nCompute the cross product of two vectors in two-space.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, AbstractVector{T3}}} where {T1, T2, T3}","page":"Functions","title":"FinEtools.RotationUtilModule.cross3!","text":"cross3!(\n    result::AbstractVector{T1},\n    theta::AbstractVector{T2},\n    v::AbstractVector{T3},\n) where {T1, T2, T3}\n\nCompute the cross product of two vectors in three-space in place.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.cross3!-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, Union{AbstractVector{T2}, Tuple{T2, T2, T2}}, Union{AbstractVector{T3}, Tuple{T3, T3, T3}}}} where {T1, T2, T3}","page":"Functions","title":"FinEtools.RotationUtilModule.cross3!","text":"cross3!(\n    result::AbstractVector{T1},\n    theta::Union{AbstractVector{T2}, Tuple{T2, T2, T2}},\n    v::Union{AbstractVector{T3}, Tuple{T3, T3, T3}}\n) where {T1, T2, T3}\n\nCompute the cross product of two vectors in three-space in place.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}","page":"Functions","title":"FinEtools.RotationUtilModule.rotmat3!","text":"rotmat3!(Rmout::Matrix{T}, a::VT) where {T, VT}\n\nCompute a 3D rotation matrix in-place.\n\na = array, vector, or tuple with three floating-point numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.rotmat3-Tuple{VT} where VT","page":"Functions","title":"FinEtools.RotationUtilModule.rotmat3","text":"rotmat3(a::VT) where {VT}\n\nPrepare a rotation matrix from a rotation vector\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.RotationUtilModule.skewmat!-Union{Tuple{VT}, Tuple{T}, Tuple{Matrix{T}, VT}} where {T, VT}","page":"Functions","title":"FinEtools.RotationUtilModule.skewmat!","text":"skewmat!(S::Matrix{T}, theta::VT) where {T, VT}\n\nCompute skew-symmetric matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-sets","page":"Functions","title":"Finite element sets","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FESetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.cat-Union{Tuple{ET}, Tuple{ET, ET}} where ET<:AbstractFESet","page":"Functions","title":"Base.cat","text":"cat(self::T,  other::T) where {T<:AbstractFESet}\n\nConcatenate the connectivities of two FE sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.count-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"Base.count","text":"count(self::T)::FInt where {T<:AbstractFESet}\n\nGet the number of individual connectivities in the FE set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.eachindex-Tuple{FES} where FES<:AbstractFESet","page":"Functions","title":"Base.eachindex","text":"eachindex(fes::AbstractFESet)\n\nCreate an iterator for elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET<:AbstractFESet0Manifold, FT}","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::ET, J::Matrix{FT}) where {ET<:AbstractFESet0Manifold, FT}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET<:AbstractFESet1Manifold, FT}","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::ET, J::Matrix{FT}) where {ET<:AbstractFESet1Manifold, FT}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET<:AbstractFESet2Manifold, FT}","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::ET, J::Matrix{FT}) where {ET<:AbstractFESet2Manifold, FT}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.Jacobian-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}}} where {ET<:AbstractFESet3Manifold, FT}","page":"Functions","title":"FinEtools.FESetModule.Jacobian","text":"Jacobian(self::ET, J::Matrix{FT}) where {ET<:AbstractFESet3Manifold, FT}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix, columns are tangent to parametric coordinates curves.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.accepttodelegate-Union{Tuple{T}, Tuple{T, Any}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.accepttodelegate","text":"accepttodelegate(self::T, delegateof) where {T<:AbstractFESet}\n\nAccept to delegate for an object.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET<:AbstractFESet, T}","page":"Functions","title":"FinEtools.FESetModule.bfun","text":"bfun(self::ET, param_coords::Vector{T}) where {ET<:AbstractFESet, T}\n\nCompute the values of the basis functions.\n\nCompute the values of the basis functions at a given parametric coordinate. One basis function per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{ET}, Tuple{ET, Vector{T}}} where {ET<:AbstractFESet, T}","page":"Functions","title":"FinEtools.FESetModule.bfundpar","text":"bfundpar(self::ET, param_coords::Vector{T}) where {ET<:AbstractFESet, T}\n\nCompute the values of the basis function gradients.\n\nCompute the values of the basis function gradients with respect to the parametric coordinates at a given parametric coordinate. One basis function gradients per row.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryconn-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryconn","text":"boundaryconn(self::T) where {T<:AbstractFESet}\n\nGet boundary connectivity.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.boundaryfe-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.boundaryfe","text":"boundaryfe(self::T) where {T<:AbstractFESet}\n\nReturn the constructor of the type of the boundary finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.centroidparametric-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.centroidparametric","text":"centroidparametric(self::T) where {T<:AbstractFESet}\n\nReturn the parametric coordinates  of the centroid of the element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.connasarray","text":"connasarray(self::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nReturn the connectivity as an array.\n\nReturn the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.delegateof-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.delegateof","text":"delegateof(self::T) where {T<:AbstractFESet}\n\nReturn the object of which the elements set is a delegate.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM}, AbstractArray}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.fromarray!","text":"fromarray!(self::AbstractFESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}\n\nSet  the connectivity from an integer array.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet1Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(\n    self::AbstractFESet1Manifold,\n    gradN::Matrix{FT},\n    gradNparams::Matrix{FT},\n    redJ::Matrix{FT},\n) where {FT}\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet2Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(\n    self::AbstractFESet2Manifold,\n    gradN::Matrix{FT},\n    gradNparams::Matrix{FT},\n    redJ::Matrix{FT},\n) where {FT}\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.gradN!-Union{Tuple{FT}, Tuple{AbstractFESet3Manifold, Matrix{FT}, Matrix{FT}, Matrix{FT}}} where FT","page":"Functions","title":"FinEtools.FESetModule.gradN!","text":"gradN!(\n    self::AbstractFESet3Manifold,\n    gradN::Matrix{FT},\n    gradNparams::Matrix{FT},\n    redJ::Matrix{FT},\n) where {FT}\n\nCompute the gradient of the basis functions with the respect to the \"reduced\" spatial coordinates.\n\ngradN= output,  matrix of gradients,  one per row\ngradNparams= matrix of gradients with respect to parametric coordinates, one per row\nredJ= reduced Jacobian matrix redJ=transpose(Rm)*J\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.inparametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Vector{FT}}} where {ET<:AbstractFESet, FT}","page":"Functions","title":"FinEtools.FESetModule.inparametric","text":"inparametric(self::AbstractFESet, param_coords)\n\nAre given parametric coordinates inside the element parametric domain?\n\nReturn a Boolean: is the point inside, true or false?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.manifdim","text":"manifdim(me)\n\nGet the manifold dimension.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.map2parametric-Union{Tuple{FT}, Tuple{ET}, Tuple{ET, Matrix{FT}, Vector{FT}}} where {ET<:AbstractFESet, FT}","page":"Functions","title":"FinEtools.FESetModule.map2parametric","text":"map2parametric(\n    self::ET,\n    x::Matrix{FT},\n    pt::Vector{FT};\n    tolerance = 0.001,\n    maxiter = 5,\n) where {ET<:AbstractFESet, FT}\n\nMap a spatial location to parametric coordinates.\n\nx=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,\nc= spatial location\ntolerance = tolerance in parametric coordinates; default is 0.001.\n\nReturn\n\nsuccess = Boolean flag, true if successful, false otherwise.\npc = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM","page":"Functions","title":"FinEtools.FESetModule.nodesperelem","text":"nodesperelem(fes::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}\n\nProvide the number of nodes per element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.nodesperelem-Union{Tuple{Type{T}}, Tuple{T}, Tuple{NODESPERELEM}} where {NODESPERELEM, T<:AbstractFESet{NODESPERELEM}}","page":"Functions","title":"FinEtools.FESetModule.nodesperelem","text":"nodesperelem(::Type{T}) where {NODESPERELEM, T<:AbstractFESet{NODESPERELEM}}\n\nProvide the number of nodes per element for a given type.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, IT}} where {ET<:AbstractFESet, IT}","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::ET, val::IT) where {ET<:AbstractFESet, IT}\n\nSet the label of the entire finite elements set.\n\nAll elements are labeled with this number.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.setlabel!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET<:AbstractFESet, IT}","page":"Functions","title":"FinEtools.FESetModule.setlabel!","text":"setlabel!(self::ET, val::Vector{IT}) where {ET<:AbstractFESet, IT}\n\nSet the labels of individual elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.subset-Union{Tuple{ET}, Tuple{ET, Any}} where ET<:AbstractFESet","page":"Functions","title":"FinEtools.FESetModule.subset","text":"subset(self::T, L) where {T<:AbstractFESet}\n\nExtract a subset of the finite elements from the given finite element set.\n\nL: an integer vector, tuple, or a range.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FESetModule.updateconn!-Union{Tuple{IT}, Tuple{ET}, Tuple{ET, Vector{IT}}} where {ET<:AbstractFESet, IT}","page":"Functions","title":"FinEtools.FESetModule.updateconn!","text":"updateconn!(self::ET, newids::Vector{IT}) where {ET<:AbstractFESet, IT}\n\nUpdate the connectivity after the IDs of nodes changed.\n\nnewids= new node IDs. Note that indexes in the conn array \"point\" into the  newids array. After the connectivity was updated this will no longer be true!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-nodes","page":"Functions","title":"Finite element nodes","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeSetModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.count-Tuple{FENodeSet}","page":"Functions","title":"Base.count","text":"count(self::FENodeSet)\n\nGet the number of finite element nodes in the node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base.eachindex-Tuple{FENodeSet}","page":"Functions","title":"Base.eachindex","text":"eachindex(fens::FENodeSet)\n\nCreate the finite element node iterator.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.spacedim","text":"spacedim(self::FENodeSet)\n\nNumber of dimensions of the space in which the node lives, 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.FENodeSetModule.xyz3","text":"xyz3(self::FENodeSet)\n\nGet the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Finite-element-node-to-element-map","page":"Functions","title":"Finite element node-to-element map","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FENodeToFEMapModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Selecting-nodes-and-elements","page":"Functions","title":"Selecting nodes and elements","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshSelectionModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectedelems-Union{Tuple{IT}, Tuple{AbstractFESet, Vector{IT}, IT}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshSelectionModule.connectedelems","text":"connectedelems(fes::AbstractFESet, node_list::FIntVec)\n\nExtract the list of numbers for the fes  that are connected to given nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.connectednodes","text":"connectednodes(fes::AbstractFESet)\n\nExtract the node numbers of the nodes connected by given finite elements.\n\nExtract the list of unique node numbers for the nodes that are connected by the finite element set fes. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet, AbstractFESet}","page":"Functions","title":"FinEtools.MeshSelectionModule.findunconnnodes","text":"findunconnnodes(fens::FENodeSet, fes::AbstractFESet)\n\nFind nodes that are not connected to any finite element.\n\nReturns\n\nconnected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectelem-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET<:AbstractFESet","page":"Functions","title":"FinEtools.MeshSelectionModule.selectelem","text":"selectelem(fens::FENodeSet, fes::T; kwargs...) where {T<:AbstractFESet}\n\nSelect finite elements.\n\nArguments\n\nfens = finite element node set\nfes = finite element set\nkwargs = keyword arguments to specify the selection criteria\n\nSelection criteria\n\nfacing\n\nSelect all \"boundary\" elements that \"face\" a certain direction.\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);\n\nor\n\nexteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);\n\nwhere\n\nfunction dout(xyz)\n    return xyz/norm(xyz)\nend\n\nand xyz is the location of the centroid  of  a boundary element. Here the finite element is considered \"facing\" in the given direction if the dot product of its normal and the direction vector is greater than dotmin. The default value for dotmin is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).\n\nThis selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).\n\nlabel\n\nSelect elements based on their label.\n\nrl1 = selectelem(fens, fes, label=1)\n\nbox, distance\n\nSelect elements based on some criteria that their nodes satisfy.  See the function selectnode().\n\nExample: Select all  elements whose nodes are closer than R+inflate from the point from.\n\nlinner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],\n  inflate = tolerance)\n\nExample:\n\nexteriorbfl = selectelem(fens, bdryfes,\n   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);\n\nwithnodes\n\nSelect elements whose nodes are in a given list of node numbers.\n\nExample:\n\nl = selectelem(fens, fes, withnodes = [13, 14])\n\nflood\n\nSelect all FEs connected together, starting from a given node. Connections through a vertex (node) are sufficient.\n\nExample: Select all FEs connected together (Starting from node 13):\n\nl = selectelem(fens, fes, flood = true, startnode = 13)\n\nOptional keyword arguments\n\nShould we consider the element only if all its nodes are in?\n\nallin = Boolean: if true, then all nodes of an element must satisfy\n\nthe criterion; otherwise  one is enough.\n\nOutput\n\nfelist = list of finite elements from the set that satisfy the criteria\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}","page":"Functions","title":"FinEtools.MeshSelectionModule.selectnode","text":"selectnode(fens::FENodeSet; kwargs...)\n\nSelect nodes using some criterion.\n\nArguments\n\nv = array of locations, one location per row\nkwargs = pairs of keyword argument/value\n\nSelection criteria\n\nbox\n\nnLx = vselect(fens.xyz, box = [0.0 Lx  0.0 0.0 0.0 0.0], inflate = Lx/1.0e5)\n\nThe keyword 'inflate' may be used to increase or decrease the extent of the box (or the distance) to make sure some nodes which would be on the boundary are either excluded or included.\n\ndistance\n\nlist = selectnode(fens.xyz; distance=1.0+0.1/2^nref, from=[0. 0.],\n        inflate=tolerance);\n\nFind all nodes within a certain distance from a given point.\n\nplane\n\ncandidates = selectnode(fens; plane = [0.0 0.0 1.0 0.0], thickness = h/1000)\n\nThe keyword plane defines the plane by its normal (the first two or three numbers) and its distance from the origin (the last number). Nodes are selected they lie on the plane,  or near the plane within the distance thickness from the plane. The normal is assumed to be of unit length, if it isn't apply as such, it will be normalized internally.\n\nnearestto\n\nnh = selectnode(fens; nearestto = [R+Ro/2, 0.0, 0.0] )\n\nFind the node nearest to the location given.\n\nfarthestfrom\n\nnh = selectnode(fens; farthestfrom = [R+Ro/2, 0.0, 0.0] )\n\nFind the node farthest from the location given.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshSelectionModule.vselect-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Number","page":"Functions","title":"FinEtools.MeshSelectionModule.vselect","text":"vselect(v::Matrix{T}; kwargs...) where {T<:Number}\n\nSelect locations (vertices) from the array based on some criterion.\n\nSee the function selectnode() for examples of the criteria that can be used to search vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Fields","page":"Functions","title":"Fields","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FieldModule, FinEtools.GeneralFieldModule, FinEtools.NodalFieldModule, FinEtools.ElementalFieldModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.copyto!-Union{Tuple{F}, Tuple{F, F}} where F<:AbstractField","page":"Functions","title":"Base.copyto!","text":"copyto!(DEST::F,  SRC::F) where {F<:AbstractField}\n\nCopy data from one field to another.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.anyfixedvaluenz-Union{Tuple{CC}, Tuple{F}, Tuple{F, CC}} where {F<:AbstractField, CC}","page":"Functions","title":"FinEtools.FieldModule.anyfixedvaluenz","text":"anyfixedvaluenz(self::F, conn::CC) where {F<:AbstractField, CC}\n\nIs any degree of freedom fixed (prescribed) to be non-zero?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.applyebc!-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.applyebc!","text":"applyebc!(self::F) where {F<:AbstractField}\n\nApply EBCs (essential boundary conditions).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.fixeddofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.fixeddofs","text":"fixeddofs(self::F) where {F<:AbstractField}\n\nReturn range corresponding to the fixed degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.freedofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.freedofs","text":"freedofs(self::F) where {F<:AbstractField}\n\nReturn range corresponding to the free degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{F}, Tuple{F, A, CC}} where {F<:AbstractField, A, CC}","page":"Functions","title":"FinEtools.FieldModule.gatherdofnums!","text":"gatherdofnums!(self::F, dest::A, conn::CC) where {F<:AbstractField, A, CC}\n\nGather dofnums from the field.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom for that node,  then the next node  and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F<:AbstractField, T, CC}","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asmat!","text":"gatherfixedvalues_asmat!(\n    self::F,\n    dest::AbstractArray{T,2},\n    conn::CC,\n) where {F<:AbstractField, T, CC}\n\nGather FIXED values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F<:AbstractField, T, CC}","page":"Functions","title":"FinEtools.FieldModule.gatherfixedvalues_asvec!","text":"gatherfixedvalues_asvec!(\n    self::F,\n    dest::AbstractArray{T,1},\n    conn::CC,\n) where {F<:AbstractField, T, CC}\n\nGather FIXED values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, Vector{T}}, Tuple{F, Vector{T}, Any}} where {F<:AbstractField, T}","page":"Functions","title":"FinEtools.FieldModule.gathersysvec!","text":"gathersysvec!(self::F,\n    vec::Vector{T}, which = :f) where {F<:AbstractField, T}\n\nGather values from the field for the system vector.\n\nArguments\n\nself: field;\nwhich:\n:f - Collect a vector that includes the free degrees of freedom (default);\n:d - Collect a vector that includes the fixed (data) degrees of freedom;\n:a - Collect a vector that includes all the degrees of freedom, free and fixed.\n\nThe system vector consists of two parts: the first part, from 1 to nfreedofs (self) are the free degrees of freedom, the second part from nfreedofs (self)+1 to nalldofs(self) are the fixed degrees of freedom.\n\nThis function gathers either the entire vector, or one of the parts. The length of the supplied buffer vec must be correct, either nfreedofs (self), nalldofs(self), or nfixeddofs(self).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F, Any}} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.gathersysvec","text":"gathersysvec(self::F, which = :f) where {F<:AbstractField}\n\nGather values from the field for the system vector.\n\nArguments\n\nself: field;\nwhich:\n:f - Collect a vector that includes the free degrees of freedom (default);\n:d - Collect a vector that includes the fixed (data) degrees of freedom;\n:a - Collect a vector that includes all the degrees of freedom, free and fixed.\n\nThe system vector consists of two parts: the first part, from 1 to nfreedofs (self) are the free degrees of freedom, the second part from nfreedofs (self)+1 to nalldofs(self) are the fixed degrees of freedom.\n\nThis function returns either the entire vector, or one of the parts.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}, CC}} where {F<:AbstractField, T, CC}","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asmat!","text":"gathervalues_asmat!(\n    self::F,\n    dest::AbstractArray{T,2},\n    conn::CC,\n) where {F<:AbstractField, T, CC}\n\nGather values from the field into a two-dimensional array.\n\nThe order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{CC}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}, CC}} where {F<:AbstractField, T, CC}","page":"Functions","title":"FinEtools.FieldModule.gathervalues_asvec!","text":"gathervalues_asvec!(\n    self::F,\n    dest::AbstractArray{T,1},\n    conn::CC,\n) where {F<:AbstractField, T, CC}\n\nGather values from the field into a vector.\n\nThe order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.\n\ndest = destination buffer: overwritten  inside,  must be preallocated in the correct size\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F<:AbstractField, T<:Number}","page":"Functions","title":"FinEtools.FieldModule.incrscattersysvec!","text":"incrscattersysvec!(self::F, vec::AbstractVector{T}) where {F<:AbstractField, T<:Number}\n\nIncrement values of the field by scattering a system vector.\n\nThe vector may be either for just the free degrees of freedom, or for all the degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nalldofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.nalldofs","text":"nalldofs(self::F)\n\nReturn to number of ALL degrees of freedom (total number of degrees of freedom, which is equal to the number of degrees of freedom per entity times the number of entities).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.ndofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.ndofs","text":"ndofs(self::F)\n\nDimension of the degree of freedom parameters (i. e. how many degrees of freedom per entity).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nents-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.nents","text":"nents(self::F)\n\nNumber of nodes associated with the field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nfixeddofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.nfixeddofs","text":"nfixeddofs(self::F)\n\nReturn to number of FIXED degrees of freedom (known, data).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.nfreedofs-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.nfreedofs","text":"nfreedofs(self::F)\n\nReturn to number of FREE degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.numberdofs!-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.numberdofs!","text":"numberdofs!(self::F) where {F<:AbstractField}\n\nNumber the degrees of freedom.\n\nThe free components in the field are numbered consecutively, then all the fixed components are numbered, again consecutively.\n\nNo effort is made to optimize the numbering in any way. If you'd like to optimize the numbering of the degrees of freedom, use a form that sets the permutation of the degrees of freedom, or the permutation of the nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.numberdofs!-Union{Tuple{F}, Tuple{F, Any}} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.numberdofs!","text":"numberdofs!(self::F, entperm) where {F<:AbstractField}\n\nNumber the degrees of freedom.\n\nThe free components in the field are numbered consecutively, then all the fixed components are numbered, again consecutively.\n\nThe sequence of the entities is given by the entperm permutation (array or range).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.prescribeddofs-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1<:AbstractField, F2<:AbstractField}","page":"Functions","title":"FinEtools.FieldModule.prescribeddofs","text":"prescribeddofs(uebc::F1, u::F2) where {F1<:AbstractField,  F2<:AbstractField}\n\nFind which degrees of freedom are prescribed. uebc = field which defines the constraints (is the dof fixed and to which value), u = field which does not have the constraints applied, and serves as the source of equation numbers; uebc and u may be one and the same field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}} where {F<:AbstractField, T<:Number}","page":"Functions","title":"FinEtools.FieldModule.scattersysvec!","text":"scattersysvec!(self::F, vec::AbstractVector{T}) where {F<:AbstractField, T<:Number}\n\nScatter values to the field from a system vector.\n\nThe vector may be either for just the free degrees of freedom, or for all the degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::F)\n\nSet the EBCs (essential boundary conditions).\n\nAll essential boundary conditions are CLEARED.\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, AbstractVector{IT}}} where {F<:AbstractField, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::F, fenids::AbstractVector{IT})  where {IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given nodes.\n\nfenids         - array of N node identifiers\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{F}, Tuple{F, IT}} where {F<:AbstractField, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(self::F, fenid::IT) where {IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nSuppress all degrees of freedom at the given node.\n\nfenid         - One integer as a node identifier\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}}, Tuple{F, AbstractVector{IT}, Bool, AbstractVector{IT}, T}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenids::AbstractVector{IT},\n    is_fixed::Bool,\n    comp::AbstractVector{IT},\n    val::T = 0.0,\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer vector, which degree of freedom (component), val = scalar of type T, default is 0.0\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT, AbstractVector{T}}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenids::AbstractVector{IT},\n    is_fixed::Bool,\n    comp::IT,\n    val::AbstractVector{T},\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, Bool, IT}, Tuple{F, AbstractVector{IT}, Bool, IT, T}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenids::AbstractVector{IT},\n    is_fixed::Bool,\n    comp::IT,\n    val::T = 0.0,\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT, AbstractVector{T}}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenids::AbstractVector{IT},\n    comp::IT,\n    val::AbstractVector{T},\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{IT}, IT}, Tuple{F, AbstractVector{IT}, IT, T}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenids::AbstractVector{IT},\n    comp::IT,\n    val::T = 0.0,\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids = array of N node identifiers comp = integer, which  degree of freedom (component), val = scalar of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.setebc!-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, IT, Bool, IT, T}} where {F<:AbstractField, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FieldModule.setebc!","text":"setebc!(\n    self::F,\n    fenid::IT,\n    is_fixed::Bool,\n    comp::IT,\n    val::T,\n) where {T<:Number, IT<:Integer}\n\nSet the EBCs (essential boundary conditions).\n\nfenids         - array of N node identifiers is_fixed = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), comp = integer, which  degree of freedom (component), val = array of N values of type T\n\nNote:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets _nfreedofs = 0; and  dofnums=0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FieldModule.wipe!-Tuple{F} where F<:AbstractField","page":"Functions","title":"FinEtools.FieldModule.wipe!","text":"wipe!(self::F) where {F<:AbstractField}\n\nWipe all the data from the field.\n\nThis includes values, prescribed values, degree of freedom numbers, and \"is fixed\" flags. The number of free degrees of freedom is set to zero.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}","page":"Functions","title":"FinEtools.NodalFieldModule.nnodes","text":"nnodes(self::NodalField)\n\nProvide the number of nodes  in the nodal field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}","page":"Functions","title":"FinEtools.ElementalFieldModule.nelems","text":"nelems(self::ElementalField)\n\nProvide the number of elements  in the elemental field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Integration-rule","page":"Functions","title":"Integration rule","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegRuleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Integration-domain","page":"Functions","title":"Integration domain","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.IntegDomainModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet0Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet0Manifold, CC, T<:Number}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet1Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiancurve","text":"Jacobiancurve(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet1Manifold, CC, T<:Number}\n\nEvaluate the curve Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT<:AbstractFESet0Manifold, CC, T<:Number, IT}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n    m::IT,\n) where {MT<:AbstractFESet0Manifold, CC, T<:Number, IT}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 0-dimensional finite element,  the manifold Jacobian is for\n\nm=0: +1\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT<:AbstractFESet1Manifold, CC, T<:Number, IT}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n    m::IT,\n) where {MT<:AbstractFESet1Manifold, CC, T<:Number, IT}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 1-dimensional finite element,  the manifold Jacobian is for\n\nm=1: Jacobiancurve\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT<:AbstractFESet2Manifold, CC, T<:Number, IT}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n    m::IT,\n) where {MT<:AbstractFESet2Manifold, CC, T<:Number, IT}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 2-dimensional finite element,  the manifold Jacobian is for\n\nm=2: Jacobiansurface\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{IT}, Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}, IT}} where {MT<:AbstractFESet3Manifold, CC, T<:Number, IT}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianmdim","text":"Jacobianmdim(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n    m::IT,\n) where {MT<:AbstractFESet3Manifold, CC, T<:Number, IT}\n\nEvaluate the manifold Jacobian for an m-dimensional manifold.\n\nFor an 3-dimensional cell,  the manifold Jacobian is\n\nm=3: Jacobianvolume\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet0Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianpoint","text":"Jacobianpoint(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet0Manifold, CC, T<:Number}\n\nEvaluate the point Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet0Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet0Manifold, CC, T<:Number}\n\nEvaluate the surface Jacobian.\n\nFor the zero-dimensional cell, the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc times the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet1Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet1Manifold, CC, T<:Number}\n\nEvaluate the surface Jacobian.\n\nFor the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet2Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobiansurface","text":"Jacobiansurface(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet2Manifold, CC, T<:Number}\n\nEvaluate the surface Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet0Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet0Manifold, CC, T<:Number}\n\nEvaluate the volume Jacobian.\n\nFor the zero-dimensional cell, the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point loc and the other dimension (units of length squared).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet1Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet1Manifold, CC, T<:Number}\n\nEvaluate the volume Jacobian.\n\nFor the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point loc and the other dimension (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet2Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet2Manifold, CC, T<:Number}\n\nEvaluate the volume Jacobian.\n\nFor the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point loc (units of length).\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{T}, Tuple{CC}, Tuple{MT}, Tuple{IntegDomain{MT}, Matrix{T}, Matrix{T}, CC, Matrix{T}}} where {MT<:AbstractFESet3Manifold, CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.Jacobianvolume","text":"Jacobianvolume(\n    self::IntegDomain{MT},\n    J::Matrix{T},\n    loc::Matrix{T},\n    conn::CC,\n    N::Matrix{T},\n) where {MT<:AbstractFESet3Manifold, CC, T<:Number}\n\nEvaluate the volume Jacobian.\n\nJ = Jacobian matrix\nloc = location of the quadrature point in physical coordinates,\nconn = connectivity of the element,\nN = matrix of basis function values at the quadrature point.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Tuple{ID} where ID<:IntegDomain","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(self::IntegDomain)\n\nCalculate the data needed for  numerical quadrature for the integration rule stored by the integration domain.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.integrationdata-Union{Tuple{IR}, Tuple{ID}, Tuple{ID, IR}} where {ID<:IntegDomain, IR<:AbstractIntegRule}","page":"Functions","title":"FinEtools.IntegDomainModule.integrationdata","text":"integrationdata(\n    self::IntegDomain,\n    integration_rule::IR,\n) where {IR<:AbstractIntegRule}\n\nCalculate the data needed for a given numerical quadrature rule.\n\nFor given integration domain, compute the quantities needed for numerical integration. The integration rule does not necessarily have to be the one associated originally with the integration domain.\n\nReturn\n\nnpts, Ns, gradNparams, w, pc = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{T}, Tuple{CC}, Tuple{Matrix{T}, CC, Matrix{T}}} where {CC, T<:Number}","page":"Functions","title":"FinEtools.IntegDomainModule.otherdimensionunity","text":"otherdimensionunity(loc::Matrix{T}, conn::CC, N::Matrix{T}) where {CC, T<:Number}\n\nEvaluate the other dimension: default is 1.0.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Assembly-of-matrices-and-vectors","page":"Functions","title":"Assembly of matrices and vectors","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AssemblyModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.eltype-Tuple{A} where A<:AbstractSysmatAssembler","page":"Functions","title":"Base.eltype","text":"eltype(a::A) where {A <: AbstractSysmatAssembler}\n\nWhat is the type of the matrix buffer entries?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerFFBlock, MBT, CIT, CIT}} where {MBT, CIT}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysmatAssemblerFFBlock,\n    mat::MBT,\n    dofnums_row::CIT,\n    dofnums_col::CIT) where {MBT, CIT}\n\nAssemble a matrix, v\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparse, MBT, CIT, CIT}} where {MBT, CIT}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(\n    self::SysmatAssemblerSparse,\n    mat::MT,\n    dofnums_row::IT,\n    dofnums_col::IT,\n) where {MT, IT}\n\nAssemble a rectangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseDiag, MBT, CIT, CIT}} where {MBT, CIT}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(\n    self::SysmatAssemblerSparseDiag,\n    mat::MT,\n    dofnums_row::IV,\n    dofnums_col::IV,\n) where {MT, IV}\n\nAssemble a square symmetric diagonal matrix.\n\ndofnums = the row degree of freedom numbers, the column degree of freedom\n\nnumber input is ignored (the row and column numbers are assumed to be the same).\n\nmat = diagonal square matrix\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseHRZLumpingSymm, MBT, CIT, CIT}} where {MBT, CIT}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(\n    self::SysmatAssemblerSparseHRZLumpingSymm,\n    mat::MT,\n    dofnums::IV,\n    ignore::IV,\n) where {MT, IV}\n\nAssemble a HRZ-lumped square symmetric matrix.\n\nAssembly of a HRZ-lumped square symmetric matrix. The method assembles the scaled diagonal of the square symmetric matrix using the two vectors of equation numbers for the rows and columns.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{CIT}, Tuple{MBT}, Tuple{SysmatAssemblerSparseSymm, MBT, CIT, CIT}} where {MBT, CIT}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(\n    self::SysmatAssemblerSparseSymm,\n    mat::MT,\n    dofnums::IT,\n    ignore\n) where {MT, IT}\n\nAssemble a square symmetric matrix.\n\ndofnums are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are assumed to be the same).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SV}, Tuple{SV, MV, IV}} where {SV<:AbstractSysvecAssembler, MV, IV}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssembler{T}, vec::MV,\n  dofnums::D) where {T<:Number, MV<:AbstractArray{T}, D<:AbstractArray{FInt}}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SysvecAssembler, MV, IV}} where {MV, IV}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssembler{T}, vec::MV,\n  dofnums::D) where {T<:Number, MV<:AbstractArray{T}, D<:AbstractArray{FInt}}\n\nAssemble an elementwise vector.\n\nThe method assembles a column element vector using the vector of degree of freedom numbers for the rows.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.assemble!-Union{Tuple{IV}, Tuple{MV}, Tuple{SysvecAssemblerFBlock, MV, IV}} where {MV, IV}","page":"Functions","title":"FinEtools.AssemblyModule.assemble!","text":"assemble!(self::SysvecAssemblerFBlock,\n    vec::MV,\n    dofnums::IV) where {MV, IV}\n\nAssemble an elementwise vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.expectedntriples-Union{Tuple{IT}, Tuple{A}, Tuple{A, IT, IT, IT}} where {A<:AbstractSysmatAssembler, IT}","page":"Functions","title":"FinEtools.AssemblyModule.expectedntriples","text":"expectedntriples(\n    a::A,\n    elem_mat_nrows::IT,\n    elem_mat_ncols::IT,\n    n_elem_mats::IT,\n) where {A<:AbstractSysmatAssembler, IT}\n\nHow many triples (I, J, V) does the assembler expect to store?\n\nDefault is: the product of the size of the element matrices times the number of matrices. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerFFBlock}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerFFBlock)\n\nMake an assembled matrix. Delegate the construction of the matrix to the wrapped assembler. Then extract the left upper corner block of the matrix(the free-free matrix).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseDiag}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseDiag)\n\nMake a sparse symmetric square diagonal matrix.\n\nnote: Note\nIf nomatrixresult is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.\n\nnote: Note\nWhen the matrix is constructed (nomatrixresult is false), the buffers are not deallocated, and the buffer_pointer is set to 1. It is then possible to immediately start assembling another matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)\n\nMake a sparse HRZ-lumped symmetric square  matrix.\n\nnote: Note\nIf nomatrixresult is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.\n\nnote: Note\nWhen the matrix is constructed (nomatrixresult is false), the buffers are not deallocated, and the buffer_pointer is set to 1. It is then possible to immediately start assembling another matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparseSymm)\n\nMake a sparse symmetric square matrix.\n\nnote: Note\nIf nomatrixresult is set to true, dummy (zero) sparse matrix is returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.\n\nnote: Note\nWhen the matrix is constructed (nomatrixresult is false), the buffers are not deallocated, and the buffer_pointer is set to 1. It is then possible to immediately start assembling another matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}","page":"Functions","title":"FinEtools.AssemblyModule.makematrix!","text":"makematrix!(self::SysmatAssemblerSparse)\n\nMake a sparse matrix.\n\nThe sparse matrix is returned.\n\nnote: Note\nIf nomatrixresult is set to true, dummy (zero) sparse matrices are returned. The entire result of the assembly is preserved in the assembler buffers. The ends of the buffers are filled with illegal (ignorable) values.\n\nnote: Note\nWhen the matrix is constructed (nomatrixresult is false), the buffers are not deallocated, and the buffer_pointer is set to 1. It is then possible to immediately start assembling another matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SV} where SV<:AbstractSysvecAssembler","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssemblerFBlock}","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssemblerFBlock)\n\nMake the global \"free\" vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}","page":"Functions","title":"FinEtools.AssemblyModule.makevector!","text":"makevector!(self::SysvecAssembler)\n\nMake the global vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SV}, Tuple{SV, Tuple{IT, IT}}} where {SV<:AbstractSysvecAssembler, IT}","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssembler{T}, ndofs_row::FInt) where {T<:Number}\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nelem_mat_nmatrices = number of element matrices expected to be processed during the assembly.\nndofs_row= Total number of degrees of freedom.\n\nReturns\n\nself: the modified assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SysmatAssemblerFFBlock, Vararg{IT, 5}}} where IT<:Integer","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerFFBlock,\n    elem_mat_nrows::IT,\n    elem_mat_ncols::IT,\n    n_elem_mats::IT,\n    row_nalldofs::IT,\n    col_nalldofs::IT;\n    force_init = false) where {IT <: Integer}\n\nStart assembly, delegate to the wrapped assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SysvecAssembler, IT}} where IT<:Integer","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssembler, ndofs_row)\n\nStart assembly.\n\nThe method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.\n\nndofs_row= Total number of degrees of freedom.\n\nReturns\n\nself: the modified assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{SysvecAssemblerFBlock, IT}} where IT<:Integer","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysvecAssemblerFBlock, row_nalldofs::IT) where {IT <: Integer}\n\nStart assembly.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseDiag{T, T1, MBT, IJT} where {T1, MBT<:AbstractVector{T1}, IJT<:AbstractVector{T}}, Vararg{IT, 5}}} where {T, IT<:Integer}","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseDiag{T},\n    elem_mat_nrows::IT,\n    elem_mat_ncols::IT,\n    n_elem_mats::IT,\n    row_nalldofs::IT,\n    col_nalldofs::IT;\n    force_init = false\n    ) where {T, IT<:Integer}\n\nStart the assembly of a symmetric square diagonal matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nArguments\n\nelem_mat_nrows = row dimension of the element matrix;\nelem_mat_ncols = column dimension of the element matrix;\nn_elem_mats = number of element matrices;\nrow_nalldofs= The total number of rows as a tuple;\ncol_nalldofs= The total number of columns as a tuple.\n\nThe values stored in the buffers are initially undefined!\n\nReturns\n\nself: the modified assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T, T1, MBT, IJT} where {T1, MBT<:AbstractVector{T1}, IJT<:AbstractVector{T}}, Vararg{IT, 5}}} where {T, IT<:Integer}","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},\n        elem_mat_nrows::IT,\n        elem_mat_ncols::IT,\n        n_elem_mats::IT,\n        row_nalldofs::IT,\n        col_nalldofs::IT;\n        force_init = false\n        ) where {T, IT<:Integer}\n\nStart the assembly of a symmetric lumped diagonal square global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nArguments\n\nelem_mat_nrows = row dimension of the element matrix;\nelem_mat_ncols = column dimension of the element matrix;\nn_elem_mats = number of element matrices;\nrow_nalldofs= The total number of rows as a tuple;\ncol_nalldofs= The total number of columns as a tuple.\n\nThe values stored in the buffers are initially undefined!\n\nReturns\n\nself: the modified assembler.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T, T1, MBT, IJT} where {T1, MBT<:AbstractVector{T1}, IJT<:AbstractVector{T}}, Vararg{IT, 5}}} where {T, IT<:Integer}","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparseSymm{T},\n    elem_mat_nrows::IT,\n    elem_mat_ncols::IT,\n    n_elem_mats::IT,\n    row_nalldofs::IT,\n    col_nalldofs::IT;\n    force_init = false\n    ) where {T, IT<:Integer}\n\nStart the assembly of a global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nArguments\n\nelem_mat_nrows = row dimension of the element matrix;\nelem_mat_ncols = column dimension of the element matrix;\nn_elem_mats = number of element matrices;\nrow_nalldofs= The total number of rows as a tuple;\ncol_nalldofs= The total number of columns as a tuple.\n\nIf the buffer_pointer field of the assembler is 0, which is the case after that assembler was created, the buffers are resized appropriately given the dimensions on input. Otherwise, the buffers are left completely untouched. The buffer_pointer is set to the beginning of the buffer, namely 1.\n\nReturns\n\nself: the modified assembler.\n\nnote: Note\nThe buffers may be automatically resized if more numbers are assembled then initially intended. However, this operation will not necessarily be efficient and fast.\n\nnote: Note\nThe buffers are initially not filled with anything meaningful. After the assembly, only the (self._buffer_pointer - 1) entries are meaningful numbers. Beware!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AssemblyModule.startassembly!-Union{Tuple{IT}, Tuple{T}, Tuple{SysmatAssemblerSparse{T, T1, MBT, IJT} where {T1, MBT<:AbstractVector{T1}, IJT<:AbstractVector{T}}, Vararg{IT, 5}}} where {T, IT<:Integer}","page":"Functions","title":"FinEtools.AssemblyModule.startassembly!","text":"startassembly!(self::SysmatAssemblerSparse{T},\n    elem_mat_nrows::IT,\n    elem_mat_ncols::IT,\n    n_elem_mats::IT,\n    row_nalldofs::IT,\n    col_nalldofs::IT;\n    force_init = false\n    ) where {T, IT<:Integer}\n\nStart the assembly of a global matrix.\n\nThe method makes buffers for matrix assembly. It must be called before the first call to the method assemble!.\n\nArguments\n\nelem_mat_nrows = row dimension of the element matrix;\nelem_mat_ncols = column dimension of the element matrix;\nn_elem_mats = number of element matrices;\nrow_nalldofs= The total number of rows as a tuple;\ncol_nalldofs= The total number of columns as a tuple.\n\nIf the buffer_pointer field of the assembler is 0, which is the case after that assembler was created, the buffers are resized appropriately given the dimensions on input. Otherwise, the buffers are left completely untouched. The buffer_pointer is set to the beginning of the buffer, namely 1.\n\nReturns\n\nself: the modified assembler.\n\nnote: Note\nThe buffers are initially not filled with anything meaningful. After the assembly, only the (self._buffer_pointer - 1) entries are meaningful numbers. Beware!\n\nnote: Note\nThe buffers may be automatically resized if more numbers are assembled then initially intended. However, this operation will not necessarily be efficient and fast.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing","page":"Functions","title":"Meshing","text":"","category":"section"},{"location":"man/functions.html#Meshing-with-line-elements","page":"Functions","title":"Meshing with line elements","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshLineModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2block-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshLineModule.L2block","text":"L2block(Length::T, nL::IT) where {T<:Number, IT<:Integer}\n\nMesh of a 1-D block of L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L2blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Functions","title":"FinEtools.MeshLineModule.L2blockx","text":"L2blockx(xs::Vector{T}) where {T<:Number}\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshLineModule.L3blockx-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Functions","title":"FinEtools.MeshLineModule.L3blockx","text":"L3blockx(xs::Vector{T}) where {T<:Number}\n\nGraded mesh of a 1-D block, L2 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-triangles","page":"Functions","title":"Meshing with triangles","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTriangleModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.Q4toT3","page":"Functions","title":"FinEtools.MeshTriangleModule.Q4toT3","text":"Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)\n\nConvert a mesh of quadrilateral Q4's to two T3 triangles  each.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3annulus","text":"T3annulus(rin::T, rex::T, nr::IT, nc::IT, angl::T, orientation::Symbol=:a)\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3block","text":"T3block(Length::T, Width::T, nL::IT, nW::IT, orientation::Symbol = :a\n    ) where {T<:Number, IT<:Integer}\n\nT3 mesh of a rectangle.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T<:Number","page":"Functions","title":"FinEtools.MeshTriangleModule.T3blockx","text":"T3blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, orientation::Symbol = :a\n    ) where {T<:Number}\n\nT3 mesh of a rectangle.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3circlen","text":"T3circlen(radius::T, nperradius::IT) where {T<:Number, IT<:Integer}\n\nMesh of a quarter circle with a given number of elements per radius.\n\nThe parameter nperradius should be an even  number; if that isn't so is adjusted to by adding one. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3circleseg-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3circleseg","text":"T3circleseg(\n    angle::T,\n    radius::T,\n    ncircumferentially::IT,\n    nperradius::IT,\n    orientation::Symbol = :a,\n) where {T<:Number, IT<:Integer}\n\nMesh of a segment of a circle.\n\nThe subtended angle is angle in radians. The orientation: refer to T3block.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet, FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3refine","text":"T3refine(fens::FENodeSet,fes::FESetT3)\n\nRefine a mesh of 3-node triangles by quadrisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet, FESetT3}","page":"Functions","title":"FinEtools.MeshTriangleModule.T3toT6","text":"T3toT6(fens::FENodeSet, fes::FESetT3)\n\nConvert a mesh of triangle T3 (three-node) to triangle T6.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}, Tuple{T, T, IT, IT, T, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T6annulus","text":"T6annulus(\n    rin::T,\n    rex::T,\n    nr::IT,\n    nc::IT,\n    angl::T,\n    orientation::Symbol = :a,\n) where {T<:Number, IT<:Integer}\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}, Tuple{T, T, IT, IT, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTriangleModule.T6block","text":"T6block(Length::T, Width::T, nL::IT, nW::IT, orientation::Symbol = :a\n    ) where {T<:Number, IT<:Integer}\n\nMesh of a rectangle of T6 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTriangleModule.T6blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, Symbol}} where T<:Number","page":"Functions","title":"FinEtools.MeshTriangleModule.T6blockx","text":"T6blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, orientation::Symbol = :a\n    ) where {T<:Number}\n\nGraded mesh of a 2-D block of T6 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-quadrilaterals","page":"Functions","title":"Meshing with quadrilaterals","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshQuadrilateralModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4annulus","text":"Q4annulus(rin::T, rex::T, nr::IT, nc::IT, Angl::T) where {T<:Number, IT<:Integer}\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4block","text":"Q4block(Length::T, Width::T, nL::IT, nW::IT) where {T<:Number, IT<:Integer}\n\nMesh of a rectangle, Q4 elements.\n\nDivided into elements: nL, nW in the first, second (x,y).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4blockx","text":"Q4blockx(xs::Vector{T}, ys::Vector{T})\n\nGraded mesh  of a rectangle, Q4 finite elements.\n\nMesh of a 2-D block, Q4 finite elements. The nodes are located at the Cartesian product of the two intervals on the input.  This allows for construction of graded meshes.\n\nxs,ys - Locations of the individual planes of nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4circlen-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4circlen","text":"Q4circlen(radius::T, nperradius::IT) where {T<:Number, IT<:Integer}\n\nMesh of a quarter circle with a given number of elements per radius.\n\nThe parameter nperradius should be an even  number; if that isn't so is adjusted to by adding one. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4elliphole","text":"Q4elliphole(\n    xradius::T,\n    yradius::T,\n    L::T,\n    H::T,\n    nL::IT,\n    nH::IT,\n    nW::IT,\n) where {T<:Number, IT<:Integer}\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radius of the ellipse, L,H= and dimensions of the plate, nL,nH= numbers of edges along the side of the plate; this also happens     to be the number of edges along the circumference of the elliptical     hole nW= number of edges along the remaining straight edge (from the hole     in the direction of the length),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4extrudeL2-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetL2, IT, F}} where {F<:Function, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4extrudeL2","text":"Q4extrudeL2(\n    fens::FENodeSet,\n    fes::FESetL2,\n    nLayers::IT,\n    extrusionh::F,\n) where {F<:Function, IT<:Integer}\n\nExtrude a mesh of linear segments into a mesh of quadrilaterals (Q4).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4quadrilateral","text":"Q4quadrilateral(xyz::Matrix{T}, nL::IT, nW::IT) where {T<:Number, IT<:Integer}\n\nMesh of a general quadrilateral given by the location of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet, FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4refine","text":"Q4refine(fens::FENodeSet, fes::FESetQ4)\n\nRefine a mesh of quadrilaterals by bisection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4spheren","text":"Q4spheren(radius::T, nperradius::IT) where {T<:Number, IT<:Integer}\n\nGenerate mesh of a spherical surface (1/8th of the sphere).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet, FESetQ4}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q4toQ8","text":"Q4toQ8(fens::FENodeSet, fes::FESetQ4)\n\nConvert a mesh of quadrilateral Q4 to quadrilateral Q8.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8annulus-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT, T}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8annulus","text":"Q8annulus(rin::T, rex::T, nr::IT, nc::IT, Angl::T) where {T<:Number, IT<:Integer}\n\nMesh of an annulus segment.\n\nMesh of an annulus segment, centered at the origin, with internal radius rin, and  external radiusrex, and  development angle Angl. Divided into elements:nr,nc` in the radial and circumferential direction respectively.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8block","text":"Q8block(Length::T, Width::T, nL::IT, nW::IT) where {T<:Number, IT<:Integer}\n\nMesh of a rectangle of Q8 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q8blockx","text":"Q8blockx(xs::Vector{T}, ys::Vector{T}) where {T<:Number, IT<:Integer}\n\nGraded mesh of a 2-D block of Q8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshQuadrilateralModule.Q9blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshQuadrilateralModule.Q9blockx","text":"Q9blockx(xs::Vector{T}, ys::Vector{T}) where {T<:Number}\n\nCreate a block of the quadratic Lagrangean Q9 nine-node quadrilaterals.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-tetrahedra","page":"Functions","title":"Meshing with tetrahedra","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshTetrahedronModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10block","text":"T10block(\n    Length::T,\n    Width::T,\n    Height::T,\n    nL::IT,\n    nW::IT,\n    nH::IT;\n    orientation::Symbol = :a,\n) where {T<:Number, IT<:Integer}\n\nGenerate a tetrahedral  mesh of T10 elements  of a rectangular block.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T<:Number","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10blockx","text":"T10blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, zs::VecOrMat{T}, orientation::Symbol = :a) where {T<:Number}\n\nGenerate a graded 10-node tetrahedral mesh  of a 3D block.\n\n10-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into six tetrahedra.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10cylindern","text":"T10cylindern(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T<:Number, IT<:Integer}\n\nTen-node tetrahedron mesh of solid  cylinder with given number of edges per radius.\n\nThe axis of the cylinder is along the Z axis. \n\nEven though the orientation is controllable, for some orientations the mesh is highly distorted (:a, :ca, :cb). So a decent mesh can only be expected for the orientation :b (default).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, VecOrMat{IT}, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10layeredplatex","text":"T10layeredplatex(\n    xs::VecOrMat{T},\n    ys::VecOrMat{T},\n    ts::VecOrMat{T},\n    nts::VecOrMat{IT},\n    orientation::Symbol = :a,\n) where {T<:Number, IT<:Integer}\n\nT10 mesh for a layered block (composite plate) with specified in plane coordinates.\n\nxs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer\n\nThe finite elements of each layer are labeled with the layer number, starting from 1 at the bottom.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10quartercyln","text":"T10quartercyln(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T<:Number, IT<:Integer}\n\nTen-node tetrahedron mesh of one quarter of solid  cylinder with given number of edges per radius.\n\nSee: T4quartercyln\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10refine-Tuple{FENodeSet, FESetT10}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10refine","text":"T10refine(fens::FENodeSet, fes::FESetT10)\n\nRefine the mesh of quadratic tetrahedra.\n\nEach tetrahedron is converted to eight tetrahedra (each face is quadri-sected).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T10toT4-Tuple{FENodeSet, FESetT10}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T10toT4","text":"T10toT4(fens::FENodeSet,  fes::FESetT4)\n\nConvert a mesh of tetrahedra of type T10 (quadratic 10-node) to tetrahedra T4.\n\nIf desired, the array of nodes may be compacted so that unconnected nodes are deleted.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}, Tuple{T, T, T, IT, IT, IT, Symbol}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4block","text":"T4block(\n    Length::T,\n    Width::T,\n    Height::T,\n    nL::IT,\n    nW::IT,\n    nH::IT,\n    orientation::Symbol = :a,\n) where {T<:Number, IT<:Integer}\n\nGenerate a tetrahedral mesh  of the 3D block.\n\nFour-node tetrahedra in a regular arrangement, with uniform spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into five or six tetrahedra, depending on the orientation: orientation = :a, :b generates 6 tetrahedra per cell. :ca, :cb generates 5 tetrahedra per cell.\n\nRange =<0, Length> x <0, Width> x <0, Height>. Divided into elements: nL x nW x nH.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4blockx-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}, Symbol}} where T<:Number","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4blockx","text":"T4blockx(xs::VecOrMat{T}, ys::VecOrMat{T}, zs::VecOrMat{T}, orientation::Symbol = :a) where {T<:Number}\n\nGenerate a graded tetrahedral mesh  of a 3D block.\n\nFour-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.\n\nThe mesh is produced by splitting each logical  rectangular cell into five or six tetrahedra: refer to T4block.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4cylindern","text":"T4cylindern(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T<:Number, IT<:Integer}\n\nFour-node tetrahedron mesh of solid  cylinder with given number of edges per radius.\n\nThe axis of the cylinder is along the Z axis. \n\nEven though the orientation is controllable, for some orientations the mesh is highly distorted (:a, :ca, :cb). So a decent mesh can only be expected for the orientation :b (default).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4extrudeT3-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetT3, IT, F}} where {F<:Function, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4extrudeT3","text":"T4extrudeT3(\n    fens::FENodeSet,\n    fes::FESetT3,\n    nLayers::IT,\n    extrusionh::F,\n) where {F<:Function, IT<:Integer}\n\nExtrude a mesh of triangles into a mesh of tetrahedra (T4).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4meshedges-Union{Tuple{Matrix{IT}}, Tuple{IT}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4meshedges","text":"T4meshedges(t::Array{IT,2}) where {IT<:Integer}\n\nCompute all the edges of the 4-node triangulation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4quartercyln-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4quartercyln","text":"T4quartercyln(R::T, L::T, nR::IT, nL::IT; orientation = :b) where {T<:Number, IT<:Integer}\n\nFour-node tetrahedron mesh of one quarter of solid  cylinder with given number of edges per radius.\n\nThe axis of the cylinder is along the Z axis. The mesh may be mirrored to create half a cylinder or a full cylinder.\n\nEven though the orientation is controllable, for some orientations the mesh is highly distorted (:a, :ca, :cb). So a decent mesh can only be expected for the orientation :b (default).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4refine-Tuple{FENodeSet, FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4refine","text":"T4refine(fens::FENodeSet, fes::FESetT4)\n\nRefine a mesh of 4-node tetrahedra by octasection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4refine20-Tuple{FENodeSet, FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4refine20","text":"T4refine20(fens::FENodeSet, fes::FESetT4)\n\nRefine a tetrahedral four-node mesh into another four-node tetrahedral mesh, with each original tetrahedron being subdivided into 20 new tetrahedra.\n\nEach vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4toT10-Tuple{FENodeSet, FESetT4}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4toT10","text":"T4toT10(fens::FENodeSet,  fes::FESetT4)\n\nConvert a mesh of tetrahedra of type T4 (four-node) to tetrahedra T10.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.T4voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, T, Vector{DataT}}} where {DataT<:Number, T}","page":"Functions","title":"FinEtools.MeshTetrahedronModule.T4voximg","text":"T4voximg(\n    img::Array{DataT,3},\n    voxdims::T,\n    voxval::Array{DataT,1},\n) where {DataT<:Number, T}\n\nGenerate a tetrahedral mesh  from three-dimensional image.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv","text":"tetv(X)\n\nCompute the volume of a tetrahedron.\n\nX = [0  4  3\n9  2  4\n6  1  7\n0  1  5] # for these points the volume is 10.0\ntetv(X)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, NTuple{12, T}} where T<:Number","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv","text":"tetv(X)\n\nCompute the volume of a tetrahedron.\n\nX = [0  4  3\n9  2  4\n6  1  7\n0  1  5] # for these points the volume is 10.0\ntetv(X)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv-Union{Tuple{T}, Tuple{Matrix{T}, Vararg{Int64, 4}}} where T","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv","text":"tetv(X)\n\nCompute the volume of a tetrahedron.\n\nX = Float64[0  4  3\n9  2  4\n6  1  7\n0  1  5] # for these points the volume is 10.0\ntetv(X, 1, 2, 3, 4)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshTetrahedronModule.tetv1times6-Union{Tuple{T}, Tuple{Matrix{T}, Vararg{Int64, 4}}} where T","page":"Functions","title":"FinEtools.MeshTetrahedronModule.tetv1times6","text":"tetv1times6(v, i1, i2, i3, i4)\n\nCompute 6 times the volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-with-hexahedra","page":"Functions","title":"Meshing with hexahedra","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshHexahedronModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20block","text":"H20block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T<:Number, IT<:Integer}\n\nCreate mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H20blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshHexahedronModule.H20blockx","text":"H20blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T<:Number}\n\nGraded mesh of a 3-D block of H20 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27block","text":"H27block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T<:Number, IT<:Integer}\n\nCreate mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H27blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshHexahedronModule.H27blockx","text":"H27blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T<:Number}\n\nGraded mesh of a 3-D block of H27 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8block-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8block","text":"H8block(Length::T, Width::T, Height::T, nL::IT, nW::IT, nH::IT) where {T<:Number, IT<:Integer}\n\nMake  a mesh  of a 3D block consisting of  eight node hexahedra.\n\nLength, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8blockx-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Number","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8blockx","text":"H8blockx(xs::Vector{T}, ys::Vector{T}, zs::Vector{T}) where {T<:Number}\n\nGraded mesh of a 3-D block of H8 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8cylindern-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8cylindern","text":"H8cylindern(Radius::T, Length::T, nperradius::IT, nL::IT) where {T<:Number, IT<:Integer}\n\nH8 mesh of a solid  cylinder with given number of edges per radius (nperradius) and per length (nL).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8elliphole-Union{Tuple{IT}, Tuple{T}, Tuple{T, T, T, T, T, Vararg{IT, 4}}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8elliphole","text":"H8elliphole(\n    xradius::T,\n    yradius::T,\n    L::T,\n    H::T,\n    T::T,\n    nL::IT,\n    nH::IT,\n    nW::IT,\n    nT::IT,\n) where {T<:Number, IT<:Integer}\n\nMesh of one quarter of a rectangular plate with an elliptical hole.\n\nxradius,yradius = radii of the ellipse, L,H = dimensions of the plate, Th = thickness of the plate nL,nH= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole nW = number of edges along the remaining straight edge (from the hole   in the radial direction),\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{IT}, Tuple{F}, Tuple{FENodeSet, FESetQ4, IT, F}} where {F<:Function, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8extrudeQ4","text":"H8extrudeQ4(\n    fens::FENodeSet,\n    fes::FESetQ4,\n    nLayers::IT,\n    extrusionh::F,\n) where {F<:Function, IT<:Integer}\n\nExtrude a mesh of quadrilaterals into a mesh of hexahedra (H8).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8hexahedron-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, IT, IT, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8hexahedron","text":"H8hexahedron(xyz::Matrix{T}, nL::IT, nW::IT, nH::IT; blockfun = nothing) where {T<:Number, IT<:Integer}\n\nMesh of a general hexahedron given by the location of the vertices.\n\nxyz = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). nL,  nW,  nH = number of elements in each direction blockfun = Optional argument: function of the block-generating mesh function      (having the signature of the function H8block()).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8layeredplatex-Union{Tuple{IT}, Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{IT}}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8layeredplatex","text":"H8layeredplatex(xs::Vector{T}, ys::Vector{T}, ts::Vector{T}, nts::Vector{IT}) where {T<:Number, IT<:Integer}\n\nH8 mesh for a layered block (composite plate) with specified in plane coordinates.\n\nxs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer\n\nThe finite elements of each layer are labeled with the layer number, starting from 1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet, FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8refine","text":"H8refine(fens::FENodeSet,  fes::FESetH8)\n\nRefine a mesh of H8 hexahedrals by octasection.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8sphere-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8sphere","text":"H8sphere(radius::T, nrefine::IT) where {T<:Number, IT<:Integer}\n\nCreate a mesh of 1/8 of the sphere of \"radius\". The  mesh will consist of\nfour hexahedral elements if \"nrefine==0\",  or more if \"nrefine>0\".\n\"nrefine\" is the number of bisections applied  to refine the mesh.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8spheren-Union{Tuple{IT}, Tuple{T}, Tuple{T, IT}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8spheren","text":"H8spheren(radius::T, nperradius::IT) where {T<:Number, IT<:Integer}\n\nCreate a solid mesh of 1/8 of sphere.\n\nCreate a solid mesh of 1/8 of the sphere of radius,  with nperradius elements per radius.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet, FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH20","text":"H8toH20(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H20.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet, FESetH8}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8toH27","text":"H8toH27(fens::FENodeSet,  fes::FESetH8)\n\nConvert a mesh of hexahedra H8 to hexahedra H27.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{T}, Tuple{DataT}, Tuple{Array{DataT, 3}, Vector{T}, Vector{DataT}}} where {DataT<:Number, T<:Number}","page":"Functions","title":"FinEtools.MeshHexahedronModule.H8voximg","text":"H8voximg(\n    img::Array{DataT,3},\n    voxdims::Vector{T},\n    voxval::Array{DataT,1},\n) where {DataT<:Number}\n\nGenerate a hexahedral mesh  from three-dimensional image.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet, FESetT4}","page":"Functions","title":"FinEtools.MeshHexahedronModule.T4toH8","text":"T4toH8(fens::FENodeSet, fes::FESetT4)\n\nConvert a tetrahedral four-node mesh into eight-node hexahedra.\n\nEach vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-selection","page":"Functions","title":"Mesh selection","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"See above as \"Selecting nodes and elements\".","category":"page"},{"location":"man/functions.html#Mesh-modification","page":"Functions","title":"Mesh modification","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshModificationModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet, BitVector}","page":"Functions","title":"FinEtools.MeshModificationModule.compactnodes","text":"compactnodes(fens::FENodeSet, connected::Vector{Bool})\n\nCompact the finite element node set by deleting unconnected nodes.\n\nfens = array of finite element nodes connected = The array element connected[j] is either 0 (when j is an   unconnected node), or a positive number (when node j is connected to   other nodes by at least one finite element)\n\nOutput\n\nfens = new set of finite element nodes new_numbering= array which tells where in the new fens array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      new_numbering[5] is 3.\n\nExamples\n\nLet us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactnodes(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.distortblock-Union{Tuple{IT}, Tuple{T}, Tuple{F}, Tuple{F, T, T, IT, IT, T, T}} where {F<:Function, T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshModificationModule.distortblock","text":"distortblock(\n    B::F,\n    Length::T,\n    Width::T,\n    nL::IT,\n    nW::IT,\n    xdispmul::T,\n    ydispmul::T,\n) where {F<:Function, T<:Number, IT<:Integer}\n\nDistort a block mesh by shifting around the nodes. The goal is to distort the horizontal and vertical mesh lines into slanted lines. This is useful when testing finite elements where special directions must be avoided.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.distortblock-Union{Tuple{T}, Tuple{FENodeSet{T}, T, T}} where T<:Number","page":"Functions","title":"FinEtools.MeshModificationModule.distortblock","text":"distortblock(ofens::FENodeSet{T}, xdispmul::T, ydispmul::T) where {T<:Number}\n\nDistort a block mesh by shifting around the nodes. The goal is to distort the horizontal and vertical mesh lines into slanted lines.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.element_coloring!-NTuple{6, Any}","page":"Functions","title":"FinEtools.MeshModificationModule.element_coloring!","text":"element_coloring!(element_colors, unique_colors, color_counts, fes, n2e, ellist)\n\nFind coloring of the elements such that no two elements of the same color share a node.\n\nCompute element coloring, supplying the current element colors and the list of elements to be assigned colors.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.element_coloring-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Vector{IT}}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshModificationModule.element_coloring","text":"element_coloring(fes, n2e, ellist::Vector{IT} = IT[]) where {IT<:Integer}\n\nFind coloring of the elements such that no two elements of the same color share a node.\n\nReturns the colors of the elements (color here means an integer), and a list of the unique colors (numbers).\n\nellist = list of elements to be assigned colors; other element colors may be looked at\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.fusenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, FENodeSet{T}, T}} where T<:Number","page":"Functions","title":"FinEtools.MeshModificationModule.fusenodes","text":"fusenodes(fens1::FENodeSet{T}, fens2::FENodeSet{T}, tolerance::T) where {T<:Number}\n\nFuse together nodes from two node sets.\n\nFuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, fens1 and fens2,  are fused together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the new  indexes of the nodes in the set fens1 are returned.\n\nThe set fens2 will be included unchanged, in the same order, in the node set fens. The indexes of the node set fens1 will have changed.\n\nExample\n\nAfter the call to this function we have k=new_indexes_of_fens1_nodes[j] is the node in the node set fens which used to be node j in node set fens1. The finite element set connectivity that used to refer to fens1 needs to be updated to refer to the same nodes in  the set fens as      updateconn!(fes, new_indexes_of_fens1_nodes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.interior2boundary-Union{Tuple{IT}, Tuple{Matrix{IT}, Matrix{IT}}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshModificationModule.interior2boundary","text":"interior2boundary(interiorconn::Array{IT,2}, extractb::Array{IT,2}) where {IT<:Integer}\n\nExtract the boundary connectivity from the connectivity of the interior.\n\nextractb = array that defines in which order the bounding faces are traversed. For     example, for tetrahedra this array is     extractb = [1 3 2; 1 2 4; 2 3 4; 1 4 3]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{FENodeSet{T}, T1, FENodeSet{T}, T2, T}} where {T, T1<:AbstractFESet, T2<:AbstractFESet}","page":"Functions","title":"FinEtools.MeshModificationModule.mergemeshes","text":"mergemeshes(\n    fens1::FENodeSet{T},\n    fes1::T1,\n    fens2::FENodeSet{T},\n    fes2::T2,\n    tolerance::T,\n) where {T, T1<:AbstractFESet, T2<:AbstractFESet}\n\nMerge together two meshes.\n\nMerge two meshes together by gluing together nodes within tolerance. The two meshes, fens1, fes1, and fens2, fes2, are glued together by merging the nodes that fall within a box of size tolerance. If tolerance is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.\n\nThe merged node set, fens, and the two finite element sets with renumbered  connectivities are returned.\n\nImportant notes: On entry into this function the connectivity of fes1 point into fens1 and the connectivity of fes2 point into fens2. After this function returns the connectivity of both fes1 and fes2 point into fens. The order of the nodes of the node set fens1 in the resulting set fens will have changed, whereas the order of the nodes of the node set fens2 is are guaranteed to be the same. Therefore, the connectivity of fes2 will in fact remain the same.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenmeshes-Union{Tuple{T}, Tuple{Array{Tuple{FENodeSet, AbstractFESet}}, T}} where T<:Number","page":"Functions","title":"FinEtools.MeshModificationModule.mergenmeshes","text":"mergenmeshes(meshes::Array{Tuple{FENodeSet{T},AbstractFESet}}, tolerance::T) where {T<:Number}\n\nMerge several meshes together.\n\nThe meshes are glued together by merging the nodes that fall within a box of size tolerance. If tolerance is set to zero, no merging of nodes is performed; the nodes from the meshes are simply concatenated together.\n\nOutput\n\nThe merged node set, fens, and an array of finite element sets with renumbered  connectivities are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Union{Tuple{IT}, Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T, AbstractVector{IT}}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(\n    fens::FENodeSet{T},\n    fes::AbstractFESet,\n    tolerance::T,\n    candidates::AbstractVector{IT},\n) where {T<:Number, IT<:Integer}\n\nMerge together  nodes of a single node set.\n\nSimilar to mergenodes(fens, fes, tolerance), but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mergenodes-Union{Tuple{T}, Tuple{FENodeSet{T}, AbstractFESet, T}} where T<:Number","page":"Functions","title":"FinEtools.MeshModificationModule.mergenodes","text":"mergenodes(fens::FENodeSet{T}, fes::AbstractFESet, tolerance::T) where {T<:Number}\n\nMerge together nodes of a single node set.\n\nMerge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size tolerance. The merged node set, fens, and the finite element set, fes, with renumbered  connectivities are returned.\n\nWarning: This tends to be an expensive operation!\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshboundary-Tuple{T} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshboundary","text":"meshboundary(fes::T) where {T<:AbstractFESet}\n\nCompute the boundary of a mesh defined by the given finite element set.\n\nArguments\n\nfes::T: The finite element set representing the mesh.\n\nReturns\n\nThe boundary of the mesh.\n\nExtract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet, T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.meshsmoothing","text":"meshsmoothing(fens::FENodeSet, fes::T; options...) where {T<:AbstractFESet}\n\nGeneral smoothing of meshes.\n\nKeyword options\n\nmethod = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\nReturn\n\nThe modified  node set.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{ET}, Tuple{FENodeSet, ET, Vector{T}, Vector{T}}} where {ET<:AbstractFESet, T<:Number}","page":"Functions","title":"FinEtools.MeshModificationModule.mirrormesh","text":"mirrormesh(\n    fens::FENodeSet,\n    fes::ET,\n    Normal::Vector{T},\n    Point::Vector{T};\n    kwargs...,\n) where {ET<:AbstractFESet, T<:Number}\n\nMirror a mesh in a plane given by its normal and one point.\n\nKeyword arguments\n\nrenumb = node renumbering function for the mirrored element\n\nWarning: The code to relies on the numbering of the finite elements: to reverse the orientation of the mirrored finite elements, the connectivity is listed in reverse order.   If the mirrored finite elements do not follow this rule (for instance hexahedra or quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.\n\nFor instance: H8 elements require the renumbering function to be supplied as\n\nrenumb = (c) -> c[[1, 4, 3, 2, 5, 8, 7, 6]]\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnincluded = Boolean array: is the node to be included in the partitioning or     not? npartitions = number of partitions, but note that the actual number of     partitions is going to be a power of two.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-$(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend\nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" $File`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning-2","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, npartitions)\n\nCompute the inertial-cut partitioning of the nodes.\n\nnpartitions = number of partitions, but note that the actual number of partitions will be a power of two.\n\nIn this variant all the nodes are to be included in the partitioning.\n\nThe partitioning can be visualized for instance as:\n\npartitioning = nodepartitioning(fens, npartitions)\npartitionnumbers = unique(partitioning)\nfor gp = partitionnumbers\n  groupnodes = findall(k -> k == gp, partitioning)\n  File =  \"partition-nodes-Dollar(gp).vtk\"\n  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))\nend\nFile =  \"partition-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" DollarFile`)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet, Any, Vector{Int64}}","page":"Functions","title":"FinEtools.MeshModificationModule.nodepartitioning","text":"nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})\n\nCompute the inertial-cut partitioning of the nodes.\n\nfesarr = array of finite element sets that represent regions npartitions = array of the number of partitions in each region. However note that the actual number of partitions will be a power of two.\n\nThe partitioning itself is carried out by nodepartitioning() with a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to the elements of that region, but not to elements that belong to any of the previous regions, 1…I-1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.outer_surface_of_solid-Union{Tuple{ET}, Tuple{FENodeSet, ET}} where ET<:AbstractFESet","page":"Functions","title":"FinEtools.MeshModificationModule.outer_surface_of_solid","text":"outer_surface_of_solid(fens, bdry_fes)\n\nFind the finite elements that form the outer boundary surface.\n\n!!! note:\n\nThe code will currently not work correctly for 2D axially symmetric geometries.\n\nReturn\n\nSet of boundary finite elements that enclose the solid. Now cavities  are included.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.pointpartitioning","page":"Functions","title":"FinEtools.MeshModificationModule.pointpartitioning","text":"pointpartitioning(xyz, npartitions::Int = 2)\n\nCompute the inertial-cut partitioning of a set of points.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshModificationModule.renumberconn!-Union{Tuple{IT}, Tuple{AbstractFESet, AbstractVector{IT}}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshModificationModule.renumberconn!","text":"renumberconn!(fes::AbstractFESet, new_numbering::AbstractVector{IT}) where {IT<:Integer}\n\nRenumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.\n\nfes =finite element set new_numbering = new serial numbers for the nodes.  The connectivity           should be changed as conn[j] –> new_numbering[conn[j]]\n\nLet us say there are nodes not connected to any finite element that we would like to remove from the mesh: here is how that would be accomplished.\n\nconnected = findunconnnodes(fens, fes);\nfens, new_numbering = compactnodes(fens, connected);\nfes = renumberconn!(fes, new_numbering);\n\nFinally, check that the mesh is valid:\n\nvalidate_mesh(fens, fes);\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.reordermesh-Tuple{Any, Any, Any}","page":"Functions","title":"FinEtools.MeshModificationModule.reordermesh","text":"reordermesh(fens, fes, ordering)\n\nReorder mesh (reshuffle nodes, renumber connectivities correspondingly).\n\nArguments\n\nfens: The set of mesh nodes.\nfes: The set of elements.\nordering: The desired ordering of the nodes and elements.\n\nReturns\n\nThe reordered mesh nodes and elements.\n\nThe ordering may come from Reverse Cuthill-McKey (package SymRCM).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vertexneighbors-Union{Tuple{IT}, Tuple{Matrix{IT}, IT}} where IT<:Integer","page":"Functions","title":"FinEtools.MeshModificationModule.vertexneighbors","text":"vertexneighbors(conn::Matrix{IT}, nvertices::IT) where {IT<:Integer}\n\nFind the node neighbors in the mesh.\n\nReturn an array of integer vectors, element I holds an array of numbers of nodes which are connected to node I (including node I).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshModificationModule.vsmoothing-Union{Tuple{IT}, Tuple{T}, Tuple{Matrix{T}, Matrix{IT}}} where {T<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.MeshModificationModule.vsmoothing","text":"vsmoothing(v::Matrix{T}, t::Matrix{IT}; kwargs...) where {T<:Number, IT<:Integer}\n\nInternal routine for mesh smoothing.\n\nKeyword options: method = :taubin (default) or :laplace fixedv = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) npass = number of passes (default 2)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Meshing-utilities","page":"Functions","title":"Meshing utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshUtilModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshUtilModule.addhyperface!-Tuple{Any, Any, Any}","page":"Functions","title":"FinEtools.MeshUtilModule.addhyperface!","text":"addhyperface!(container,hyperface,newn)\n\nAdd a hyper face to the container.\n\nThe new node is stored in hyper face data in the container and can be retrieved later.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.findhyperface!-Tuple{Any, Any}","page":"Functions","title":"FinEtools.MeshUtilModule.findhyperface!","text":"findhyperface!(container,hyperface)\n\nFind a hyper face in the container.\n\nIf the container holds the indicated hyper face, it is returned together with the stored new node number.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T, T, Int64}, Tuple{T, T, Int64, Any}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.gradedspace","text":"gradedspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate quadratic space.\n\nGenerate a quadratic sequence of N numbers between start and stop. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.\n\nExample\n\njulia> gradedspace(2.0, 3.0, 5)\n5-element Array{Float64,1}:\n 2.0\n 2.0625\n 2.25\n 2.5625\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.linearspace","text":"linearspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate linear space.\n\nGenerate a linear sequence of N numbers between  start and stop (i. e. sequence  of number with uniform intervals inbetween).\n\nExample\n\njulia> linearspace(2.0, 3.0, 5)\n2.0:0.25:3.0\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.logspace-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Number","page":"Functions","title":"FinEtools.MeshUtilModule.logspace","text":"logspace(start::T, stop::T, N::Int)  where {T<:Number}\n\nGenerate logarithmic space.\n\nGenerate a logarithmic sequence of N numbers between  start and stop (i. e. sequence  of number with uniform intervals inbetween in the log space).\n\nExample\n\njulia> logspace(2.0, 3.0, 5)                                                             \n5-element Array{Float64,1}:                                                              \n  100.0\n  177.82794100389228   \n  316.2277660168379      \n  562.341325190349  \n 1000.0    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshUtilModule.makecontainer","page":"Functions","title":"FinEtools.MeshUtilModule.makecontainer","text":"makecontainer()\n\nMake hyper face container.\n\nThis is a dictionary of hyper faces, indexed with an anchor node. The anchor node is the smallest node number within the connectivity of the hyper face.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshUtilModule.ontosphere-Union{Tuple{T}, Tuple{Matrix{T}, T}} where T","page":"Functions","title":"FinEtools.MeshUtilModule.ontosphere","text":"ontosphere(xyz::Matrix{T}, radius::T) where {T}\n\nProject nodes onto a sphere of given radius.\n\nArguments\n\nxyz::Matrix{T}: A matrix of shape (3, N) representing the coordinates of N points.\nradius::T: The radius of the sphere.\n\nReturns\n\nA matrix of shape (3, N) representing the coordinates of points on the sphere.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-import","page":"Functions","title":"Mesh import","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshImportModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_ABAQUS","text":"import_ABAQUS(filename)\n\nImport Abaqus mesh (.inp file).\n\nLimitations:\n\nOnly the *NODE and *ELEMENT  sections are read\nOnly 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 4-node quadrilaterals, 3-node triangles are handled.\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\"nsets\" = dictionary of \"node sets\", the keys are the names of the sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_H5MESH-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_H5MESH","text":"import_H5MESH(meshfile)\n\nImport mesh in the H5MESH format (.h5mesh file).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_MESH-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_MESH","text":"import_MESH(filename)\n\nImport mesh in the MESH format (.mesh, .xyz, .conn triplet of files).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\" = finite element nodes.\n\"fesets\" = array of finite element sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}","page":"Functions","title":"FinEtools.MeshImportModule.import_NASTRAN","text":"import_NASTRAN(filename)\n\nImport tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).\n\nLimitations:\n\nonly the GRID, CTETRA, and PSOLID sections are read.\nOnly 4-node and 10-node tetrahedra  are handled.\nThe file should be free-form (data separated by commas). \n\nSome fixed-format files can also be processed (large-field, but not small-field).\n\nOutput\n\nData dictionary, with keys \n\n\"fens\": set of finite element nodes, \n\"fesets\": array of finite element sets,\n\"property_ids\": array of property ids (integers) associated with the finite element sets.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Mesh-export","page":"Functions","title":"Mesh export","text":"","category":"section"},{"location":"man/functions.html#VTK","page":"Functions","title":"VTK","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.VTK]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String, Any, Any, Any}","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportmesh","text":"vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;\n    vectors=nothing, scalars=nothing)\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nArguments:\n\ntheFile = file name,\nConnectivity = array of connectivities, one row per element,\nPoints = array of node coordinates, one row per node,\nCell_type = type of the cell, refer to the predefined constants P1, L2, ..., H20, ...\nscalars = array of tuples, (name, data)\nvectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportmesh","text":"vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T<:AbstractFESet}\n\nExport mesh to a VTK 1.0 file as an unstructured grid.\n\nArguments:\n\ntheFile = file name,\nfens = finite element node set,\nfes = finite element set,\nopts = keyword argument list, where\nscalars = array of tuples, (name, data)\nvectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String, Any, Any}","page":"Functions","title":"FinEtools.MeshExportModule.VTK.vtkexportvectors","text":"vtkexportvectors(theFile::String, Points, vectors)\n\nExport vector data to a VTK 1.0 file.\n\nArguments:\n\ntheFile = file name,\nPoints = array of collection of coordinates (tuples or vectors), \nvectors = array of tuples, (name, data), where name is a string, and data is array of collection of coordinates (tuples or vectors).\n\nExample\n\nPoints = [(1.0, 3.0), (0.0, -1.0)]\nvectors = [(\"v\", [(-1.0, -2.0), (1.0, 1.0)])]\nvtkexportvectors(\"theFile.VTK\", Points, vectors)\n\nwill produce file with\n\n# vtk DataFile Version 1.0\nFinEtools Export\nASCII\n\nDATASET UNSTRUCTURED_GRID\nPOINTS 2 double\n1.0 3.0 0.0\n0.0 -1.0 0.0\n\n\nPOINT_DATA 2\nVECTORS v double\n-1.0 -2.0 0.0\n1.0 1.0 0.0\n\nnote: Note\nThe filter \"Glyph\" must be used within Paraview. Also in the drop-down  menu \"Glyph mode\" select \"all points\".\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Abaqus","page":"Functions","title":"Abaqus","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.Abaqus]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{AbaqusExporter}","page":"Functions","title":"Base.close","text":"close(self::AbaqusExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ASSEMBLY","text":"ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer, Any}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,  fixed_value)\n\nWrite out the *BOUNDARY option.\n\nNSET = name of a node set,\nis_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node,\nfixed_value=array of displacements to which the corresponding displacement components is fixed\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter, AbstractString, Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)\n\nWrite out the *BOUNDARY option to fix displacements at zero for a node set.\n\nInvoke at Level: Model,  Step\n\nNSET= node set,\ndof=Degree of freedom, 1, 2, 3\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F, AbstractString}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  value::F) where {F}\n\nWrite out the *BOUNDARY option to fix displacements at nonzero value for a node set.\n\nNSET= node set,\ndof=Degree of freedom, 1, 2, 3\ntyp = DISPLACEMENT\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, meshornset, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}\n\nWrite out the *BOUNDARY option.\n\nmeshornset = name of a mesh or a node set,\nis_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, as many columns as there are degrees of freedom per node,\nfixed_value=array of displacements to which the corresponding displacement components is fixed, as many columns as there are degrees of freedom per node\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter, Any, Any, AbstractMatrix{B}, AbstractMatrix{F}}} where {B, F}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.BOUNDARY","text":"BOUNDARY(self::AbaqusExporter, mesh, nodes, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}\n\nWrite out the *BOUNDARY option. \n\nThe boundary condition is applied to the nodes specified in  the array nodes, in the mesh (or node set) meshornset.\n\nmeshornset = mesh or node set (default is empty) nodes = array of node numbers, the node numbers are attached to the mesh label, is_fixed= array of Boolean flags (true means fixed, or prescribed),  one row per node, fixed_value=array of displacements to which the corresponding displacement components is fixed\n\nExample\n\nBOUNDARY(AE, \"ASSEM1.INSTNC1\", 1:4, fill(true, 4, 1), reshape([uy(fens.xyz[i, :]...) for i in 1:4], 4, 1))\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, Integer, F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.CLOAD","text":"CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nNSET=Node set dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, Integer, Integer, F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.CLOAD","text":"CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,\n  magnitude::F) where {F}\n\nWrite out the *CLOAD option.\n\nnodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.COMMENT","text":"COMMENT(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the ** comment option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter, Any}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.DENSITY","text":"DENSITY(self::AbaqusExporter, rho)\n\nWrite out the *DENSITY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractVector{F}}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.DLOAD","text":"DLOAD(self::AbaqusExporter, ELSET::AbstractString,\n  traction::AbstractVector{F}) where {F}\n\nWrite out the *DLOAD option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, F, F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ISOTROPIC option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter, Vararg{F, 9}}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELASTIC","text":"ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,\n  G12::F, G13::F, G23::F) where {F}\n\nWrite out the *ELASTIC,TYPE=ENGINEERING CONSTANTS option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractString, Integer, AbstractMatrix{T}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELEMENT","text":"ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,\n  start::Integer, conn::AbstractArray{T, 2}) where {T<:Integer}\n\nWrite out the *ELEMENT option.\n\nTYPE= element type code, ELSET= element set to which the elements belong, start= start the element numbering at this integer, conn= connectivity array for the elements, one row per element\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ELSET_ELSET","text":"ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T<:Integer}\n\nWrite out the *ELSET option.\n\nELSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter, AbstractString, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.EL_PRINT","text":"EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)\n\nWrite out the *EL PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY","text":"END_ASSEMBLY(self::AbaqusExporter)\n\nWrite out the *END ASSEMBLY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_INSTANCE","text":"END_INSTANCE(self::AbaqusExporter)\n\nWrite out the *END INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_PART","text":"END_PART(self::AbaqusExporter)\n\nWrite out the *END PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.END_STEP","text":"END_STEP(self::AbaqusExporter)\n\nWrite out the *END STEP option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT","text":"ENERGY_PRINT(self::AbaqusExporter)\n\nWrite out the *ENERGY PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter, F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.EXPANSION","text":"EXPANSION(self::AbaqusExporter, CTE::F) where {F}\n\nWrite out the *EXPANSION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.HEADING","text":"HEADING(self::AbaqusExporter, Text::AbstractString)\n\nWrite out the *HEADING option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter, AbstractString, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.INSTANCE","text":"INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)\n\nWrite out the *INSTANCE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.MATERIAL","text":"MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)\n\nWrite out the *MATERIAL option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractMatrix{T}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NODE","text":"NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}\n\nWrite out the *NODE option.\n\nxyz=array of node coordinates\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NODE_PRINT","text":"NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)\n\nWrite out the *NODE PRINT option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}}} where T<:Integer","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.NSET_NSET","text":"NSET_NSET(self::AbaqusExporter, NSET::AbstractString,\n  n::AbstractVector{T}) where {T<:Integer}\n\nWrite out the *NSET option.\n\nNSET = name of the set, n = array of the node numbers\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter, AbstractString, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.ORIENTATION","text":"ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,\n  a::AbstractArray{T,1}, b::AbstractArray{T,1})\n\nWrite out the *ORIENTATION option.\n\nInvoke at level: Part,  Part instance,  Assembly\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.PART","text":"PART(self::AbaqusExporter, NAME::AbstractString)\n\nWrite out the *PART option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter, AbstractString, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS","text":"SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,\n  OPTIONAL::AbstractString)\n\nWrite out the *SECTION CONTROLS option.\n\nOPTIONAL = string, for instance                      HOURGLASS=ENHANCED\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter, Vararg{AbstractString, 4}}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString,\n  CONTROLS::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter, AbstractString, AbstractString, AbstractString, F}} where F","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SOLID_SECTION","text":"SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,\n  ORIENTATION::AbstractString, ELSET::AbstractString)\n\nWrite out the *SOLID SECTION option.\n\nLevel: Part,  Part instance\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter, Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY","text":"STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)\n\nWrite out the *STEP,FREQUENCY option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter, Integer}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE","text":"STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)\n\nWrite out the *STEP,PERTURBATION option for linear buckling analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC","text":"STEP_PERTURBATION_STATIC(self::AbaqusExporter)\n\nWrite out the *STEP,PERTURBATION option for linear static analysis.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter, AbstractString}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION","text":"SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)\n\nWrite out the *SURFACE SECTION option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter, AbstractString, AbstractVector{I}, AbstractVector{F}}} where {I, F}","page":"Functions","title":"FinEtools.MeshExportModule.Abaqus.TEMPERATURE","text":"TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},\n  tlist::AbstractArray{F, 1}) where {I, F}\n\nWrite out the *TEMPERATURE option.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#NASTRAN","page":"Functions","title":"NASTRAN","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.NASTRAN]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{NASTRANExporter}","page":"Functions","title":"Base.close","text":"close(self::NASTRANExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK","text":"BEGIN_BULK(self::NASTRANExporter)\n\nTerminate the Case Control section by starting the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.CEND","text":"CEND(self::NASTRANExporter)\n\nTerminate the Executive Control section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.CTETRA-Tuple{NASTRANExporter, Int64, Int64, Vector{Int64}}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.CTETRA","text":"CTETRA(self::NASTRANExporter, eid::Int, pid::Int, conn::Vector{Int})\n\nWrite a statement for a single tetrahedron element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.ENDDATA","text":"ENDDATA(self::NASTRANExporter)\n\nTerminate the bulk section.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter, Int64, Any}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.GRID","text":"GRID(self::NASTRANExporter, n::Int, xyz)\n\nWrite a grid-point statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, T, T}, Tuple{NASTRANExporter, Int64, T, T, T}, Tuple{NASTRANExporter, Int64, Vararg{T, 4}}, Tuple{NASTRANExporter, Int64, Vararg{T, 5}}, Tuple{NASTRANExporter, Int64, Vararg{T, 6}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.MAT1","text":"MAT1(\n    self::NASTRANExporter,\n    mid::Int,\n    E::T,\n    nu::T,\n    rho::T = 0.0,\n    A::T = 0.0,\n    TREF::T = 0.0,\n    GE::T = 0.0,\n) where {T}\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.MAT1-Union{Tuple{T}, Tuple{NASTRANExporter, Int64, Vararg{T, 7}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.MAT1","text":"MAT1(\n    self::NASTRANExporter,\n    mid::Int,\n    E::T,\n    G::T,\n    nu::T,\n    rho::T,\n    A::T,\n    TREF::T,\n    GE::T,\n) where {T}\n\nWrite a statement for an isotropic elastic material.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter, Int64, Int64}","page":"Functions","title":"FinEtools.MeshExportModule.NASTRAN.PSOLID","text":"PSOLID(self::NASTRANExporter, pid::Int, mid::Int)\n\nWrite solid-property statement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#STL","page":"Functions","title":"STL","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.STL]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base.close-Tuple{STLExporter}","page":"Functions","title":"Base.close","text":"close(self::STLExporter)\n\nClose  the stream opened by the exporter.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.STL.endsolid","page":"Functions","title":"FinEtools.MeshExportModule.STL.endsolid","text":"endsolid(self::STLExporter, name::AbstractString = \"thesolid\")\n\nWrite statement to end the solid.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.MeshExportModule.STL.facet-Union{Tuple{T}, Tuple{STLExporter, Vector{T}, Vector{T}, Vector{T}}} where T","page":"Functions","title":"FinEtools.MeshExportModule.STL.facet","text":"facet(self::STLExporter, v1::Vector{T}, v2::Vector{T}, v3::Vector{T}) where {T}\n\nWrite a single facet.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.STL.solid","page":"Functions","title":"FinEtools.MeshExportModule.STL.solid","text":"solid(self::STLExporter, name::AbstractString = \"thesolid\")\n\nWrite a statement to begin the solid.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#CSV","page":"Functions","title":"CSV","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.CSV]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}","page":"Functions","title":"FinEtools.MeshExportModule.CSV.savecsv","text":"savecsv(name::String; kwargs...)\n\nSave arrays as a CSV file.\n\nExample:\n\nsavecsv(\"ab\", a = rand(3), b = rand(3))\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#H2Lib","page":"Functions","title":"H2Lib","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.H2Lib]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.H2Lib.h2libexporttri-Tuple{String, Any, Any}","page":"Functions","title":"FinEtools.MeshExportModule.H2Lib.h2libexporttri","text":"h2libexporttri(theFile::String, Connectivity, Points)\n\nWrite a file in the H2Lib format.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#VTKWrite","page":"Functions","title":"VTKWrite","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.VTKWrite]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTKWrite.vtkwrite-Tuple{String, Any, Any, Any}","page":"Functions","title":"FinEtools.MeshExportModule.VTKWrite.vtkwrite","text":"vtkwrite(theFile::String, Connectivity, Points, celltype; vectors=nothing, scalars=nothing)\n\nExport mesh to VTK as an unstructured grid (binary format).\n\nArguments:\n\ntheFile = file name,\nConnectivity = array of connectivities, one row per element,\nPoints = array of node coordinates, one row per node,\nCell_type = type of the cell, refer to the predefined    constants WriteVTK.P1, WriteVTK.L2, ..., WriteVTK.H20`, ...\nscalars = array of tuples, (name, data)\nvectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\nReturn the vtk file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTKWrite.vtkwrite-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.VTKWrite.vtkwrite","text":"vtkwrite(theFile::String, fens::FENodeSet, fes::T; opts...) where {T<:AbstractFESet}\n\nExport mesh to VTK as an unstructured grid (binary file).\n\nArguments:\n\ntheFile = file name,\nfens = finite element node set,\nfes = finite element set,\nopts = keyword argument list, where scalars = array of tuples,    (name, data), vectors = array of tuples, (name, data)\n\nFor the scalars: If data is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Tuple{String, Vararg{Any, 4}}","page":"Functions","title":"FinEtools.MeshExportModule.VTKWrite.vtkwritecollection","text":"vtkwritecollection(theFile::String, Connectivity, Points, celltype, times; vectors=nothing, scalars=nothing)\n\nWrite a collection of VTK files (.pvd file).\n\ntimes: array of times\n\nAll the other arguments are the same as for vtkwrite. If scalars or vectors are supplied, they correspond to the times in the times array.\n\nSee the vtkwritecollection methods.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.MeshExportModule.VTKWrite.vtkwritecollection-Union{Tuple{T}, Tuple{String, FENodeSet, T, Any}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.VTKWrite.vtkwritecollection","text":"vtkwritecollection(theFile::String, fens::FENodeSet, fes::T, times; opts...) where {T<:AbstractFESet}\n\nWrite a collection of VTK files (.pvd file).\n\ntimes: array of times\n\nAll the other arguments are the same as for vtkwrite. If scalars or vectors are supplied, they correspond to the times in the times array.\n\nSee the vtkwritecollection methods.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#H5MESH","page":"Functions","title":"H5MESH","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MeshExportModule.H5MESH]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MeshExportModule.H5MESH.write_H5MESH-Union{Tuple{T}, Tuple{String, FENodeSet, T}} where T<:AbstractFESet","page":"Functions","title":"FinEtools.MeshExportModule.H5MESH.write_H5MESH","text":"write_H5MESH(meshfile::String, fens::FENodeSet, fes::T) where {T<:AbstractFESet}\n\nWrite the mesh in the H5MESH format.\n\nThe mesh is stored in a HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FEM-machines","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Base","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.FEMMBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}}} where GFT","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::AbstractFEMM, geom::NodalField{GFT}) where {GFT}\n\nAssociate geometry field with the FEMM.\n\nThere may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.\n\nGeometry field is normally passed into any routine that evaluates some forms (integrals) over the mesh.  Whenever the geometry passed into a routine is not consistent with the one for which associategeometry!() was called before, associategeometry!() needs to be called with the new geometry field.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.bilform_convection-Union{Tuple{DC}, Tuple{QT}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, NodalField{QT}, DC}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, QT, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.bilform_convection","text":"bilform_convection(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    u::NodalField{T},\n    Q::NodalField{QT},\n    rhof::DC\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, QT, DC<:DataCache}\n\nCompute the sparse matrix implied by the bilinear form of the \"convection\" type.\n\nint_V  w rho mathbfu cdot nabla q  mathrmd V\n\nHere w is the scalar test function, mathbfu is the convective velocity, q is the scalar trial function, rho is the mass density; rho is computed by rhof, which is a given function(data). Both test and trial functions are assumed to be from the same approximation space. rhof is represented with DataCache, and needs to return a  scalar mass density.\n\nThe integral is with respect to the volume of the domain V (i.e. a three dimensional integral).\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global matrix;\ngeom = geometry field;\nu = convective velocity field;\nQ = nodal field to define the degree of freedom numbers;\nrhof= data cache, which is called to evaluate the coefficient rho, given the location of the integration point, the Jacobian matrix, and the finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.bilform_diffusion-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.bilform_diffusion","text":"bilform_diffusion(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    u::NodalField{T},\n    cf::DC\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}\n\nCompute the sparse matrix implied by the bilinear form of the \"diffusion\" type.\n\nint_V  nabla w cdot c cdot nabla u  mathrmd V\n\nHere nabla w is the gradient of the scalar test function, nabla u is the gradient of the scalar trial function, c is a square symmetric matrix of coefficients or a scalar; c is computed by cf, which is a given function (data). Both test and trial functions are assumed to be from the same approximation space. cf is represented with DataCache, and needs to return a symmetric square matrix (to represent general anisotropic diffusion) or a scalar (to represent isotropic diffusion).\n\nThe coefficient matrix c can be given in the so-called local material coordinates: coordinates that are attached to a material point and are determined by a local cartesian coordinates system (mcsys).\n\nThe integral is with respect to the volume of the domain V (i.e. a three dimensional integral).\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global matrix;\ngeom = geometry field;\nu = nodal field to define the degree of freedom numbers;\ncf= data cache, which is called to evaluate the coefficient c, given the location of the integration point, the Jacobian matrix, and the finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.bilform_div_grad-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.bilform_div_grad","text":"bilform_div_grad(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    u::NodalField{T},\n    viscf::DC\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}\n\nCompute the sparse matrix implied by the bilinear form of the \"div grad\" type.\n\nint_V  mu nabla mathbfw  nablamathbfu    mathrmd V\n\nHere mathbfw is the vector test function, mathbfu is the velocity, mu is the dynamic viscosity (or kinematic viscosity, depending on the formulation); mu is computed by viscf, which is a given function (data). Both test and trial functions are assumed to be from the same approximation space. viscf is represented with DataCache, and needs to return a  scalar viscosity.\n\nThe integral is with respect to the volume of the domain V (i.e. a three dimensional integral).\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global matrix;\ngeom = geometry field;\nu = velocity field;\nviscf= data cache, which is called to evaluate the coefficient mu, given the location of the integration point, the Jacobian matrix, and the finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.bilform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.bilform_dot","text":"bilform_dot(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    u::NodalField{T},\n    cf::DC\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}\n\nCompute the sparse matrix implied by the bilinear form of the \"dot\" type.\n\nint_Omega  mathbfw cdot mathbfc cdot mathbfu  mathrmd Omega\n\nHere mathbfw is the test function, mathbfu is the trial function, mathbfc is a square matrix of coefficients; mathbf c is computed by cf, which is a given function (data). Both trial and test functions are assumed to be vectors(even if of length 1). cf is represented with DataCache, and needs to return a square matrix, with dimension equal to the number of degrees of freedom per node in the u field.\n\nThe integral domain Omega can be the volume of the domain V (i.e. a three dimensional integral), or a surface S (i.e. a two dimensional integral), or a line domain L (i.e. a one dimensional integral).\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global object;\ngeom = geometry field;\nu = nodal field to define the degree of freedom numbers;\ncf= data cache, which is called to evaluate the coefficient c, given the location of the integration point, the Jacobian matrix, and the finite element label.\nm = manifold dimension (default is 3).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.bilform_lin_elastic-Union{Tuple{DC}, Tuple{MR}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, Type{MR}, DC}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, MR<:AbstractDeforModelRed, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.bilform_lin_elastic","text":"bilform_lin_elastic(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    u::NodalField{T},\n    cf::DC\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T, DC<:DataCache}\n\nCompute the sparse matrix implied by the bilinear form of the \"linearized elasticity\" type.\n\nint_V (B mathbfw)^T C  B mathbfu    mathrmd V\n\nHere mathbfw is the vector test function, mathbfu is the displacement (velocity), C is the elasticity (viscosity) matrix; C is computed by cf, which is a given function(data). Both test and trial functions are assumed to be from the same approximation space. cf is represented with DataCache, and needs to return a matrix of the appropriate size.\n\nThe integral is with respect to the volume of the domain V (i.e. a three dimensional integral).\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global matrix;\ngeom = geometry field;\nu = velocity field;\nviscf= data cache, which is called to evaluate the coefficient mu, given the location of the integration point, the Jacobian matrix, and the finite element label.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, Any}} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.connectionmatrix","text":"connectionmatrix(self::FEMM, nnodes) where {FEMM<:AbstractFEMM}\n\nCompute the connection matrix.\n\nThe matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.distribloads-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, ForceIntensity, Any}} where {FEMM<:AbstractFEMM, A<:AbstractSysvecAssembler, FT<:Number, T}","page":"Functions","title":"FinEtools.FEMMBaseModule.distribloads","text":"distribloads(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    P::NodalField{T},\n    fi::ForceIntensity,\n    m,\n) where {FEMM<:AbstractFEMM, A<:AbstractSysvecAssembler, FT<:Number, T}\n\nCompute distributed loads vector.\n\nArguments\n\nfi=force intensity object\nm= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads m is set to 3, for tractions on the surface it is set to 2, and so on.\n\nThe actual work is done by linform_dot().\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.dualconnectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM, FENodeSet}, Tuple{FEMM, FENodeSet, Any}} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.dualconnectionmatrix","text":"dualconnectionmatrix(\n    self::FEMM,\n    fens::FENodeSet,\n    minnodes = 1,\n) where {FEMM<:AbstractFEMM}\n\nCompute the dual connection matrix.\n\nThe matrix has a nonzero in all the rows and columns which correspond to elements connected by some finite element nodes.\n\nminnodes: minimum number of nodes that the elements needs to share in order to be neighbors (default 1)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM<:AbstractFEMM, GFT<:Number, UFT<:Number, TFT<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FEMMBaseModule.elemfieldfromintegpoints","text":"elemfieldfromintegpoints(\n    self::FEMM,\n    geom::NodalField{GFT},\n    u::NodalField{UFT},\n    dT::NodalField{TFT},\n    quantity::Symbol,\n    component::AbstractVector{IT};\n    context...,\n) where {FEMM<:AbstractFEMM, GFT<:Number, UFT<:Number, TFT<:Number, IT<:Integer}\n\nConstruct elemental field from integration points.\n\nArguments\n\ngeom     - reference geometry field u        - displacement field dT       - temperature difference field quantity   - this is what you would assign to the 'quantity' argument            of the material update!() method. component- component of the 'quantity' array: see the material update()            method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.ev_integrate-Union{Tuple{R}, Tuple{DC}, Tuple{FT}, Tuple{FEMM}, Tuple{FEMM, NodalField{FT}, DC, R, Any}} where {FEMM<:AbstractFEMM, FT<:Number, DC<:DataCache, R}","page":"Functions","title":"FinEtools.FEMMBaseModule.ev_integrate","text":"ev_integrate(\n        self::FEMM,\n        geom::NodalField{FT},\n        f::DC,\n        initial::R,\n        m,\n) where {FEMM<:AbstractFEMM, FT<:Number, DC<:DataCache, R}\n\nCompute the integral of a given function over a mesh domain.\n\nint_Omega  f  mathrmd Omega\n\nHere f is a given function (data).  The data f is represented with DataCache.\n\nArguments\n\nself = finite element machine;\ngeom = geometry field;\nf= data cache, which is called to evaluate the integrand based on the location, the Jacobian matrix, the finite element identifier, and the quadrature point;\ninitial = initial value of the integral,\nm= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads m is set to 3, for tractions on the surface it is set to 2, and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.field_elem_to_nodal!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, EFL, NFL}} where {FT, T<:Number, EFL<:(ElementalField{T}), NFL<:(NodalField{T})}","page":"Functions","title":"FinEtools.FEMMBaseModule.field_elem_to_nodal!","text":"field_elem_to_nodal!(\n    self::AbstractFEMM,\n    geom::NodalField{FT},\n    ef::EFL,\n    nf::NFL;\n    kind = :weighted_average,\n) where {FT, T<:Number, EFL<:ElementalField{T}, NFL<:NodalField{T}}\n\nMake a nodal field  from an elemental field over the discrete manifold.\n\nef = ELEMENTAL field to supply the values nf = NODAL field to receive the values kind = default is :weighted_average; other options: :max\n\nReturns nf.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.field_nodal_to_elem!-Union{Tuple{NFL}, Tuple{EFL}, Tuple{T}, Tuple{FT}, Tuple{AbstractFEMM, NodalField{FT}, NFL, EFL}} where {FT<:Number, T, EFL<:(ElementalField{T}), NFL<:(NodalField{T})}","page":"Functions","title":"FinEtools.FEMMBaseModule.field_nodal_to_elem!","text":"field_nodal_to_elem!(\n    self::AbstractFEMM,\n    geom::NodalField{FT},\n    nf::NFL,\n    ef::EFL;\n    kind = :weighted_average,\n) where {FT<:Number, T, EFL<:ElementalField{T}, NFL<:NodalField{T}}\n\nMake an elemental field  from a nodal field over the discrete manifold.\n\nnf = NODAL field to supply the values ef = ELEMENTAL field to receive the values kind = default is :weighted_average; other options: :max\n\nReturns ef.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{IT}, Tuple{TFT}, Tuple{UFT}, Tuple{GFT}, Tuple{FEMM}, Tuple{FEMM, NodalField{GFT}, NodalField{UFT}, NodalField{TFT}, Symbol, AbstractVector{IT}}} where {FEMM<:AbstractFEMM, GFT<:Number, UFT<:Number, TFT<:Number, IT<:Integer}","page":"Functions","title":"FinEtools.FEMMBaseModule.fieldfromintegpoints","text":"fieldfromintegpoints(\n    self::FEMM,\n    geom::NodalField{GFT},\n    u::NodalField{UFT},\n    dT::NodalField{TFT},\n    quantity::Symbol,\n    component::AbstractVector{IT};\n    context...,\n) where {FEMM<:AbstractFEMM, GFT<:Number, UFT<:Number, TFT<:Number, IT<:Integer}\n\nConstruct nodal field from integration points.\n\nArguments\n\ngeom     - reference geometry field\nu        - displacement field\ndT       - temperature difference field\nquantity   - this is what you would assign to the 'quantity' argument          of the material update!() method.\ncomponent- component of the 'quantity' array: see the material update()          method.\n\nKeyword arguments\n\nnodevalmethod = :invdistance (the default) or :averaging;\nreportat = at which point should the  element quantities be reported?   This argument is interpreted inside the inspectintegpoints() method.\n\nOutput\n\nthe new field that can be used to map values to colors and so on\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.finite_elements-Tuple{FEMM} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.finite_elements","text":"finite_elements(self::FEMM) where {FEMM <: AbstractFEMM}\n\nRetrieve the finite element set for this FEMM to work on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}}} where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T}","page":"Functions","title":"FinEtools.FEMMBaseModule.innerproduct","text":"innerproduct(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    afield::NodalField{T},\n) where {FEMM<:AbstractFEMM, A<:AbstractSysmatAssembler, FT, T}\n\nCompute the inner-product (Gram) matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMM,\n    geom::NodalField{GFT},\n    u::NodalField{FT},\n    dT::NodalField{FT},\n    felist::AbstractVector{IT},\n    inspector::F,\n    idat,\n    quantity = :Cauchy;\n    context...,) where {FEMM<:AbstractFEMM, GFT, IT, FT, F <: Function}\n\nInspect integration points.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL<:(ElementalField{T}), F<:Function, R}","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(\n    self::AbstractFEMM,\n    geom::NodalField{GFT},\n    afield::FL,\n    fh::F;\n    initial::R = zero(FT),\n    m = -1,\n) where {GFT, T, FL<:ElementalField{T}, F<:Function,R}\n\nIntegrate a elemental-field function over the discrete manifold.\n\nafield = ELEMENTAL field to supply the value within the element (one value per element),\nfh = function taking position and an array of field values for the element as arguments, returning value of type R.  The function fh must take two arguments, x which is the location, and val which is the value of the field at that location. The rectangular array of field values val  has one row, and as many columns as there are degrees of freedom per node.\nm = dimension of the manifold over which to integrate; m < 0 means that the dimension is controlled by the manifold dimension of the elements.\n\nIntegrates a  function returning a scalar value of type R, which is initialized by initial.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{R}, Tuple{F}, Tuple{FL}, Tuple{T}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, FL, F}} where {GFT, T, FL<:(NodalField{T}), F<:Function, R}","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefieldfunction","text":"integratefieldfunction(\n    self::AbstractFEMM,\n    geom::NodalField{GFT},\n    afield::FL,\n    fh::F;\n    initial::R,\n    m = -1,\n) where {GFT, T, FL<:NodalField{T}, F<:Function,R}\n\nIntegrate a nodal-field function over the discrete manifold.\n\nafield = NODAL field to supply the values at the nodes, which are interpolated to the quadrature points,\nfh = function taking position and an array of field values for the element as arguments, returning value of type R.  The function fh must take two arguments, x which is the location, and val which is the value of the field at that location. The rectangular array of field values val  has one row, and as many columns as there are degrees of freedom per node.\nm = dimension of the manifold over which to integrate; m < 0 means that the dimension is controlled by the manifold dimension of the elements.\n\nIntegrates a  function returning a scalar value of type R, which is initialized by initial.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{R}, Tuple{F}, Tuple{GFT}, Tuple{AbstractFEMM, NodalField{GFT}, F}} where {GFT<:Number, F<:Function, R<:Number}","page":"Functions","title":"FinEtools.FEMMBaseModule.integratefunction","text":"integratefunction(\n    self::AbstractFEMM,\n    geom::NodalField{GFT},\n    fh::F;\n    initial::R = zero(typeof(fh(zeros(ndofs(geom), 1)))),\n    m = -1,\n) where {GFT<:Number, F<:Function, R<:Number}\n\nIntegrate a function over the discrete manifold.\n\nIntegrate some scalar function over the geometric cells. The function takes a single argument, the position vector.\n\nWhen the scalar function returns just +1 (such as (x) ->  1.0), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.\n\nExample:\n\nCompute the volume of the mesh and then its center of gravity:\n\nV = integratefunction(femm, geom, (x) ->  1.0, 0.0)\nSx = integratefunction(femm, geom, (x) ->  x[1], 0.0)\nSy = integratefunction(femm, geom, (x) ->  x[2], 0.0)\nSz = integratefunction(femm, geom, (x) ->  x[3], 0.0)\nCG = vec([Sx Sy Sz]/V)\n\nCompute a moment of inertia of the mesh relative to the origin:\n\nIxx = integratefunction(femm, geom, (x) ->  x[2]^2 + x[3]^2)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.iselementbased-Tuple{FEMM} where FEMM<:AbstractFEMM","page":"Functions","title":"FinEtools.FEMMBaseModule.iselementbased","text":"iselementbased(self::FEMM) where {FEMM <: AbstractFEMM}\n\nIs the FEMM element-based? (This will only be false for nodal-integration formulations.)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.linform_dot-Union{Tuple{DC}, Tuple{T}, Tuple{FT}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM, A, NodalField{FT}, NodalField{T}, DC, Any}} where {FEMM<:AbstractFEMM, A<:AbstractSysvecAssembler, FT<:Number, T, DC<:DataCache}","page":"Functions","title":"FinEtools.FEMMBaseModule.linform_dot","text":"linform_dot(\n    self::FEMM,\n    assembler::A,\n    geom::NodalField{FT},\n    P::NodalField{T},\n    f::DC,\n    m,\n) where {FEMM<:AbstractFEMM, A<:AbstractSysvecAssembler, FT<:Number, T, DC<:DataCache}\n\nCompute the discrete vector implied by the linear form \"dot\".\n\nint_V  mathbfw cdot mathbff  mathrmd V\n\nHere mathbfw is the test function, mathbff is a given function (data). Both are assumed to be vectors,  even if they are of length 1, representing scalars. The data mathbff is represented with DataCache.\n\nArguments\n\nself = finite element machine;\nassembler = assembler of the global vector;\ngeom = geometry field;\nP = nodal field to define the degree of freedom numbers;\nf= data cache, which is called to evaluate the integrand based on the location, the Jacobian matrix, the finite element identifier, and the quadrature point;\nm= manifold dimension, 0= vertex (point), 1= curve, 2= surface, 3= volume. For body loads m is set to 3, for tractions on the surface it is set to 2, and so on.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT<:Number, T, F<:(ElementalField{T})}","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(\n    ff::F,\n    fensf::FENodeSet{FT},\n    fesf::AbstractFESet,\n    fc::F,\n    fensc::FENodeSet{FT},\n    fesc::AbstractFESet,\n    geometricaltolerance::FT;\n    parametrictolerance::FT = 0.01,\n) where {FT<:Number, F<:ElementalField{T}, T}\n\nTransfer an elemental field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ntolerance = tolerance in physical space for searches of the adjacent nodes\n\nOutput\n\nElemental field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{FT}, Tuple{F, FENodeSet{FT}, AbstractFESet, F, FENodeSet{FT}, AbstractFESet, FT}} where {FT<:Number, T, F<:(NodalField{T})}","page":"Functions","title":"FinEtools.FEMMBaseModule.transferfield!","text":"transferfield!(\n    ff::F,\n    fensf::FENodeSet{FT},\n    fesf::AbstractFESet,\n    fc::F,\n    fensc::FENodeSet{FT},\n    fesc::AbstractFESet,\n    geometricaltolerance::FT;\n    parametrictolerance::FT = 0.01,\n) where {FT<:Number, F<:NodalField{T}, T}\n\nTransfer a nodal field from a coarse mesh to a finer one.\n\nArguments\n\nff = the fine-mesh field (modified and also returned)\nfensf = finite element node set for the fine-mesh\nfc = the coarse-mesh field\nfensc = finite element node set for the fine-mesh,\nfesc = finite element set for the coarse mesh\ngeometricaltolerance = tolerance in physical space for searches of the adjacent nodes\nparametrictolerance = tolerance in parametric space for for check whether node is inside an element\n\nOutput\n\nNodal field ff transferred to the fine mesh is output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Base-2","page":"Functions","title":"Base","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.AlgoBaseModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.bisect-NTuple{5, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.bisect","text":"bisect(fun, xl, xu, tolx, tolf)\n\nImplementation of the bisection method.\n\nTolerance both on x and on f(x) is used.\n\nfun = function,\nxl= lower value of the bracket,\nxu= upper Value of the bracket,\ntolx= tolerance on the location of the root,\ntolf= tolerance on the function value\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.bisect-NTuple{7, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.bisect","text":"bisect(fun, xl, xu, fl, fu, tolx, tolf)\n\nImplementation of the bisection method.\n\nTolerance both on x and on f(x) is used.\n\nfun = function,\nxl,xu= lower and upper value of the bracket,\nfl,fu= function value at the lower and upper limit of the bracket.\n\nThe true values must have opposite signs (that is they must constitute a bracket). Otherwise  this algorithm will fail.\n\ntolx= tolerance on the location of the root,\ntolf= tolerance on the function value\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{MT}, Tuple{MT, Vector{T}, Vector{T}, Any}} where {MT, T<:Number}","page":"Functions","title":"FinEtools.AlgoBaseModule.conjugategradient","text":"conjugategradient(A::MT, b::Vector{T}, x0::Vector{T}, maxiter) where {MT, T<:Number}\n\nCompute one or more iterations of the conjugate gradient process.  \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.evalconvergencestudy","text":"evalconvergencestudy(modeldatasequence)\n\nEvaluate a convergence study from a model-data sequence.  \n\nmodeldatasequence = array of modeldata dictionaries. At least two must be included.\n\nRefer to methods fieldnorm and fielddiffnorm for details  on the required keys in the dictionaries.\n\nOutput\n\nelementsizes = element size array, \nerrornorms = norms of the error, \nconvergencerate = rate of convergence\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fielddiffnorm","text":"fielddiffnorm(modeldatacoarse, modeldatafine)\n\nCompute norm of the difference of the fields.  \n\nArguments\n\nmodeldatacoarse, modeldatafine = data dictionaries.\n\nFor both the \"coarse\"- and \"fine\"-mesh modeldata the data dictionaries need to contain the mandatory keys:\n\n\"fens\" = finite element node set\n\"regions\" = array of regions\n\"targetfields\" = array of fields, one for each region\n\"geom\" = geometry field\n\"elementsize\" = representative element size,\n\"geometricaltolerance\" = geometrical tolerance (used in field transfer; refer to the documentation of transferfield!)\n\"parametrictolerance\" = parametric tolerance (used in field transfer; refer to the documentation of transferfield!)\n\nOutput\n\nNorm of the field as floating-point scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.fieldnorm","text":"fieldnorm(modeldata)\n\nCompute norm of the target field.  \n\nArgument\n\nmodeldata = data dictionary, mandatory keys:\nfens = finite element node set\nregions = array of regions\ntargetfields = array of fields, one for each region\ngeom = geometry field\nelementsize = representative element size,\n\nOutput\n\nNorm of the field as floating-point scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.matrix_blocked","page":"Functions","title":"FinEtools.AlgoBaseModule.matrix_blocked","text":"matrix_blocked(A, row_nfreedofs, col_nfreedofs = row_nfreedofs)\n\nPartition matrix into blocks.\n\nThe function returns the sparse matrix as a named tuple of its constituent blocks. The matrix is assumed to be composed of four blocks\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nThe named tuple is the value (ff = A_ff, fd = A_fd, df = A_df, dd = A_dd). Index into this named tuple to retrieve the parts of the matrix that you want.\n\nHere f stands for free, and d stands for data (i.e. fixed, prescribed, ...). The size of the ff block is row_nfreedofs, col_nfreedofs. Neither one of the blocks is square, unless row_nfreedofs == col_nfreedofs.\n\nWhen row_nfreedofs == col_nfreedofs, only the number of rows needs to be given.\n\nExample\n\nBoth\n\nK_ff, K_fd = matrix_blocked(K, nfreedofs, nfreedofs)[(:ff, :fd)]\nK_ff, K_fd = matrix_blocked(K, nfreedofs)[(:ff, :fd)]\n\ndefine a square K_ff matrix and, in general a rectangular, matrix K_fd.\n\nThis retrieves all four partitions of the matrix\n\nA_ff, A_fd, A_df, A_dd = matrix_blocked(A, nfreedofs)[(:ff, :fd, :df, :dd)]\n\nThis retrieves the complete named tuple, and then the matrices can be referenced with a dot syntax.\n\nA_b = matrix_blocked(A, nfreedofs, nfreedofs)\n@test size(A_b.ff) == (nfreedofs, nfreedofs)\n@test size(A_b.fd) == (nfreedofs, size(A, 1) - nfreedofs)\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.penaltyebc!","text":"penaltyebc!(K, F, dofnums, prescribedvalues, penfact)\n\nApply penalty essential boundary conditions.\n\nArguments\n\nK = stiffness matrix\nF = global load vector \ndofnums, prescribedvalues = arrays computed by prescribeddofs()\npenfact = penalty multiplier, in relative terms: how many times the maximum absolute value of the diagonal elements should the penalty term be?\n\nOutput\n\nUpdated matrix K and vector F.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qcovariance-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}, VecOrMat{T}}} where T<:Number","page":"Functions","title":"FinEtools.AlgoBaseModule.qcovariance","text":"qcovariance(ps::VecOrMat{T}, xs::VecOrMat{T}, ys::VecOrMat{T}; ws = nothing) where {T<:Number}\n\nCompute the covariance for two 'functions' given by the arrays xs and ys  at the values of the parameter ps. ws is the optional weights vector;   if it is not supplied, uniformly distributed default weights are assumed.  \n\nNotes: \n\n– The mean is subtracted from both functions.  – This function is not particularly efficient: it computes the mean of both   functions and it allocates arrays instead of overwriting the contents of the   arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qtrap-Union{Tuple{T}, Tuple{VecOrMat{T}, VecOrMat{T}}} where T<:Number","page":"Functions","title":"FinEtools.AlgoBaseModule.qtrap","text":"qtrap(ps::VecOrMat{T}, xs::VecOrMat{T}) where {T<:Number}\n\nCompute the area under the curve given by a set of parameters along  an interval and the values of the 'function' at those parameter values.   The parameter values need not be uniformly distributed.\n\nTrapezoidal rule is used to evaluate the integral. The 'function' is  assumed to vary linearly inbetween the given points.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.qvariance-Tuple{Any, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.qvariance","text":"qvariance(ps, xs; ws = nothing)\n\nCompute the variance of a function given by the array xs at  the values of the parameter ps. ws is the optional weights vector   with unit default weights.    \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractArray)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapol","text":"richextrapol(solns::T, params::T; lower_conv_rate = 0.001, upper_conv_rate = 10.0) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArguments\n\nsolns =  array of three solution values\nparams = array of values of three parameters for which the solns have been obtained. \n\nThe assumption is that the error of the solution is expanded in a Taylor series, and only the first term in the Taylor series is kept.     qex - qapprox ~ C param^beta Here qex is the true solution, qapprox is an approximate solution, param is the element size, or the relative element size, in other words the parameter of the extrapolation, and beta is the convergence rate. The constant C is  the third unknown quantity in this expansion. If we obtain three successive  approximations, we can solve for the three unknown quantities, qex, beta,  and C.\n\nIt is assumed that the first solution is obtained for the largest value of the extrapolation parameter, while the last solution in the list is obtained for the smallest value of the extrapolation parameter:      params[1] > params[2] > params[3]\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nmaxresidual = maximum residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractArray)","page":"Functions","title":"FinEtools.AlgoBaseModule.richextrapoluniform","text":"richextrapoluniform(solns::T, params::T) where {T<:AbstractArray{Tn} where {Tn}}\n\nRichardson extrapolation.\n\nArgument\n\nsolns =  array of solution values\nparams = array of values of parameters for which the solns have been obtained. This function is applicable only to fixed (uniform) ratio between the mesh sizes, params[1]/params[2) = params[2)/params[3).\n\nOutput\n\nsolnestim= estimate of the asymptotic solution from the data points in the solns array\nbeta= convergence rate\nc = constant in the estimate error=c*h^beta\nresidual = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.solve_blocked!-Union{Tuple{V}, Tuple{M}, Tuple{AF}, Tuple{AF, M, V}} where {AF<:AbstractField, M<:(AbstractMatrix), V<:(AbstractVector)}","page":"Functions","title":"FinEtools.AlgoBaseModule.solve_blocked!","text":"solve_blocked!(u::AF, K::M, F::V) where {AF<:AbstractField, M<:AbstractMatrix, V<:AbstractVector}\n\nSolve a system of linear algebraic equations.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.solve_blocked-Union{Tuple{IT}, Tuple{VX}, Tuple{VB}, Tuple{M}, Tuple{M, VB, VX, IT}} where {M<:(AbstractMatrix), VB<:(AbstractVector), VX<:(AbstractVector), IT<:Integer}","page":"Functions","title":"FinEtools.AlgoBaseModule.solve_blocked","text":"solve_blocked(A::M, b::VB, x::VX, nfreedofs::IT) where {M<:AbstractMatrix, VB<:AbstractVector, VX<:AbstractVector, IT<:Integer}\n\nSolve a blocked system of linear algebraic equations.\n\nThe matrix is blocked as\n\nA = [A_ff A_fd\n     A_df A_dd]\n\nand the solution and the righthand side vector are blocked accordingly\n\nx = [x_f\n     x_d]\n\nand\n\nb = [b_f\n     b_d]\n\nAbove, b_f andxdare known,xf(solution) andb_d` (reactions) need to be computed.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.AlgoBaseModule.vector_blocked-Tuple{Any, Any}","page":"Functions","title":"FinEtools.AlgoBaseModule.vector_blocked","text":"vector_blocked(V, row_nfreedofs, which = (:all, ))\n\nPartition vector into two pieces.\n\nThe vector is composed of two blocks\n\nV = [V_f\n     V_d]\n\nwhich are returned as a named tuple (f = V_f, d = V_d).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-model-abstractions","page":"Functions","title":"Material model abstractions","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtools.MatModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.MatModule.massdensity-Tuple{AbstractMat}","page":"Functions","title":"FinEtools.MatModule.massdensity","text":"massdensity(self::AbstractMat)\n\nReturn mass density.\n\n\n\n\n\n","category":"method"}]
}
